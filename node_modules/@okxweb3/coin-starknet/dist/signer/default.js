"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Signer = void 0;
const ec_1 = require("../utils/ec");
const encode_1 = require("../utils/encode");
const hash_1 = require("../utils/hash");
const num_1 = require("../utils/num");
const transaction_1 = require("../utils/transaction");
const typedData_1 = require("../utils/typedData");
const calldata_1 = require("../utils/calldata");
class Signer {
    constructor(pk = ec_1.starkCurve.utils.randomPrivateKey()) {
        this.pk = pk instanceof Uint8Array ? (0, encode_1.buf2hex)(pk) : (0, num_1.toHex)(pk);
    }
    async getPubKey() {
        return ec_1.starkCurve.getStarkKey(this.pk);
    }
    async signMessage(typedData, accountAddress) {
        const msgHash = (0, typedData_1.getMessageHash)(typedData, accountAddress);
        return ec_1.starkCurve.sign(msgHash, this.pk);
    }
    async signTransaction(transactions, transactionsDetail, abis) {
        if (abis && abis.length !== transactions.length) {
            throw new Error('ABI must be provided for each transaction or no transaction');
        }
        const calldata = (0, transaction_1.getExecuteCalldata)(transactions, transactionsDetail.cairoVersion);
        const msgHash = (0, hash_1.calculateTransactionHash)(transactionsDetail.walletAddress, transactionsDetail.version, calldata, transactionsDetail.maxFee, transactionsDetail.chainId, transactionsDetail.nonce);
        const sig = ec_1.starkCurve.sign(msgHash, this.pk);
        return { signature: sig, hash: msgHash };
    }
    async signDeployAccountTransaction({ classHash, contractAddress, constructorCalldata, addressSalt, maxFee, version, chainId, nonce, }) {
        const msgHash = (0, hash_1.calculateDeployAccountTransactionHash)(contractAddress, classHash, calldata_1.CallData.compile(constructorCalldata), addressSalt, version, maxFee, chainId, nonce);
        const sig = ec_1.starkCurve.sign(msgHash, this.pk);
        return { signature: sig, hash: msgHash };
    }
    async signDeclareTransaction({ classHash, senderAddress, chainId, maxFee, version, nonce, compiledClassHash, }) {
        const msgHash = (0, hash_1.calculateDeclareTransactionHash)(classHash, senderAddress, version, maxFee, chainId, nonce, compiledClassHash);
        return ec_1.starkCurve.sign(msgHash, this.pk);
    }
}
exports.Signer = Signer;
//# sourceMappingURL=default.js.map