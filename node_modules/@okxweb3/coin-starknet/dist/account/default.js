"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Account = void 0;
const constants_1 = require("../constants");
const signer_1 = require("../signer");
const types_1 = require("../types");
const contract_1 = require("../utils/contract");
const ec_1 = require("../utils/ec");
const hash_1 = require("../utils/hash");
const num_1 = require("../utils/num");
const provider_1 = require("../utils/provider");
const stark_1 = require("../utils/stark");
const transaction_1 = require("../utils/transaction");
const typedData_1 = require("../utils/typedData");
const calldata_1 = require("../utils/calldata");
class Account {
    constructor(address, pkOrSigner, cairoVersion = '0') {
        this.address = address.toLowerCase();
        this.signer =
            typeof pkOrSigner === 'string' || pkOrSigner instanceof Uint8Array
                ? new signer_1.Signer(pkOrSigner)
                : pkOrSigner;
        this.cairoVersion = cairoVersion;
    }
    async signMessage(typedData) {
        return this.signer.signMessage(typedData, this.address);
    }
    async declare(payload, transactionsDetail) {
        if (transactionsDetail.nonce === undefined || transactionsDetail.maxFee === undefined || transactionsDetail.chainId === undefined) {
            throw new Error('missing transaction parameter');
        }
        const declareContractPayload = (0, contract_1.extractContractHashes)(payload);
        const details = {};
        details.nonce = (0, num_1.toBigInt)(transactionsDetail.nonce);
        details.maxFee = transactionsDetail.maxFee;
        details.chainId = transactionsDetail.chainId;
        details.version = !(0, contract_1.isSierra)(payload.contract) ? hash_1.transactionVersion : hash_1.transactionVersion_2;
        const declareContractTransaction = await this.buildDeclareContractTransaction(declareContractPayload, {
            ...details,
            walletAddress: this.address,
            cairoVersion: this.cairoVersion,
        });
        const { senderAddress, contractDefinition, signature, compiledClassHash } = declareContractTransaction;
        if (!(0, contract_1.isSierra)(contractDefinition)) {
            return {
                type: types_1.TransactionType.DECLARE,
                contract_class: contractDefinition,
                nonce: (0, num_1.toHex)(details.nonce),
                signature: (0, stark_1.signatureToDecimalArray)(signature),
                sender_address: senderAddress,
                max_fee: (0, num_1.toHex)(details.maxFee || 0),
                version: '0x1',
            };
        }
        else {
            return {
                type: types_1.TransactionType.DECLARE,
                sender_address: senderAddress,
                compiled_class_hash: compiledClassHash,
                contract_class: contractDefinition,
                nonce: (0, num_1.toHex)(details.nonce),
                signature: (0, stark_1.signatureToDecimalArray)(signature),
                max_fee: (0, num_1.toHex)(details.maxFee || 0),
                version: '0x2',
            };
        }
        throw new Error('RPC do not support Sierra Contracts yet');
    }
    async execute(calls, abis = undefined, transactionsDetail) {
        if (transactionsDetail.nonce === undefined || transactionsDetail.maxFee === undefined || transactionsDetail.chainId === undefined) {
            throw new Error('missing transaction parameter');
        }
        const transactions = Array.isArray(calls) ? calls : [calls];
        const nonce = (0, num_1.toBigInt)(transactionsDetail.nonce);
        const maxFee = transactionsDetail.maxFee;
        const version = (0, num_1.toBigInt)(hash_1.transactionVersion);
        const chainId = transactionsDetail.chainId;
        const signerDetails = {
            walletAddress: this.address,
            nonce,
            maxFee,
            version,
            chainId,
            cairoVersion: this.cairoVersion,
        };
        const sig = await this.signer.signTransaction(transactions, signerDetails, abis);
        const calldata = (0, transaction_1.getExecuteCalldata)(transactions, this.cairoVersion);
        return {
            txId: sig.hash,
            signature: {
                type: types_1.TransactionType.INVOKE,
                sender_address: this.address,
                calldata: calldata_1.CallData.compile(calldata ?? []),
                max_fee: (0, num_1.toHex)(maxFee || 0),
                signature: (0, stark_1.signatureToDecimalArray)(sig.signature),
                version: '0x1',
                nonce: (0, num_1.toHex)(nonce)
            },
        };
    }
    async deploy(payload, details) {
        const params = [].concat(payload).map((it) => {
            const { classHash, salt, unique = true, constructorCalldata = [], } = it;
            const compiledConstructorCallData = calldata_1.CallData.compile(constructorCalldata);
            const deploySalt = salt ?? (0, stark_1.randomAddress)();
            return {
                call: {
                    contractAddress: constants_1.UDC.ADDRESS,
                    entrypoint: constants_1.UDC.ENTRYPOINT,
                    calldata: [
                        classHash,
                        deploySalt,
                        (0, num_1.toCairoBool)(unique),
                        compiledConstructorCallData.length,
                        ...compiledConstructorCallData,
                    ],
                },
                address: (0, hash_1.calculateContractAddressFromHash)(unique ? ec_1.starkCurve.pedersen(this.address, deploySalt) : deploySalt, classHash, compiledConstructorCallData, unique ? constants_1.UDC.ADDRESS : 0),
            };
        });
        const calls = params.map((it) => it.call);
        const addresses = params.map((it) => it.address);
        return await this.execute(calls, undefined, details);
    }
    async deployAccount({ classHash, constructorCalldata = [], addressSalt = 0, contractAddress: providedContractAddress, }, transactionsDetail) {
        if (transactionsDetail.maxFee === undefined || transactionsDetail.chainId === undefined) {
            throw new Error('missing transaction parameter');
        }
        const version = (0, num_1.toBigInt)(hash_1.transactionVersion);
        const nonce = constants_1.ZERO;
        const chainId = transactionsDetail.chainId;
        const compiledCalldata = calldata_1.CallData.compile(constructorCalldata);
        const contractAddress = providedContractAddress ??
            (0, hash_1.calculateContractAddressFromHash)(addressSalt, classHash, compiledCalldata, 0);
        const maxFee = transactionsDetail.maxFee;
        const sig = await this.signer.signDeployAccountTransaction({
            classHash,
            constructorCalldata,
            contractAddress,
            addressSalt,
            chainId,
            maxFee,
            version,
            nonce,
        });
        return {
            txId: sig.hash,
            signature: {
                type: types_1.TransactionType.DEPLOY_ACCOUNT,
                contract_address_salt: addressSalt,
                constructor_calldata: calldata_1.CallData.compile(constructorCalldata ?? []),
                class_hash: (0, num_1.toHex)(classHash),
                max_fee: (0, num_1.toHex)(maxFee || 0),
                version: (0, num_1.toHex)(version || 0),
                nonce: (0, num_1.toHex)(nonce),
                signature: (0, stark_1.signatureToDecimalArray)(sig.signature)
            }
        };
    }
    async buildDeclareContractTransaction(payload, { nonce, chainId, version, walletAddress, maxFee }) {
        const { classHash, contract, compiledClassHash } = (0, contract_1.extractContractHashes)(payload);
        const contractDefinition = (0, provider_1.parseContract)(contract);
        const signature = await this.signer.signDeclareTransaction({
            classHash,
            compiledClassHash,
            senderAddress: walletAddress,
            chainId,
            maxFee,
            version,
            nonce,
        });
        return {
            senderAddress: walletAddress,
            signature,
            contractDefinition,
            compiledClassHash,
        };
    }
    async hashMessage(typedData) {
        return (0, typedData_1.getMessageHash)(typedData, this.address);
    }
}
exports.Account = Account;
//# sourceMappingURL=default.js.map