"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StarknetWallet = void 0;
const coin_base_1 = require("@okxweb3/coin-base");
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const index_1 = require("./index");
function validateHexString(value) {
    if (!value) {
        return false;
    }
    const hexStr = value.toLowerCase().startsWith("0x") ? value.substring(2).toLowerCase() : value.toLowerCase();
    if (hexStr.length === 0) {
        return false;
    }
    if (!hexStr.match(/^[0-9A-Fa-f]*$/)) {
        return false;
    }
    return true;
}
function checkPrivateKey(privateKeyHex) {
    if (!validateHexString(privateKeyHex)) {
        return false;
    }
    const keyBytes = crypto_lib_1.base.fromHex(privateKeyHex.toLowerCase());
    if (keyBytes.length < 25 || keyBytes.length > 33) {
        return false;
    }
    return true;
}
class StarknetWallet extends coin_base_1.BaseWallet {
    getRandomPrivateKey() {
        return (0, index_1.GetRandomPrivateKey)();
    }
    async getDerivedPath(param) {
        return `m/44'/9004'/0'/0/${param.index}`;
    }
    async getDerivedPrivateKey(param) {
        return crypto_lib_1.bip39.mnemonicToSeed(param.mnemonic)
            .then((masterSeed) => {
            let ethKey = crypto_lib_1.bip32.fromSeed(masterSeed).derivePath("m/44'/60'/0'/0/0");
            if (!ethKey.privateKey) {
                return Promise.reject(coin_base_1.GenPrivateKeyError);
            }
            let starkKey = Buffer.from(ethKey.privateKey);
            let childKey = crypto_lib_1.bip32.fromSeed(starkKey).derivePath(param.hdPath);
            if (childKey.privateKey) {
                let hdKey = crypto_lib_1.base.toHex(childKey.privateKey);
                let privateKey = index_1.ec.starkCurve.grindKey(hdKey);
                return Promise.resolve(`0x${privateKey}`);
            }
            else {
                return Promise.reject(coin_base_1.GenPrivateKeyError);
            }
        }).catch((e) => {
            return Promise.reject(coin_base_1.GenPrivateKeyError + ":" + e);
        });
    }
    async getNewAddress(param) {
        if (!checkPrivateKey(param.privateKey)) {
            throw new Error('invalid key');
        }
        try {
            const pri = (0, index_1.modPrivateKey)(param.privateKey);
            const pub = index_1.ec.starkCurve.getStarkKey(pri);
            const address = (0, index_1.CalculateContractAddressFromHash)(pub);
            let data = {
                address: address,
                publicKey: pub
            };
            return Promise.resolve(data);
        }
        catch (e) {
            return Promise.reject(coin_base_1.NewAddressError + ":" + e);
        }
    }
    async validPrivateKey(param) {
        let isValid = checkPrivateKey(param.privateKey);
        const data = {
            isValid: isValid,
            privateKey: param.privateKey
        };
        return Promise.resolve(data);
    }
    async signTransaction(param) {
        try {
            const data = param.data;
            if (data.nonce === undefined || data.maxFee === undefined) {
                return Promise.reject(coin_base_1.SignTxError);
            }
            const nonce = data.nonce;
            const max_fee = data.maxFee;
            const chain_id = data.chainId || index_1.constants.StarknetChainId.SN_MAIN;
            const pri = (0, index_1.modPrivateKey)(param.privateKey);
            if (data.type == 'transfer' && data.transferData !== undefined) {
                const contractAddress = data.transferData.contractAddress;
                const from = data.transferData.from;
                const to = data.transferData.to;
                const amount = data.transferData.amount;
                const tx = await (0, index_1.CreateTransferTx)(contractAddress, from, to, amount, nonce, max_fee, chain_id, pri);
                return Promise.resolve(tx);
            }
            else if (data.type == 'deploy_account') {
                const tx = await (0, index_1.CreateSignedDeployAccountTx)(nonce, max_fee, chain_id, pri);
                return Promise.resolve(tx);
            }
            else if (data.type == 'contract_call' && data.contractCallData !== undefined) {
                const contractAddress = data.contractCallData.contractAddress;
                const from = data.contractCallData.from;
                const functionName = data.contractCallData.functionName;
                const callData = data.contractCallData.callData;
                const tx = await (0, index_1.CreateContractCall)(contractAddress, from, functionName, callData, nonce, max_fee, chain_id, pri);
                return Promise.resolve(tx);
            }
            else if (data.type == 'multi_contract_call' && data.multiContractCallData !== undefined) {
                const from = data.multiContractCallData.from;
                const calls = data.multiContractCallData.calls;
                const tx = (0, index_1.CreateMultiContractCall)(from, calls, nonce, max_fee, chain_id, pri);
                return Promise.resolve(tx);
            }
            return Promise.reject(coin_base_1.SignTxError);
        }
        catch (e) {
            return Promise.reject(coin_base_1.SignTxError + ":" + e);
        }
    }
    async validAddress(param) {
        let isValid;
        try {
            (0, index_1.validateAndParseAddress)(param.address);
            isValid = (param.address.startsWith("0x") && param.address.length > 50);
        }
        catch (e) {
            isValid = false;
        }
        let data = {
            isValid: isValid,
            address: param.address,
        };
        return Promise.resolve(data);
    }
    async signMessage(param) {
        try {
            const pri = (0, index_1.modPrivateKey)(param.privateKey);
            if (typeof param.data.message === "string") {
                const msg = param.data.message;
                if (msg.startsWith("0x")) {
                    const signature = (0, index_1.signMessage)(msg, pri);
                    return Promise.resolve(signature);
                }
            }
            else {
                const typedDataValidate = param.data.message;
                const signature = await (0, index_1.signMessageWithTypeData)(typedDataValidate, pri);
                return Promise.resolve(signature);
            }
        }
        catch (e) {
            return Promise.reject(coin_base_1.SignTxError + ":" + e);
        }
    }
    verifyMessage(param) {
        try {
            const sig = param.data.signature;
            const hash = param.data.hash;
            const publicKey = param.data.publicKey;
            return Promise.resolve((0, index_1.verifyMessage)(sig, hash, publicKey));
        }
        catch (e) {
            return Promise.reject(e);
        }
    }
}
exports.StarknetWallet = StarknetWallet;
//# sourceMappingURL=StarknetWallet.js.map