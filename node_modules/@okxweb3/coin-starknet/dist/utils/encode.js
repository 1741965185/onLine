"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.utf8ToArray = exports.sanitizeHex = exports.sanitizeBytes = exports.calcByteLength = exports.padLeft = exports.addHexPrefix = exports.removeHexPrefix = exports.buf2hex = exports.btoaUniversal = exports.arrayBufferToString = exports.IS_BROWSER = void 0;
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof global !== "undefined")
        return global;
    throw "Unable to locate global object";
})();
const btoa = globalThis.btoa || ((bin) => globalThis.Buffer.from(bin, "binary").toString("base64"));
exports.IS_BROWSER = typeof window !== 'undefined';
const STRING_ZERO = '0';
function arrayBufferToString(array) {
    return new Uint8Array(array).reduce((data, byte) => data + String.fromCharCode(byte), '');
}
exports.arrayBufferToString = arrayBufferToString;
function btoaUniversal(b) {
    return exports.IS_BROWSER ? btoa(arrayBufferToString(b)) : Buffer.from(b).toString('base64');
}
exports.btoaUniversal = btoaUniversal;
function buf2hex(buffer) {
    return [...buffer].map((x) => x.toString(16).padStart(2, '0')).join('');
}
exports.buf2hex = buf2hex;
function removeHexPrefix(hex) {
    return hex.replace(/^0x/i, '');
}
exports.removeHexPrefix = removeHexPrefix;
function addHexPrefix(hex) {
    return `0x${removeHexPrefix(hex)}`;
}
exports.addHexPrefix = addHexPrefix;
function padString(str, length, left, padding = STRING_ZERO) {
    const diff = length - str.length;
    let result = str;
    if (diff > 0) {
        const pad = padding.repeat(diff);
        result = left ? pad + str : str + pad;
    }
    return result;
}
function padLeft(str, length, padding = STRING_ZERO) {
    return padString(str, length, true, padding);
}
exports.padLeft = padLeft;
function calcByteLength(length, byteSize = 8) {
    const remainder = length % byteSize;
    return remainder ? ((length - remainder) / byteSize) * byteSize + byteSize : length;
}
exports.calcByteLength = calcByteLength;
function sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {
    return padLeft(str, calcByteLength(str.length, byteSize), padding);
}
exports.sanitizeBytes = sanitizeBytes;
function sanitizeHex(hex) {
    hex = removeHexPrefix(hex);
    hex = sanitizeBytes(hex, 2);
    if (hex) {
        hex = addHexPrefix(hex);
    }
    return hex;
}
exports.sanitizeHex = sanitizeHex;
function utf8ToArray(str) {
    return new TextEncoder().encode(str);
}
exports.utf8ToArray = utf8ToArray;
//# sourceMappingURL=encode.js.map