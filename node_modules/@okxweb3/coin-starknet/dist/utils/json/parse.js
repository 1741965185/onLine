"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.codeLowercaseF = exports.codeUppercaseF = exports.codeLowercaseE = exports.codeUppercaseE = exports.codeLowercaseA = exports.codeUppercaseA = exports.isDeepEqual = exports.isValidStringCharacter = exports.parse = void 0;
const numberParsers_1 = require("./numberParsers");
const revive_1 = require("./revive");
function parse(text, reviver, parseNumber = numberParsers_1.parseLosslessNumber) {
    let i = 0;
    const value = parseValue();
    expectValue(value);
    expectEndOfInput();
    return reviver ? (0, revive_1.revive)(value, reviver) : value;
    function parseObject() {
        if (text.charCodeAt(i) === codeOpeningBrace) {
            i++;
            skipWhitespace();
            const object = {};
            let initial = true;
            while (i < text.length && text.charCodeAt(i) !== codeClosingBrace) {
                if (!initial) {
                    eatComma();
                    skipWhitespace();
                }
                else {
                    initial = false;
                }
                const start = i;
                const key = parseString();
                if (key === undefined) {
                    throw new SyntaxError(`Quoted object key expected ${gotAt()}`);
                }
                skipWhitespace();
                eatColon();
                const value = parseValue();
                if (value === undefined) {
                    throwObjectValueExpected();
                }
                if (Object.prototype.hasOwnProperty.call(object, key) && !isDeepEqual(value, object[key])) {
                    throwDuplicateKey(key, start + 1);
                }
                object[key] = value;
            }
            if (text.charCodeAt(i) !== codeClosingBrace) {
                throwObjectKeyOrEndExpected();
            }
            i++;
            return object;
        }
    }
    function parseArray() {
        if (text.charCodeAt(i) === codeOpeningBracket) {
            i++;
            skipWhitespace();
            const array = [];
            let initial = true;
            while (i < text.length && text.charCodeAt(i) !== codeClosingBracket) {
                if (!initial) {
                    eatComma();
                }
                else {
                    initial = false;
                }
                const value = parseValue();
                expectArrayItem(value);
                array.push(value);
            }
            if (text.charCodeAt(i) !== codeClosingBracket) {
                throwArrayItemOrEndExpected();
            }
            i++;
            return array;
        }
    }
    function parseValue() {
        skipWhitespace();
        const value = parseString() ??
            parseNumeric() ??
            parseObject() ??
            parseArray() ??
            parseKeyword('true', true) ??
            parseKeyword('false', false) ??
            parseKeyword('null', null);
        skipWhitespace();
        return value;
    }
    function parseKeyword(name, value) {
        if (text.slice(i, i + name.length) === name) {
            i += name.length;
            return value;
        }
    }
    function skipWhitespace() {
        while (isWhitespace(text.charCodeAt(i))) {
            i++;
        }
    }
    function parseString() {
        if (text.charCodeAt(i) === codeDoubleQuote) {
            i++;
            let result = '';
            while (i < text.length && text.charCodeAt(i) !== codeDoubleQuote) {
                if (text.charCodeAt(i) === codeBackslash) {
                    const char = text[i + 1];
                    const escapeChar = escapeCharacters[char];
                    if (escapeChar !== undefined) {
                        result += escapeChar;
                        i++;
                    }
                    else if (char === 'u') {
                        if (isHex(text.charCodeAt(i + 2)) &&
                            isHex(text.charCodeAt(i + 3)) &&
                            isHex(text.charCodeAt(i + 4)) &&
                            isHex(text.charCodeAt(i + 5))) {
                            result += String.fromCharCode(parseInt(text.slice(i + 2, i + 6), 16));
                            i += 5;
                        }
                        else {
                            throwInvalidUnicodeCharacter(i);
                        }
                    }
                    else {
                        throwInvalidEscapeCharacter(i);
                    }
                }
                else {
                    if (isValidStringCharacter(text.charCodeAt(i))) {
                        result += text[i];
                    }
                    else {
                        throwInvalidCharacter(text[i]);
                    }
                }
                i++;
            }
            expectEndOfString();
            i++;
            return result;
        }
    }
    function parseNumeric() {
        const start = i;
        if (text.charCodeAt(i) === codeMinus) {
            i++;
            expectDigit(start);
        }
        if (text.charCodeAt(i) === codeZero) {
            i++;
        }
        else if (isNonZeroDigit(text.charCodeAt(i))) {
            i++;
            while (isDigit(text.charCodeAt(i))) {
                i++;
            }
        }
        if (text.charCodeAt(i) === codeDot) {
            i++;
            expectDigit(start);
            while (isDigit(text.charCodeAt(i))) {
                i++;
            }
        }
        if (text.charCodeAt(i) === exports.codeLowercaseE || text.charCodeAt(i) === exports.codeUppercaseE) {
            i++;
            if (text.charCodeAt(i) === codeMinus || text.charCodeAt(i) === codePlus) {
                i++;
            }
            expectDigit(start);
            while (isDigit(text.charCodeAt(i))) {
                i++;
            }
        }
        if (i > start) {
            return parseNumber(text.slice(start, i));
        }
    }
    function eatComma() {
        if (text.charCodeAt(i) !== codeComma) {
            throw new SyntaxError(`Comma ',' expected after value ${gotAt()}`);
        }
        i++;
    }
    function eatColon() {
        if (text.charCodeAt(i) !== codeColon) {
            throw new SyntaxError(`Colon ':' expected after property name ${gotAt()}`);
        }
        i++;
    }
    function expectValue(value) {
        if (value === undefined) {
            throw new SyntaxError(`JSON value expected ${gotAt()}`);
        }
    }
    function expectArrayItem(value) {
        if (value === undefined) {
            throw new SyntaxError(`Array item expected ${gotAt()}`);
        }
    }
    function expectEndOfInput() {
        if (i < text.length) {
            throw new SyntaxError(`Expected end of input ${gotAt()}`);
        }
    }
    function expectDigit(start) {
        if (!isDigit(text.charCodeAt(i))) {
            const numSoFar = text.slice(start, i);
            throw new SyntaxError(`Invalid number '${numSoFar}', expecting a digit ${gotAt()}`);
        }
    }
    function expectEndOfString() {
        if (text.charCodeAt(i) !== codeDoubleQuote) {
            throw new SyntaxError(`End of string '"' expected ${gotAt()}`);
        }
    }
    function throwObjectKeyExpected() {
        throw new SyntaxError(`Quoted object key expected ${gotAt()}`);
    }
    function throwDuplicateKey(key, pos) {
        throw new SyntaxError(`Duplicate key '${key}' encountered at position ${pos}`);
    }
    function throwObjectKeyOrEndExpected() {
        throw new SyntaxError(`Quoted object key or end of object '}' expected ${gotAt()}`);
    }
    function throwArrayItemOrEndExpected() {
        throw new SyntaxError(`Array item or end of array ']' expected ${gotAt()}`);
    }
    function throwInvalidCharacter(char) {
        throw new SyntaxError(`Invalid character '${char}' ${pos()}`);
    }
    function throwInvalidEscapeCharacter(start) {
        const chars = text.slice(start, start + 2);
        throw new SyntaxError(`Invalid escape character '${chars}' ${pos()}`);
    }
    function throwObjectValueExpected() {
        throw new SyntaxError(`Object value expected after ':' ${pos()}`);
    }
    function throwInvalidUnicodeCharacter(start) {
        let end = start + 2;
        while (/\w/.test(text[end])) {
            end++;
        }
        const chars = text.slice(start, end);
        throw new SyntaxError(`Invalid unicode character '${chars}' ${pos()}`);
    }
    function pos() {
        return `at position ${i}`;
    }
    function got() {
        return i < text.length ? `but got '${text[i]}'` : 'but reached end of input';
    }
    function gotAt() {
        return got() + ' ' + pos();
    }
}
exports.parse = parse;
function isWhitespace(code) {
    return code === codeSpace || code === codeNewline || code === codeTab || code === codeReturn;
}
function isHex(code) {
    return ((code >= codeZero && code <= codeNine) ||
        (code >= exports.codeUppercaseA && code <= exports.codeUppercaseF) ||
        (code >= exports.codeLowercaseA && code <= exports.codeLowercaseF));
}
function isDigit(code) {
    return code >= codeZero && code <= codeNine;
}
function isNonZeroDigit(code) {
    return code >= codeOne && code <= codeNine;
}
function isValidStringCharacter(code) {
    return code >= 0x20 && code <= 0x10ffff;
}
exports.isValidStringCharacter = isValidStringCharacter;
function isDeepEqual(a, b) {
    if (a === b) {
        return true;
    }
    if (Array.isArray(a) && Array.isArray(b)) {
        return a.length === b.length && a.every((item, index) => isDeepEqual(item, b[index]));
    }
    if (isObject(a) && isObject(b)) {
        const keys = [...new Set([...Object.keys(a), ...Object.keys(b)])];
        return keys.every((key) => isDeepEqual(a[key], b[key]));
    }
    return false;
}
exports.isDeepEqual = isDeepEqual;
function isObject(value) {
    return typeof value === 'object' && value !== null;
}
const escapeCharacters = {
    '"': '"',
    '\\': '\\',
    '/': '/',
    b: '\b',
    f: '\f',
    n: '\n',
    r: '\r',
    t: '\t'
};
const codeBackslash = 0x5c;
const codeOpeningBrace = 0x7b;
const codeClosingBrace = 0x7d;
const codeOpeningBracket = 0x5b;
const codeClosingBracket = 0x5d;
const codeSpace = 0x20;
const codeNewline = 0xa;
const codeTab = 0x9;
const codeReturn = 0xd;
const codeDoubleQuote = 0x0022;
const codePlus = 0x2b;
const codeMinus = 0x2d;
const codeZero = 0x30;
const codeOne = 0x31;
const codeNine = 0x39;
const codeComma = 0x2c;
const codeDot = 0x2e;
const codeColon = 0x3a;
exports.codeUppercaseA = 0x41;
exports.codeLowercaseA = 0x61;
exports.codeUppercaseE = 0x45;
exports.codeLowercaseE = 0x65;
exports.codeUppercaseF = 0x46;
exports.codeLowercaseF = 0x66;
//# sourceMappingURL=parse.js.map