"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.felt = exports.tuple = exports.uint256 = exports.isTypeStruct = exports.isTypeNamedTuple = exports.isTypeTuple = exports.isTypeArray = exports.isTypeFeltArray = exports.isTypeFelt = exports.isLen = void 0;
const num_1 = require("../num");
const shortString_1 = require("../shortString");
const uint256_1 = require("../uint256");
const isLen = (name) => /_len$/.test(name);
exports.isLen = isLen;
const isTypeFelt = (type) => type === 'felt';
exports.isTypeFelt = isTypeFelt;
const isTypeFeltArray = (type) => type === 'felt*';
exports.isTypeFeltArray = isTypeFeltArray;
const isTypeArray = (type) => /\*/.test(type);
exports.isTypeArray = isTypeArray;
const isTypeTuple = (type) => /^\(.*\)$/i.test(type);
exports.isTypeTuple = isTypeTuple;
const isTypeNamedTuple = (type) => /\(.*\)/i.test(type) && type.includes(':');
exports.isTypeNamedTuple = isTypeNamedTuple;
const isTypeStruct = (type, structs) => type in structs;
exports.isTypeStruct = isTypeStruct;
const uint256 = (it) => {
    const bn = BigInt(it);
    if (!(0, uint256_1.isUint256)(bn))
        throw new Error('Number is too large');
    return {
        low: (bn & uint256_1.UINT_128_MAX).toString(10),
        high: (bn >> 128n).toString(10),
    };
};
exports.uint256 = uint256;
const tuple = (...args) => ({ ...args });
exports.tuple = tuple;
function felt(it) {
    if ((0, num_1.isBigInt)(it) || (typeof it === 'number' && Number.isInteger(it))) {
        return it.toString();
    }
    if ((0, shortString_1.isText)(it)) {
        if (!(0, shortString_1.isShortString)(it))
            throw new Error(`${it} is a long string > 31 chars, felt can store short strings, split it to array of short strings`);
        const encoded = (0, shortString_1.encodeShortString)(it);
        return BigInt(encoded).toString();
    }
    if (typeof it === 'string' && (0, num_1.isHex)(it)) {
        return BigInt(it).toString();
    }
    if (typeof it === 'string' && (0, num_1.isStringWholeNumber)(it)) {
        return it;
    }
    throw new Error(`${it} can't be computed by felt()`);
}
exports.felt = felt;
//# sourceMappingURL=cairo.js.map