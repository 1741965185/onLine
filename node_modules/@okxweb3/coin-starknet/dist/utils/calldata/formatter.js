"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const num_1 = require("../num");
const shortString_1 = require("../shortString");
const guard = {
    isBN: (data, type, key) => {
        if (!(0, num_1.isBigInt)(data[key]))
            throw new Error(`Data and formatter mismatch on ${key}:${type[key]}, expected response data ${key}:${data[key]} to be BN instead it is ${typeof data[key]}`);
    },
    unknown: (data, type, key) => {
        throw new Error(`Unhandled formatter type on ${key}:${type[key]} for data ${key}:${data[key]}`);
    },
};
function formatter(data, type, sameType) {
    return Object.entries(data).reduce((acc, [key, value]) => {
        const elType = sameType ?? type[key];
        if (!(key in type) && !sameType) {
            acc[key] = value;
            return acc;
        }
        if (elType === 'string') {
            if (Array.isArray(data[key])) {
                const arrayStr = formatter(data[key], data[key].map((_) => elType));
                acc[key] = Object.values(arrayStr).join('');
                return acc;
            }
            guard.isBN(data, type, key);
            acc[key] = (0, shortString_1.decodeShortString)(value);
            return acc;
        }
        if (elType === 'number') {
            guard.isBN(data, type, key);
            acc[key] = Number(value);
            return acc;
        }
        if (typeof elType === 'function') {
            acc[key] = elType(value);
            return acc;
        }
        if (Array.isArray(elType)) {
            const arrayObj = formatter(data[key], elType, elType[0]);
            acc[key] = Object.values(arrayObj);
            return acc;
        }
        if (typeof elType === 'object') {
            acc[key] = formatter(data[key], elType);
            return acc;
        }
        guard.unknown(data, type, key);
        return acc;
    }, {});
}
exports.default = formatter;
//# sourceMappingURL=formatter.js.map