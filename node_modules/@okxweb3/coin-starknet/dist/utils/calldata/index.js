"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CallData = void 0;
const assert_1 = __importDefault(require("../assert"));
const num_1 = require("../num");
const shortString_1 = require("../shortString");
const cairo_1 = require("./cairo");
const formatter_1 = __importDefault(require("./formatter"));
const requestParser_1 = require("./requestParser");
const responseParser_1 = __importDefault(require("./responseParser"));
const validate_1 = __importDefault(require("./validate"));
class CallData {
    constructor(abi) {
        this.abi = abi;
        this.structs = CallData.getAbiStruct(abi);
    }
    validate(type, method, args = []) {
        if (type !== 'DEPLOY') {
            const invocableFunctionNames = this.abi
                .filter((abi) => {
                if (abi.type !== 'function')
                    return false;
                const isView = abi.stateMutability === 'view' || abi.state_mutability === 'view';
                return type === 'INVOKE' ? !isView : isView;
            })
                .map((abi) => abi.name);
            (0, assert_1.default)(invocableFunctionNames.includes(method), `${type === 'INVOKE' ? 'invocable' : 'viewable'} method not found in abi`);
        }
        const abiMethod = this.abi.find((abi) => type === 'DEPLOY'
            ? abi.name === method && abi.type === method
            : abi.name === method && abi.type === 'function');
        const inputsLength = CallData.abiInputsLength(abiMethod.inputs);
        if (args.length !== inputsLength) {
            throw Error(`Invalid number of arguments, expected ${inputsLength} arguments, but got ${args.length}`);
        }
        (0, validate_1.default)(abiMethod, args, this.structs);
    }
    compile(args, inputs) {
        const argsIterator = args[Symbol.iterator]();
        return inputs.reduce((acc, input) => (0, cairo_1.isLen)(input.name) ? acc : acc.concat((0, requestParser_1.parseCalldataField)(argsIterator, input, this.structs)), []);
    }
    static compile(data) {
        const createTree = (obj) => {
            const getEntries = (o, prefix = '') => {
                const oe = Array.isArray(o) ? [o.length.toString(), ...o] : o;
                return Object.entries(oe).flatMap(([k, v]) => {
                    let value = v;
                    if ((0, shortString_1.isLongText)(value))
                        value = (0, shortString_1.splitLongString)(value);
                    const kk = Array.isArray(oe) && k === '0' ? '$$len' : k;
                    if ((0, num_1.isBigInt)(value))
                        return [[`${prefix}${kk}`, (0, cairo_1.felt)(value)]];
                    return Object(value) === value
                        ? getEntries(value, `${prefix}${kk}.`)
                        : [[`${prefix}${kk}`, (0, cairo_1.felt)(value)]];
                });
            };
            return Object.fromEntries(getEntries(obj));
        };
        let callTreeArray;
        if (!Array.isArray(data)) {
            const callTree = createTree(data);
            callTreeArray = Object.values(callTree);
        }
        else {
            callTreeArray = data;
        }
        Object.defineProperty(callTreeArray, 'compiled', {
            enumerable: false,
            writable: false,
            value: true,
        });
        return callTreeArray;
    }
    parse(method, response) {
        const { outputs } = this.abi.find((abi) => abi.name === method);
        const responseIterator = response.flat()[Symbol.iterator]();
        return outputs.flat().reduce((acc, output) => {
            acc[output.name] = (0, responseParser_1.default)(responseIterator, output, this.structs, acc);
            if (acc[output.name] && acc[`${output.name}_len`]) {
                delete acc[`${output.name}_len`];
            }
            return acc;
        }, {});
    }
    format(method, response, format) {
        const parsed = this.parse(method, response);
        return (0, formatter_1.default)(parsed, format);
    }
    static abiInputsLength(inputs) {
        return inputs.reduce((acc, input) => (!(0, cairo_1.isLen)(input.name) ? acc + 1 : acc), 0);
    }
    static getAbiStruct(abi) {
        return abi
            .filter((abiEntry) => abiEntry.type === 'struct')
            .reduce((acc, abiEntry) => ({
            ...acc,
            [abiEntry.name]: abiEntry,
        }), {});
    }
}
exports.CallData = CallData;
//# sourceMappingURL=index.js.map