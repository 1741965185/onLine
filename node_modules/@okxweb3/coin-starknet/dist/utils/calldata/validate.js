"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("../assert"));
const shortString_1 = require("../shortString");
const cairo_1 = require("./cairo");
const validateFelt = (parameter, input) => {
    (0, assert_1.default)(typeof parameter === 'string' || typeof parameter === 'number' || typeof parameter === 'bigint', `Validate: arg ${input.name} should be a felt (string, number, BigNumber)`);
};
const validateStruct = (parameter, input, structs) => {
    (0, assert_1.default)(typeof parameter === 'object' && !Array.isArray(parameter), `Validate: arg ${input.name} is cairo type struct (${input.type}), and should be defined as js object (not array)`);
    structs[input.type].members.forEach(({ name }) => {
        (0, assert_1.default)(Object.keys(parameter).includes(name), `Validate: arg ${input.name} should have a property ${name}`);
    });
};
const validateTuple = (parameter, input) => {
    (0, assert_1.default)(typeof parameter === 'object' && !Array.isArray(parameter), `Validate: arg ${input.name} should be a tuple (defined as object)`);
};
const validateArray = (parameter, input, structs) => {
    const baseType = input.type.replace('*', '');
    if ((0, cairo_1.isTypeFelt)(baseType) && (0, shortString_1.isLongText)(parameter))
        return;
    (0, assert_1.default)(Array.isArray(parameter), `Validate: arg ${input.name} should be an Array`);
    switch (true) {
        case (0, cairo_1.isTypeFelt)(baseType):
            parameter.forEach((param) => validateFelt(param, input));
            break;
        case (0, cairo_1.isTypeTuple)(baseType):
            parameter.forEach((it) => validateTuple(it, { name: input.name, type: baseType }));
            break;
        case (0, cairo_1.isTypeStruct)(baseType, structs):
            parameter.forEach((it) => validateStruct(it, { name: input.name, type: baseType }, structs));
            break;
        default:
            throw new Error(`Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`);
    }
};
function validateFields(abiMethod, args, structs) {
    abiMethod.inputs.reduce((acc, input) => {
        const parameter = args[acc];
        switch (true) {
            case (0, cairo_1.isLen)(input.name):
                return acc;
            case (0, cairo_1.isTypeFelt)(input.type):
                validateFelt(parameter, input);
                break;
            case (0, cairo_1.isTypeStruct)(input.type, structs):
                validateStruct(parameter, input, structs);
                break;
            case (0, cairo_1.isTypeTuple)(input.type):
                validateTuple(parameter, input);
                break;
            case (0, cairo_1.isTypeArray)(input.type):
                validateArray(parameter, input, structs);
                break;
            default:
                throw new Error(`Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`);
        }
        return acc + 1;
    }, 0);
}
exports.default = validateFields;
//# sourceMappingURL=validate.js.map