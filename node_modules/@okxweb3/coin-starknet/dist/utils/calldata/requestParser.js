"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseCalldataField = void 0;
const shortString_1 = require("../shortString");
const cairo_1 = require("./cairo");
const tuple_1 = __importDefault(require("./tuple"));
function parseTuple(element, typeStr) {
    const memberTypes = (0, tuple_1.default)(typeStr);
    const elements = Object.values(element);
    if (elements.length !== memberTypes.length) {
        throw Error(`ParseTuple: provided and expected abi tuple size do not match.
      provided: ${elements} 
      expected: ${memberTypes}`);
    }
    return memberTypes.map((it, dx) => {
        return {
            element: elements[dx],
            type: it.type ?? it,
        };
    });
}
function parseCalldataValue(element, type, structs) {
    if (element === undefined) {
        throw Error(`Missing parameter for type ${type}`);
    }
    if (Array.isArray(element)) {
        throw Error(`Array inside array (nD) are not supported by cairo. Element: ${element} ${type}`);
    }
    if (structs[type] && structs[type].members.length) {
        const { members } = structs[type];
        const subElement = element;
        return members.reduce((acc, it) => {
            return acc.concat(parseCalldataValue(subElement[it.name], it.type, structs));
        }, []);
    }
    if ((0, cairo_1.isTypeTuple)(type)) {
        const tupled = parseTuple(element, type);
        return tupled.reduce((acc, it) => {
            const parsedData = parseCalldataValue(it.element, it.type, structs);
            return acc.concat(parsedData);
        }, []);
    }
    if (typeof element === 'object') {
        throw Error(`Parameter ${element} do not align with abi parameter ${type}`);
    }
    return (0, cairo_1.felt)(element);
}
function parseCalldataField(argsIterator, input, structs) {
    const { name, type } = input;
    let { value } = argsIterator.next();
    switch (true) {
        case (0, cairo_1.isTypeArray)(type):
            if (!Array.isArray(value) && !(0, shortString_1.isText)(value)) {
                throw Error(`ABI expected parameter ${name} to be array or long string, got ${value}`);
            }
            if (typeof value === 'string') {
                value = (0, shortString_1.splitLongString)(value);
            }
            const result = [];
            result.push((0, cairo_1.felt)(value.length));
            return value.reduce((acc, el) => {
                if ((0, cairo_1.isTypeFeltArray)(type)) {
                    acc.push((0, cairo_1.felt)(el));
                }
                else {
                    acc.push(...parseCalldataValue(el, type.replace('*', ''), structs));
                }
                return acc;
            }, result);
        case (0, cairo_1.isTypeStruct)(type, structs) || (0, cairo_1.isTypeTuple)(type):
            return parseCalldataValue(value, type, structs);
        default:
            return (0, cairo_1.felt)(value);
    }
}
exports.parseCalldataField = parseCalldataField;
//# sourceMappingURL=requestParser.js.map