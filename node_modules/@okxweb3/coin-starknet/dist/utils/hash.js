"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeContractClassHash = exports.computeSierraContractClassHash = exports.computeCompiledClassHash = exports.computeLegacyContractClassHash = exports.formatSpaces = exports.calculateContractAddressFromHash = exports.calculateTransactionHash = exports.calculateDeployAccountTransactionHash = exports.calculateDeclareTransactionHash = exports.calculateDeployTransactionHash = exports.calculateTransactionHashCommon = exports.computeHashOnElements = exports.getSelector = exports.getSelectorFromName = exports.starknetKeccak = exports.keccakBn = exports.feeTransactionVersion = exports.transactionVersion_2 = exports.transactionVersion = void 0;
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const stark = crypto_lib_1.signUtil.schnorr.stark;
const constants_1 = require("../constants");
const cairo_1 = require("./calldata/cairo");
const ec_1 = require("./ec");
const encode_1 = require("./encode");
const num_1 = require("./num");
const shortString_1 = require("./shortString");
const json_1 = require("./json");
exports.transactionVersion = 1n;
exports.transactionVersion_2 = 2n;
exports.feeTransactionVersion = 2n ** 128n + exports.transactionVersion;
function keccakBn(value) {
    const hexWithoutPrefix = (0, encode_1.removeHexPrefix)((0, num_1.toHex)(BigInt(value)));
    const evenHex = hexWithoutPrefix.length % 2 === 0 ? hexWithoutPrefix : `0${hexWithoutPrefix}`;
    return (0, encode_1.addHexPrefix)(stark.keccak((0, num_1.hexToBytes)((0, encode_1.addHexPrefix)(evenHex))).toString(16));
}
exports.keccakBn = keccakBn;
function keccakHex(value) {
    return (0, encode_1.addHexPrefix)(stark.keccak((0, encode_1.utf8ToArray)(value)).toString(16));
}
function starknetKeccak(value) {
    const hash = BigInt(keccakHex(value));
    return hash & constants_1.MASK_250;
}
exports.starknetKeccak = starknetKeccak;
function getSelectorFromName(funcName) {
    return (0, num_1.toHex)(starknetKeccak(funcName));
}
exports.getSelectorFromName = getSelectorFromName;
function getSelector(value) {
    if ((0, num_1.isHex)(value)) {
        return value;
    }
    if ((0, num_1.isStringWholeNumber)(value)) {
        return (0, num_1.toHexString)(value);
    }
    return getSelectorFromName(value);
}
exports.getSelector = getSelector;
function computeHashOnElements(data) {
    return [...data, data.length]
        .reduce((x, y) => ec_1.starkCurve.pedersen((0, num_1.toBigInt)(x), (0, num_1.toBigInt)(y)), 0)
        .toString();
}
exports.computeHashOnElements = computeHashOnElements;
function calculateTransactionHashCommon(txHashPrefix, version, contractAddress, entryPointSelector, calldata, maxFee, chainId, additionalData = []) {
    const calldataHash = computeHashOnElements(calldata);
    const dataToHash = [
        txHashPrefix,
        version,
        contractAddress,
        entryPointSelector,
        calldataHash,
        maxFee,
        chainId,
        ...additionalData,
    ];
    return computeHashOnElements(dataToHash);
}
exports.calculateTransactionHashCommon = calculateTransactionHashCommon;
function calculateDeployTransactionHash(contractAddress, constructorCalldata, version, chainId) {
    return calculateTransactionHashCommon(constants_1.TransactionHashPrefix.DEPLOY, version, contractAddress, getSelectorFromName('constructor'), constructorCalldata, 0, chainId);
}
exports.calculateDeployTransactionHash = calculateDeployTransactionHash;
function calculateDeclareTransactionHash(classHash, senderAddress, version, maxFee, chainId, nonce, compiledClassHash) {
    return calculateTransactionHashCommon(constants_1.TransactionHashPrefix.DECLARE, version, senderAddress, 0, [classHash], maxFee, chainId, [nonce, ...(compiledClassHash ? [compiledClassHash] : [])]);
}
exports.calculateDeclareTransactionHash = calculateDeclareTransactionHash;
function calculateDeployAccountTransactionHash(contractAddress, classHash, constructorCalldata, salt, version, maxFee, chainId, nonce) {
    const calldata = [classHash, salt, ...constructorCalldata];
    return calculateTransactionHashCommon(constants_1.TransactionHashPrefix.DEPLOY_ACCOUNT, version, contractAddress, 0, calldata, maxFee, chainId, [nonce]);
}
exports.calculateDeployAccountTransactionHash = calculateDeployAccountTransactionHash;
function calculateTransactionHash(contractAddress, version, calldata, maxFee, chainId, nonce) {
    return calculateTransactionHashCommon(constants_1.TransactionHashPrefix.INVOKE, version, contractAddress, 0, calldata, maxFee, chainId, [nonce]);
}
exports.calculateTransactionHash = calculateTransactionHash;
function calculateContractAddressFromHash(salt, classHash, constructorCalldata, deployerAddress) {
    const constructorCalldataHash = computeHashOnElements(constructorCalldata);
    const CONTRACT_ADDRESS_PREFIX = (0, cairo_1.felt)('0x535441524b4e45545f434f4e54524143545f41444452455353');
    return computeHashOnElements([
        CONTRACT_ADDRESS_PREFIX,
        deployerAddress,
        salt,
        classHash,
        constructorCalldataHash,
    ]);
}
exports.calculateContractAddressFromHash = calculateContractAddressFromHash;
function nullSkipReplacer(key, value) {
    if (key === 'attributes' || key === 'accessible_scopes') {
        return Array.isArray(value) && value.length === 0 ? undefined : value;
    }
    if (key === 'debug_info') {
        return null;
    }
    return value === null ? undefined : value;
}
function formatSpaces(json) {
    let insideQuotes = false;
    let newString = '';
    for (const char of json) {
        if (char === '"' && newString.endsWith('\\') === false) {
            insideQuotes = !insideQuotes;
        }
        if (insideQuotes) {
            newString += char;
        }
        else {
            newString += char === ':' ? ': ' : char === ',' ? ', ' : char;
        }
    }
    return newString;
}
exports.formatSpaces = formatSpaces;
function computeHintedClassHash(compiledContract) {
    const { abi, program } = compiledContract;
    const contractClass = { abi, program };
    const serializedJson = formatSpaces((0, json_1.stringify)(contractClass, nullSkipReplacer));
    return (0, encode_1.addHexPrefix)(ec_1.starkCurve.keccak((0, encode_1.utf8ToArray)(serializedJson)).toString(16));
}
exports.default = computeHintedClassHash;
function computeLegacyContractClassHash(contract) {
    const compiledContract = typeof contract === 'string' ? (0, json_1.parse)(contract) : contract;
    const apiVersion = (0, num_1.toHex)(constants_1.API_VERSION);
    const externalEntryPointsHash = computeHashOnElements(compiledContract.entry_points_by_type.EXTERNAL.flatMap((e) => [e.selector, e.offset]));
    const l1HandlerEntryPointsHash = computeHashOnElements(compiledContract.entry_points_by_type.L1_HANDLER.flatMap((e) => [e.selector, e.offset]));
    const constructorEntryPointHash = computeHashOnElements(compiledContract.entry_points_by_type.CONSTRUCTOR.flatMap((e) => [e.selector, e.offset]));
    const builtinsHash = computeHashOnElements(compiledContract.program.builtins.map((s) => (0, shortString_1.encodeShortString)(s)));
    const hintedClassHash = computeHintedClassHash(compiledContract);
    const dataHash = computeHashOnElements(compiledContract.program.data);
    return computeHashOnElements([
        apiVersion,
        externalEntryPointsHash,
        l1HandlerEntryPointsHash,
        constructorEntryPointHash,
        builtinsHash,
        hintedClassHash,
        dataHash,
    ]);
}
exports.computeLegacyContractClassHash = computeLegacyContractClassHash;
function hashBuiltins(builtins) {
    return stark.poseidonHashMany(builtins.flatMap((it) => {
        return BigInt((0, shortString_1.encodeShortString)(it));
    }));
}
function hashEntryPoint(data) {
    const base = data.flatMap((it) => {
        return [BigInt(it.selector), BigInt(it.offset), hashBuiltins(it.builtins)];
    });
    return stark.poseidonHashMany(base);
}
function computeCompiledClassHash(casm) {
    const COMPILED_CLASS_VERSION = 'COMPILED_CLASS_V1';
    const compiledClassVersion = BigInt((0, shortString_1.encodeShortString)(COMPILED_CLASS_VERSION));
    const externalEntryPointsHash = hashEntryPoint(casm.entry_points_by_type.EXTERNAL);
    const l1Handlers = hashEntryPoint(casm.entry_points_by_type.L1_HANDLER);
    const constructor = hashEntryPoint(casm.entry_points_by_type.CONSTRUCTOR);
    const bytecode = stark.poseidonHashMany(casm.bytecode.map((it) => BigInt(it)));
    return (0, num_1.toHex)(stark.poseidonHashMany([
        compiledClassVersion,
        externalEntryPointsHash,
        l1Handlers,
        constructor,
        bytecode,
    ]));
}
exports.computeCompiledClassHash = computeCompiledClassHash;
function hashEntryPointSierra(data) {
    const base = data.flatMap((it) => {
        return [BigInt(it.selector), BigInt(it.function_idx)];
    });
    return stark.poseidonHashMany(base);
}
function hashAbi(sierra) {
    const indentString = formatSpaces((0, json_1.stringify)(sierra.abi, undefined));
    return BigInt((0, encode_1.addHexPrefix)(ec_1.starkCurve.keccak((0, encode_1.utf8ToArray)(indentString)).toString(16)));
}
function computeSierraContractClassHash(sierra) {
    const CONTRACT_CLASS_VERSION = 'CONTRACT_CLASS_V0.1.0';
    const compiledClassVersion = BigInt((0, shortString_1.encodeShortString)(CONTRACT_CLASS_VERSION));
    const externalEntryPointsHash = hashEntryPointSierra(sierra.entry_points_by_type.EXTERNAL);
    const l1Handlers = hashEntryPointSierra(sierra.entry_points_by_type.L1_HANDLER);
    const constructor = hashEntryPointSierra(sierra.entry_points_by_type.CONSTRUCTOR);
    const abiHash = hashAbi(sierra);
    const sierraProgram = stark.poseidonHashMany(sierra.sierra_program.map((it) => BigInt(it)));
    return (0, num_1.toHex)(stark.poseidonHashMany([
        compiledClassVersion,
        externalEntryPointsHash,
        l1Handlers,
        constructor,
        abiHash,
        sierraProgram,
    ]));
}
exports.computeSierraContractClassHash = computeSierraContractClassHash;
function computeContractClassHash(contract) {
    const compiledContract = typeof contract === 'string' ? (0, json_1.parse)(contract) : contract;
    if ('sierra_program' in compiledContract) {
        return computeSierraContractClassHash(compiledContract);
    }
    return computeLegacyContractClassHash(compiledContract);
}
exports.computeContractClassHash = computeContractClassHash;
//# sourceMappingURL=hash.js.map