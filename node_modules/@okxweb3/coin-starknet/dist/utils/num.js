"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hexToBytes = exports.toCairoBool = exports.getHexStringArray = exports.getHexString = exports.getDecimalString = exports.toHexString = exports.isStringWholeNumber = exports.bigNumberishArrayToHexadecimalStringArray = exports.bigNumberishArrayToDecimalStringArray = exports.assertInRange = exports.cleanHex = exports.hexToDecimalString = exports.toHex = exports.isBigInt = exports.toBigInt = exports.isHex = void 0;
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const hexToBytesNoble = crypto_lib_1.signUtil.schnorr.hexToBytes;
const assert_1 = __importDefault(require("./assert"));
const encode_1 = require("./encode");
function isHex(hex) {
    return /^0x[0-9a-f]*$/i.test(hex);
}
exports.isHex = isHex;
function toBigInt(value) {
    return BigInt(value);
}
exports.toBigInt = toBigInt;
function isBigInt(value) {
    return typeof value === 'bigint';
}
exports.isBigInt = isBigInt;
function toHex(number) {
    return (0, encode_1.addHexPrefix)(toBigInt(number).toString(16));
}
exports.toHex = toHex;
function hexToDecimalString(hex) {
    return BigInt((0, encode_1.addHexPrefix)(hex)).toString(10);
}
exports.hexToDecimalString = hexToDecimalString;
const cleanHex = (hex) => hex.toLowerCase().replace(/^(0x)0+/, '$1');
exports.cleanHex = cleanHex;
function assertInRange(input, lowerBound, upperBound, inputName = '') {
    const messageSuffix = inputName === '' ? 'invalid length' : `invalid ${inputName} length`;
    const inputBigInt = BigInt(input);
    const lowerBoundBigInt = BigInt(lowerBound);
    const upperBoundBigInt = BigInt(upperBound);
    (0, assert_1.default)(inputBigInt >= lowerBoundBigInt && inputBigInt <= upperBoundBigInt, `Message not signable, ${messageSuffix}.`);
}
exports.assertInRange = assertInRange;
function bigNumberishArrayToDecimalStringArray(rawCalldata) {
    return rawCalldata.map((x) => toBigInt(x).toString(10));
}
exports.bigNumberishArrayToDecimalStringArray = bigNumberishArrayToDecimalStringArray;
function bigNumberishArrayToHexadecimalStringArray(rawCalldata) {
    return rawCalldata.map((x) => toHex(x));
}
exports.bigNumberishArrayToHexadecimalStringArray = bigNumberishArrayToHexadecimalStringArray;
const isStringWholeNumber = (value) => /^\d+$/.test(value);
exports.isStringWholeNumber = isStringWholeNumber;
const toHexString = (value) => toHex(value);
exports.toHexString = toHexString;
function getDecimalString(value) {
    if (isHex(value)) {
        return hexToDecimalString(value);
    }
    if ((0, exports.isStringWholeNumber)(value)) {
        return value;
    }
    throw new Error(`${value} need to be hex-string or whole-number-string`);
}
exports.getDecimalString = getDecimalString;
function getHexString(value) {
    if (isHex(value)) {
        return value;
    }
    if ((0, exports.isStringWholeNumber)(value)) {
        return (0, exports.toHexString)(value);
    }
    throw new Error(`${value} need to be hex-string or whole-number-string`);
}
exports.getHexString = getHexString;
function getHexStringArray(value) {
    return value.map((el) => getHexString(el));
}
exports.getHexStringArray = getHexStringArray;
const toCairoBool = (value) => (+value).toString();
exports.toCairoBool = toCairoBool;
function hexToBytes(value) {
    if (!isHex(value))
        throw new Error(`${value} need to be a hex-string`);
    let adaptedValue = (0, encode_1.removeHexPrefix)(value);
    if (adaptedValue.length % 2 !== 0) {
        adaptedValue = `0${adaptedValue}`;
    }
    return hexToBytesNoble(adaptedValue);
}
exports.hexToBytes = hexToBytes;
//# sourceMappingURL=num.js.map