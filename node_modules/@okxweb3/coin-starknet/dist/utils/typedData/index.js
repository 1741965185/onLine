"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMessageHash = exports.getStructHash = exports.encodeData = exports.encodeValue = exports.getTypeHash = exports.encodeType = exports.getDependencies = exports.isMerkleTreeType = exports.prepareSelector = void 0;
const hash_1 = require("../hash");
const merkle_1 = require("../merkle");
const num_1 = require("../num");
const shortString_1 = require("../shortString");
const utils_1 = require("./utils");
__exportStar(require("./types"), exports);
function getHex(value) {
    try {
        return (0, num_1.toHex)(value);
    }
    catch (e) {
        if (typeof value === 'string') {
            return (0, num_1.toHex)((0, shortString_1.encodeShortString)(value));
        }
        throw new Error(`Invalid BigNumberish: ${value}`);
    }
}
function prepareSelector(selector) {
    return (0, num_1.isHex)(selector) ? selector : (0, hash_1.getSelectorFromName)(selector);
}
exports.prepareSelector = prepareSelector;
function isMerkleTreeType(type) {
    return type.type === 'merkletree';
}
exports.isMerkleTreeType = isMerkleTreeType;
const getDependencies = (types, type, dependencies = []) => {
    if (type[type.length - 1] === '*') {
        type = type.slice(0, -1);
    }
    if (dependencies.includes(type)) {
        return dependencies;
    }
    if (!types[type]) {
        return dependencies;
    }
    return [
        type,
        ...types[type].reduce((previous, t) => [
            ...previous,
            ...(0, exports.getDependencies)(types, t.type, previous).filter((dependency) => !previous.includes(dependency)),
        ], []),
    ];
};
exports.getDependencies = getDependencies;
function getMerkleTreeType(types, ctx) {
    if (ctx.parent && ctx.key) {
        const parentType = types[ctx.parent];
        const merkleType = parentType.find((t) => t.name === ctx.key);
        const isMerkleTree = isMerkleTreeType(merkleType);
        if (!isMerkleTree) {
            throw new Error(`${ctx.key} is not a merkle tree`);
        }
        if (merkleType.contains.endsWith('*')) {
            throw new Error(`Merkle tree contain property must not be an array but was given ${ctx.key}`);
        }
        return merkleType.contains;
    }
    return 'raw';
}
const encodeType = (types, type) => {
    const [primary, ...dependencies] = (0, exports.getDependencies)(types, type);
    const newTypes = !primary ? [] : [primary, ...dependencies.sort()];
    return newTypes
        .map((dependency) => {
        return `${dependency}(${types[dependency].map((t) => `${t.name}:${t.type}`)})`;
    })
        .join('');
};
exports.encodeType = encodeType;
const getTypeHash = (types, type) => {
    return (0, hash_1.getSelectorFromName)((0, exports.encodeType)(types, type));
};
exports.getTypeHash = getTypeHash;
const encodeValue = (types, type, data, ctx = {}) => {
    if (types[type]) {
        return [type, (0, exports.getStructHash)(types, type, data)];
    }
    if (Object.keys(types)
        .map((x) => `${x}*`)
        .includes(type)) {
        const structHashes = data.map((struct) => {
            return (0, exports.getStructHash)(types, type.slice(0, -1), struct);
        });
        return [type, (0, hash_1.computeHashOnElements)(structHashes)];
    }
    if (type === 'merkletree') {
        const merkleTreeType = getMerkleTreeType(types, ctx);
        const structHashes = data.map((struct) => {
            return (0, exports.encodeValue)(types, merkleTreeType, struct)[1];
        });
        const { root } = new merkle_1.MerkleTree(structHashes);
        return ['felt', root];
    }
    if (type === 'felt*') {
        return ['felt*', (0, hash_1.computeHashOnElements)(data)];
    }
    if (type === 'selector') {
        return ['felt', prepareSelector(data)];
    }
    return [type, getHex(data)];
};
exports.encodeValue = encodeValue;
const encodeData = (types, type, data) => {
    const [returnTypes, values] = types[type].reduce(([ts, vs], field) => {
        if (data[field.name] === undefined || data[field.name] === null) {
            throw new Error(`Cannot encode data: missing data for '${field.name}'`);
        }
        const value = data[field.name];
        const [t, encodedValue] = (0, exports.encodeValue)(types, field.type, value, {
            parent: type,
            key: field.name,
        });
        return [
            [...ts, t],
            [...vs, encodedValue],
        ];
    }, [['felt'], [(0, exports.getTypeHash)(types, type)]]);
    return [returnTypes, values];
};
exports.encodeData = encodeData;
const getStructHash = (types, type, data) => {
    return (0, hash_1.computeHashOnElements)((0, exports.encodeData)(types, type, data)[1]);
};
exports.getStructHash = getStructHash;
const getMessageHash = (typedData, account) => {
    if (!(0, utils_1.validateTypedData)(typedData)) {
        throw new Error('Typed data does not match JSON schema');
    }
    const message = [
        (0, shortString_1.encodeShortString)('StarkNet Message'),
        (0, exports.getStructHash)(typedData.types, 'StarkNetDomain', typedData.domain),
        account,
        (0, exports.getStructHash)(typedData.types, typedData.primaryType, typedData.message),
    ];
    return (0, hash_1.computeHashOnElements)(message);
};
exports.getMessageHash = getMessageHash;
//# sourceMappingURL=index.js.map