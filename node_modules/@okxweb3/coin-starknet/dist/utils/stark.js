"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.estimatedFeeToMaxFee = exports.signatureToHexArray = exports.signatureToDecimalArray = exports.formatSignature = exports.makeAddress = exports.randomAddress = exports.compressProgram = void 0;
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const pako_1 = require("pako");
const index_1 = require("../index");
const encode_1 = require("./encode");
const num_1 = require("./num");
function compressProgram(jsonProgram) {
    const stringified = typeof jsonProgram === 'string' ? jsonProgram : index_1.json.stringify(jsonProgram);
    const compressedProgram = (0, pako_1.gzip)(stringified);
    return (0, encode_1.btoaUniversal)(compressedProgram);
}
exports.compressProgram = compressProgram;
function randomAddress() {
    const randomKeyPair = crypto_lib_1.signUtil.schnorr.stark.utils.randomPrivateKey();
    return crypto_lib_1.signUtil.schnorr.stark.getStarkKey(randomKeyPair);
}
exports.randomAddress = randomAddress;
function makeAddress(input) {
    return (0, encode_1.addHexPrefix)(input).toLowerCase();
}
exports.makeAddress = makeAddress;
function formatSignature(sig) {
    if (!sig)
        throw Error('formatSignature: provided signature is undefined');
    if (Array.isArray(sig)) {
        return sig.map((it) => (0, num_1.toHex)(it));
    }
    try {
        const { r, s } = sig;
        return [(0, num_1.toHex)(r), (0, num_1.toHex)(s)];
    }
    catch (e) {
        throw new Error('Signature need to be weierstrass.SignatureType or an array for custom');
    }
}
exports.formatSignature = formatSignature;
function signatureToDecimalArray(sig) {
    return (0, num_1.bigNumberishArrayToDecimalStringArray)(formatSignature(sig));
}
exports.signatureToDecimalArray = signatureToDecimalArray;
function signatureToHexArray(sig) {
    return (0, num_1.bigNumberishArrayToHexadecimalStringArray)(formatSignature(sig));
}
exports.signatureToHexArray = signatureToHexArray;
function estimatedFeeToMaxFee(estimatedFee, overhead = 0.5) {
    const overHeadPercent = Math.round((1 + overhead) * 100);
    return ((0, num_1.toBigInt)(estimatedFee) * (0, num_1.toBigInt)(overHeadPercent)) / 100n;
}
exports.estimatedFeeToMaxFee = estimatedFeeToMaxFee;
//# sourceMappingURL=stark.js.map