"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZksyncWallet = void 0;
const coin_base_1 = require("@okxweb3/coin-base");
const coin_ethereum_1 = require("@okxweb3/coin-ethereum");
const index_1 = require("./index");
const bignumber_1 = require("@ethersproject/bignumber");
class ZksyncWallet extends coin_ethereum_1.EthWallet {
    async signTransaction(param) {
        try {
            let result;
            const data = param.data;
            const closeFees = getCloseFeeBylocal(data.fees);
            if (!bignumber_1.BigNumber.from(closeFees).eq(bignumber_1.BigNumber.from(data.fees))) {
                let rejectParam = {
                    code: '402',
                    reason: 'Fee is not packable',
                    closeFees_number: bignumber_1.BigNumber.from(closeFees)
                };
                return Promise.resolve(rejectParam);
            }
            if (data.type === 'transfer') {
                if (data.from == null ||
                    data.to == null ||
                    data.nonce == null ||
                    data.accountId == null ||
                    data.fees == null ||
                    data.tokenId == null ||
                    data.tokenSymbol == null) {
                    return Promise.reject(coin_base_1.SignTxError);
                }
                const closeAmount = getCloseAmountsByLocal(data.amounts);
                if (!bignumber_1.BigNumber.from(closeAmount).eq(bignumber_1.BigNumber.from(data.amounts))) {
                    let rejectParam = {
                        code: '401',
                        reason: 'Amount is not packable',
                        closeAmount_number: bignumber_1.BigNumber.from(closeAmount),
                    };
                    return Promise.resolve(rejectParam);
                }
                result = (0, index_1.zksyncTransfer)(param.privateKey, data.from, data.to, data.accountId, data.tokenId, data.tokenSymbol, data.amounts, data.fees, data.decimals, data.nonce);
            }
            else if (data.type === 'changePubkey') {
                if (data.from == null ||
                    data.nonce == null ||
                    data.accountId == null ||
                    data.fees == null) {
                    return Promise.reject(coin_base_1.SignTxError);
                }
                result = (0, index_1.zksyncChangePubkey)(param.privateKey, data.from, data.nonce, data.accountId, data.fees, data.tokenId);
            }
            else {
                return Promise.reject(coin_base_1.SignTxError);
            }
            return Promise.resolve(result);
        }
        catch (e) {
            return Promise.reject(coin_base_1.SignTxError);
        }
    }
    static async getCloseAmounts(amounts) {
        return getCloseAmountsByLocal(amounts);
    }
    static async getCloseFee(fees) {
        return getCloseFeeBylocal(fees);
    }
}
exports.ZksyncWallet = ZksyncWallet;
function getCloseAmountsByLocal(amounts) {
    const originAmounts = bignumber_1.BigNumber.from(amounts);
    const closeAmounts = (0, index_1.closestPackableTransactionAmount)(amounts);
    if (closeAmounts.gt(originAmounts)) {
        throw new Error('closeAmounts greater than origin');
    }
    return closeAmounts.toString();
}
function getCloseFeeBylocal(fees) {
    const originFees = bignumber_1.BigNumber.from(fees);
    const closeFees = (0, index_1.closestPackableTransactionAmount)(fees);
    if (closeFees.gt(originFees)) {
        throw new Error('closeFees greater than origin');
    }
    return closeFees.toString();
}
//# sourceMappingURL=ZksyncWallet.js.map