"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.zksyncTransfer = exports.zksyncChangePubkey = void 0;
const bignumber_1 = require("@ethersproject/bignumber");
const coin_ethereum_1 = require("@okxweb3/coin-ethereum");
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const Units_1 = require("../Units");
const zksync = require('../zksync-crypto/zksync-crypto-web.js');
const initPromise = zksync.loadZkSyncCrypto();
async function zksyncChangePubkey(l1PrivateKey, from, nonce, accountId, fee, tokenId) {
    await initPromise;
    const msg = 'Access zkSync account.\n\nOnly sign this message for a trusted client!';
    const signature = (0, coin_ethereum_1.signMessage)(coin_ethereum_1.MessageTypes.PERSONAL_SIGN, msg, crypto_lib_1.base.fromHex(l1PrivateKey));
    const seed = crypto_lib_1.base.fromHex(signature);
    const l2PrivateKey = zksync.privateKeyFromSeed(seed);
    const pubKeyHash = `sync:${crypto_lib_1.base.toHex(zksync.private_key_to_pubkey_hash(l2PrivateKey))}`;
    const feeString = bignumber_1.BigNumber.from(fee);
    const packedFee = packAmount(feeString, 11, 5, 10);
    const address = crypto_lib_1.base.toHex((0, coin_ethereum_1.privateToAddress)(crypto_lib_1.base.fromHex(l1PrivateKey)), true);
    const type = new Uint8Array([255 - 7]);
    const version = new Uint8Array([1]);
    const accountIdBytes = crypto_lib_1.base.fromHex(numberToBytes(accountId, 4));
    const accountBytes = crypto_lib_1.base.fromHex(address);
    const pubKeyHashBytes = crypto_lib_1.base.fromHex('0x' + pubKeyHash.slice(5));
    const tokenIdBytes = crypto_lib_1.base.fromHex(numberToBytes(tokenId, 4));
    const feeBytes = crypto_lib_1.base.fromHex(packedFee.toHexString());
    const nonceBytes = crypto_lib_1.base.fromHex(numberToBytes(nonce, 4));
    const validFromBytes = crypto_lib_1.base.fromHex(numberToBytes(0, 8));
    const validUntilBytes = crypto_lib_1.base.fromHex(numberToBytes(4294967295, 8));
    const msgBytes = Buffer.concat([
        type,
        version,
        accountIdBytes,
        accountBytes,
        pubKeyHashBytes,
        tokenIdBytes,
        feeBytes,
        nonceBytes,
        validFromBytes,
        validUntilBytes,
    ]);
    const txHash = crypto_lib_1.base.toHex(crypto_lib_1.base.sha256(msgBytes), true);
    const signaturePacked = zksync.sign_musig(l2PrivateKey, msgBytes);
    const pubKey = crypto_lib_1.base.toHex(signaturePacked.slice(0, 32));
    const pubKey_signature = crypto_lib_1.base.toHex(signaturePacked.slice(32));
    const msgBatchHash = new Uint8Array(32).fill(0);
    const msgBatchHash_HEX = crypto_lib_1.base.toHex(msgBatchHash);
    let messageBytes = Buffer.concat([
        pubKeyHashBytes,
        nonceBytes,
        accountIdBytes,
        crypto_lib_1.base.fromHex(msgBatchHash_HEX),
    ]);
    const ethSignature = (0, coin_ethereum_1.signMessage)(coin_ethereum_1.MessageTypes.PERSONAL_SIGN, crypto_lib_1.base.toHex(messageBytes, true), crypto_lib_1.base.fromHex(l1PrivateKey));
    const tx = {
        tx: {
            type: 'ChangePubKey',
            accountId: accountId,
            account: address,
            newPkHash: pubKeyHash,
            nonce: nonce,
            validFrom: 0,
            validUntil: 4294967295,
            fee: fee,
            feeToken: tokenId,
            signature: {
                pubKey: pubKey,
                signature: pubKey_signature,
            },
            ethAuthData: {
                type: 'ECDSA',
                batchHash: '0x' + msgBatchHash_HEX,
                ethSignature: ethSignature,
            },
            txHash: txHash,
        },
    };
    return tx;
}
exports.zksyncChangePubkey = zksyncChangePubkey;
function PrefixInteger(num, length) {
    for (var len = (num + "").length; len < length; len = num.length) {
        num = "0" + num;
    }
    return num;
}
async function zksyncTransfer(l1PrivateKey, from, to, accountId, tokenId, tokenSymbol, amounts, fees, decimals, nonce) {
    await initPromise;
    to = to.toLowerCase();
    const msg = 'Access zkSync account.\n\nOnly sign this message for a trusted client!';
    const signature_pri = (0, coin_ethereum_1.signMessage)(coin_ethereum_1.MessageTypes.PERSONAL_SIGN, msg, crypto_lib_1.base.fromHex(l1PrivateKey));
    const seed = crypto_lib_1.base.fromHex(signature_pri);
    const l2PrivateKey = zksync.privateKeyFromSeed(seed);
    const amount = bignumber_1.BigNumber.from(amounts);
    const packedAmount = packAmount(amount, 35, 5, 10);
    const closestAmount = unpackAmount(packedAmount, 35, 5);
    const readableAmount = (0, Units_1.formatUnits)(closestAmount, decimals);
    const fee = bignumber_1.BigNumber.from(fees);
    const packedFee = packAmount(fee, 11, 5, 10);
    const closestFee = unpackAmount(packedFee, 11, 5);
    const readableFee = (0, Units_1.formatUnits)(closestFee, decimals);
    const message = `Transfer ${readableAmount} ${tokenSymbol} to: ${to}
Fee: ${readableFee} ${tokenSymbol}
Nonce: ${nonce}`;
    const ethSignature = (0, coin_ethereum_1.signMessage)(coin_ethereum_1.MessageTypes.PERSONAL_SIGN, message, crypto_lib_1.base.fromHex(l1PrivateKey));
    const ethereumSignature = {
        type: 'EthereumSignature',
        signature: ethSignature,
    };
    const type = new Uint8Array([255 - 5]);
    const version = new Uint8Array([1]);
    const accountIdBytes = crypto_lib_1.base.fromHex(numberToBytes(accountId, 4));
    const fromBytes = crypto_lib_1.base.fromHex(from);
    const toBytes = crypto_lib_1.base.fromHex(to);
    const tokenIdBytes = crypto_lib_1.base.fromHex(numberToBytes(tokenId, 4));
    const amountbytes = crypto_lib_1.base.fromHex(PrefixInteger(packedAmount.toHexString().replace('0x', ''), 10));
    const feeBytes = crypto_lib_1.base.fromHex(packedFee.toHexString());
    const nonceBytes = crypto_lib_1.base.fromHex(numberToBytes(nonce, 4));
    const validFromBytes = crypto_lib_1.base.fromHex(numberToBytes(0, 8));
    const validUntilBytes = crypto_lib_1.base.fromHex(numberToBytes(4294967295, 8));
    const msgBytes = Buffer.concat([
        type,
        version,
        accountIdBytes,
        fromBytes,
        toBytes,
        tokenIdBytes,
        amountbytes,
        feeBytes,
        nonceBytes,
        validFromBytes,
        validUntilBytes,
    ]);
    const signaturePacked = zksync.sign_musig(l2PrivateKey, msgBytes);
    const pubKey = crypto_lib_1.base.toHex(signaturePacked.slice(0, 32));
    const pubKey_signature = crypto_lib_1.base.toHex(signaturePacked.slice(32));
    const txHash = crypto_lib_1.base.toHex(crypto_lib_1.base.sha256(msgBytes), true);
    const tx = {
        tx: {
            accountId: accountId,
            amount: amounts,
            fee: fees,
            from: from,
            nonce: nonce,
            signature: {
                pubKey: pubKey,
                signature: pubKey_signature,
            },
            to: to,
            token: tokenId,
            type: 'Transfer',
            validFrom: 0,
            validUntil: 4294967295,
            txHash: txHash,
        },
        signature: {
            signature: ethSignature,
            type: 'EthereumSignature',
        },
    };
    return tx;
}
exports.zksyncTransfer = zksyncTransfer;
function hexZeroPad(value, length) {
    while (value.length < 2 * length + 2) {
        value = '0x0' + value.substring(2);
    }
    return value;
}
function numberToBytes(number, length) {
    return hexZeroPad(bignumber_1.BigNumber.from(number).toHexString(), length);
}
function packAmount(amount, mantissaBits, expBits, expBase) {
    const expBaseBN = bignumber_1.BigNumber.from(expBase);
    const expBitsBN = bignumber_1.BigNumber.from(expBits);
    const mantissaBitsBN = bignumber_1.BigNumber.from(mantissaBits);
    const mantissaMaskBN = bignumber_1.BigNumber.from(2).pow(mantissaBitsBN).sub(1);
    const expMaskBN = bignumber_1.BigNumber.from(2).pow(expBitsBN).sub(1);
    let exp = bignumber_1.BigNumber.from(0);
    let mantissa = bignumber_1.BigNumber.from(amount);
    while (mantissa.gt(mantissaMaskBN)) {
        mantissa = mantissa.div(expBaseBN);
        exp = exp.add(1);
    }
    if (exp.gt(expMaskBN)) {
        throw new Error('Amount is too big');
    }
    return mantissa.shl(expBits).or(exp);
}
function unpackAmount(amount, mantissaBits, expBits) {
    const expBaseBN = bignumber_1.BigNumber.from(10);
    const expBitsBN = bignumber_1.BigNumber.from(expBits);
    const mantissaBitsBN = bignumber_1.BigNumber.from(mantissaBits);
    const mantissaMaskBN = bignumber_1.BigNumber.from(2).pow(mantissaBitsBN).sub(1);
    const expMaskBN = bignumber_1.BigNumber.from(2).pow(expBitsBN).sub(1);
    const exp = amount.and(expMaskBN);
    const mantissa = amount.shr(expBits).and(mantissaMaskBN);
    return mantissa.mul(expBaseBN.pow(exp));
}
//# sourceMappingURL=index.js.map