"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bitsIntoBytesInBEOrder = exports.integerToFloat = exports.reverseBits = exports.buffer2bitsBE = exports.floatToInteger = exports.closestPackableTransactionFee = exports.closestPackableTransactionAmount = void 0;
const bignumber_1 = require("@ethersproject/bignumber");
const AMOUNT_EXPONENT_BIT_WIDTH = 5;
const AMOUNT_MANTISSA_BIT_WIDTH = 35;
const FEE_EXPONENT_BIT_WIDTH = 5;
const FEE_MANTISSA_BIT_WIDTH = 11;
function closestPackableTransactionAmount(amount) {
    const packedAmount = packAmount(bignumber_1.BigNumber.from(amount));
    return floatToInteger(packedAmount, AMOUNT_EXPONENT_BIT_WIDTH, AMOUNT_MANTISSA_BIT_WIDTH, 10);
}
exports.closestPackableTransactionAmount = closestPackableTransactionAmount;
function closestPackableTransactionFee(fee) {
    const packedFee = packFee(bignumber_1.BigNumber.from(fee));
    return floatToInteger(packedFee, FEE_EXPONENT_BIT_WIDTH, FEE_MANTISSA_BIT_WIDTH, 10);
}
exports.closestPackableTransactionFee = closestPackableTransactionFee;
function packFee(amount) {
    return reverseBits(integerToFloat(amount, FEE_EXPONENT_BIT_WIDTH, FEE_MANTISSA_BIT_WIDTH, 10));
}
function floatToInteger(floatBytes, expBits, mantissaBits, expBaseNumber) {
    if (floatBytes.length * 8 !== mantissaBits + expBits) {
        throw new Error('Float unpacking, incorrect input length');
    }
    const bits = buffer2bitsBE(floatBytes).reverse();
    let exponent = bignumber_1.BigNumber.from(0);
    let expPow2 = bignumber_1.BigNumber.from(1);
    for (let i = 0; i < expBits; i++) {
        if (bits[i] === 1) {
            exponent = exponent.add(expPow2);
        }
        expPow2 = expPow2.mul(2);
    }
    exponent = bignumber_1.BigNumber.from(expBaseNumber).pow(exponent);
    let mantissa = bignumber_1.BigNumber.from(0);
    let mantissaPow2 = bignumber_1.BigNumber.from(1);
    for (let i = expBits; i < expBits + mantissaBits; i++) {
        if (bits[i] === 1) {
            mantissa = mantissa.add(mantissaPow2);
        }
        mantissaPow2 = mantissaPow2.mul(2);
    }
    return exponent.mul(mantissa);
}
exports.floatToInteger = floatToInteger;
function buffer2bitsBE(buff) {
    const res = new Array(buff.length * 8);
    for (let i = 0; i < buff.length; i++) {
        const b = buff[i];
        res[i * 8] = (b & 0x80) !== 0 ? 1 : 0;
        res[i * 8 + 1] = (b & 0x40) !== 0 ? 1 : 0;
        res[i * 8 + 2] = (b & 0x20) !== 0 ? 1 : 0;
        res[i * 8 + 3] = (b & 0x10) !== 0 ? 1 : 0;
        res[i * 8 + 4] = (b & 0x08) !== 0 ? 1 : 0;
        res[i * 8 + 5] = (b & 0x04) !== 0 ? 1 : 0;
        res[i * 8 + 6] = (b & 0x02) !== 0 ? 1 : 0;
        res[i * 8 + 7] = (b & 0x01) !== 0 ? 1 : 0;
    }
    return res;
}
exports.buffer2bitsBE = buffer2bitsBE;
function packAmount(amount) {
    return reverseBits(integerToFloat(amount, AMOUNT_EXPONENT_BIT_WIDTH, AMOUNT_MANTISSA_BIT_WIDTH, 10));
}
function reverseBits(buffer) {
    const reversed = buffer.reverse();
    reversed.map((b) => {
        b = ((b & 0xf0) >> 4) | ((b & 0x0f) << 4);
        b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
        b = ((b & 0xaa) >> 1) | ((b & 0x55) << 1);
        return b;
    });
    return reversed;
}
exports.reverseBits = reverseBits;
function integerToFloat(integer, expBits, mantissaBits, expBase) {
    const maxExponentPower = bignumber_1.BigNumber.from(2).pow(expBits).sub(1);
    const maxExponent = bignumber_1.BigNumber.from(expBase).pow(maxExponentPower);
    const maxMantissa = bignumber_1.BigNumber.from(2).pow(mantissaBits).sub(1);
    if (integer.gt(maxMantissa.mul(maxExponent))) {
        throw new Error('Integer is too big');
    }
    let exponent = 0;
    let exponentTemp = bignumber_1.BigNumber.from(1);
    while (integer.gt(maxMantissa.mul(exponentTemp))) {
        exponentTemp = exponentTemp.mul(expBase);
        exponent += 1;
    }
    let mantissa = integer.div(exponentTemp);
    if (exponent !== 0) {
        const variant1 = exponentTemp.mul(mantissa);
        const variant2 = exponentTemp.div(expBase).mul(maxMantissa);
        const diff1 = integer.sub(variant1);
        const diff2 = integer.sub(variant2);
        if (diff2.lt(diff1)) {
            mantissa = maxMantissa;
            exponent -= 1;
        }
    }
    const encoding = [];
    encoding.push(...numberToBits(exponent, expBits));
    const mantissaNumber = mantissa.toNumber();
    encoding.push(...numberToBits(mantissaNumber, mantissaBits));
    return bitsIntoBytesInBEOrder(encoding.reverse()).reverse();
}
exports.integerToFloat = integerToFloat;
function numberToBits(integer, bits) {
    const result = [];
    for (let i = 0; i < bits; i++) {
        result.push(integer & 1);
        integer /= 2;
    }
    return result;
}
function bitsIntoBytesInBEOrder(bits) {
    if (bits.length % 8 !== 0) {
        throw new Error('wrong number of bits to pack');
    }
    const nBytes = bits.length / 8;
    const resultBytes = new Uint8Array(nBytes);
    for (let byte = 0; byte < nBytes; ++byte) {
        let value = 0;
        if (bits[byte * 8] === 1) {
            value |= 0x80;
        }
        if (bits[byte * 8 + 1] === 1) {
            value |= 0x40;
        }
        if (bits[byte * 8 + 2] === 1) {
            value |= 0x20;
        }
        if (bits[byte * 8 + 3] === 1) {
            value |= 0x10;
        }
        if (bits[byte * 8 + 4] === 1) {
            value |= 0x08;
        }
        if (bits[byte * 8 + 5] === 1) {
            value |= 0x04;
        }
        if (bits[byte * 8 + 6] === 1) {
            value |= 0x02;
        }
        if (bits[byte * 8 + 7] === 1) {
            value |= 0x01;
        }
        resultBytes[byte] = value;
    }
    return resultBytes;
}
exports.bitsIntoBytesInBEOrder = bitsIntoBytesInBEOrder;
//# sourceMappingURL=utils.js.map