"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transfer = exports.changePubkey = void 0;
const bignumber_1 = require("@ethersproject/bignumber");
const coin_ethereum_1 = require("@okxweb3/coin-ethereum");
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const Units_1 = require("../Units");
const zksync = require('../zksync-crypto/zksync-crypto-web.js');
const initPromise = zksync.loadZkSyncCrypto();
async function changePubkey(l1PrivateKey, from, nonce, accountId) {
    await initPromise;
    const msg = 'Access ZKSwap account.\n\nOnly sign this message for a trusted client!';
    const signature = (0, coin_ethereum_1.signMessage)(coin_ethereum_1.MessageTypes.PERSONAL_SIGN, msg, crypto_lib_1.base.fromHex(l1PrivateKey));
    const seed = crypto_lib_1.base.fromHex(signature);
    const l2PrivateKey = zksync.privateKeyFromSeed(seed);
    const pubKeyHash = `sync:${crypto_lib_1.base.toHex(zksync.private_key_to_pubkey_hash(l2PrivateKey))}`;
    const message = `Register ZKSwap pubkey:

${pubKeyHash.replace('sync:', '')}
nonce: ${numberToBytes(nonce, 4)}
account id: ${numberToBytes(accountId, 4)}

Only sign this message for a trusted client!`;
    const ethSignature = (0, coin_ethereum_1.signMessage)(coin_ethereum_1.MessageTypes.PERSONAL_SIGN, message, crypto_lib_1.base.fromHex(l1PrivateKey));
    const address = crypto_lib_1.base.toHex((0, coin_ethereum_1.privateToAddress)(crypto_lib_1.base.fromHex(l1PrivateKey)), true);
    const msgBytes = Buffer.concat([
        crypto_lib_1.base.fromHex('0x07'),
        crypto_lib_1.base.fromHex(numberToBytes(accountId, 4)),
        crypto_lib_1.base.fromHex(address),
        crypto_lib_1.base.fromHex('0x' + pubKeyHash.slice(5)),
        crypto_lib_1.base.fromHex(numberToBytes(nonce, 4)),
        crypto_lib_1.base.fromHex(ethSignature),
    ]);
    const txHash = crypto_lib_1.base.toHex(crypto_lib_1.base.sha256(msgBytes), true);
    const data = {
        type: 'ChangePubKey',
        accountId: accountId,
        account: address,
        newPkHash: pubKeyHash,
        nonce: nonce,
        ethSignature: ethSignature,
        txHash: txHash,
    };
    return data;
}
exports.changePubkey = changePubkey;
function hexZeroPad(value, length) {
    while (value.length < 2 * length + 2) {
        value = '0x0' + value.substring(2);
    }
    return value;
}
function numberToBytes(number, length) {
    return hexZeroPad(bignumber_1.BigNumber.from(number).toHexString(), length);
}
async function transfer(l1PrivateKey, from, nonce, accountId, chainId, to, tokenId, tokenSymbol, decimals, feeTokenId, feeTokenSymbol, feeDecimals, amounts, fees) {
    await initPromise;
    const msg = 'Access ZKSwap account.\n\nOnly sign this message for a trusted client!';
    const signature_pri = (0, coin_ethereum_1.signMessage)(coin_ethereum_1.MessageTypes.PERSONAL_SIGN, msg, crypto_lib_1.base.fromHex(l1PrivateKey));
    const seed = crypto_lib_1.base.fromHex(signature_pri);
    const l2PrivateKey = zksync.privateKeyFromSeed(seed);
    const amount = bignumber_1.BigNumber.from(amounts);
    const packedAmount = packAmount(amount, 35, 5, 10);
    const closestAmount = unpackAmount(packedAmount, 35, 5);
    const readableAmount = (0, Units_1.formatUnits)(closestAmount, decimals);
    const fee = bignumber_1.BigNumber.from(fees);
    const packedFee = packAmount(fee, 11, 5, 10);
    const closestFee = unpackAmount(packedFee, 11, 5);
    const readableFee = (0, Units_1.formatUnits)(closestFee, feeDecimals);
    const message = `Transfer ${readableAmount} ${tokenSymbol}
To: ${to}
Chain Id: ${chainId}
Nonce: ${nonce}
Fee: ${readableFee} ${feeTokenSymbol}
Account Id: ${accountId}`;
    const ethSignature = (0, coin_ethereum_1.signMessage)(coin_ethereum_1.MessageTypes.PERSONAL_SIGN, message, crypto_lib_1.base.fromHex(l1PrivateKey));
    const ethereumSignature = {
        type: 'EthereumSignature',
        signature: ethSignature,
    };
    const address = crypto_lib_1.base.toHex((0, coin_ethereum_1.privateToAddress)(crypto_lib_1.base.fromHex(l1PrivateKey)), true);
    const msgBytes = Buffer.concat([
        crypto_lib_1.base.fromHex('0x05'),
        crypto_lib_1.base.fromHex(numberToBytes(accountId, 4)),
        crypto_lib_1.base.fromHex(address),
        crypto_lib_1.base.fromHex(to),
        crypto_lib_1.base.fromHex(numberToBytes(tokenId, 2)),
        crypto_lib_1.base.fromHex(PrefixInteger(packedAmount.toHexString().replace('0x', ''), 10)),
        crypto_lib_1.base.fromHex(numberToBytes(feeTokenId, 1)),
        crypto_lib_1.base.fromHex(packedFee.toHexString()),
        crypto_lib_1.base.fromHex(numberToBytes(chainId, 1)),
        crypto_lib_1.base.fromHex(numberToBytes(nonce, 4)),
    ]);
    const txHash = crypto_lib_1.base.toHex(crypto_lib_1.base.sha256(msgBytes), true);
    const signaturePacked = zksync.sign_musig(l2PrivateKey, msgBytes);
    const pubKey = crypto_lib_1.base.toHex(signaturePacked.slice(0, 32));
    const signature = crypto_lib_1.base.toHex(signaturePacked.slice(32));
    const tx = {
        type: 'Transfer',
        accountId,
        from: address,
        to: to,
        token: tokenId,
        amount: closestAmount.toString(),
        feeToken: feeTokenId,
        fee: closestFee.toString(),
        chainId,
        nonce,
        signature: {
            pubKey,
            signature,
        },
        txHash: txHash,
    };
    return { tx, signature: ethereumSignature };
}
exports.transfer = transfer;
function packAmount(amount, mantissaBits, expBits, expBase) {
    const expBaseBN = bignumber_1.BigNumber.from(expBase);
    const expBitsBN = bignumber_1.BigNumber.from(expBits);
    const mantissaBitsBN = bignumber_1.BigNumber.from(mantissaBits);
    const mantissaMaskBN = bignumber_1.BigNumber.from(2).pow(mantissaBitsBN).sub(1);
    const expMaskBN = bignumber_1.BigNumber.from(2).pow(expBitsBN).sub(1);
    let exp = bignumber_1.BigNumber.from(0);
    let mantissa = bignumber_1.BigNumber.from(amount);
    while (mantissa.gt(mantissaMaskBN)) {
        mantissa = mantissa.div(expBaseBN);
        exp = exp.add(1);
    }
    if (exp.gt(expMaskBN)) {
        throw new Error('Amount is too big');
    }
    return mantissa.shl(expBits).or(exp);
}
function unpackAmount(amount, mantissaBits, expBits) {
    const expBaseBN = bignumber_1.BigNumber.from(10);
    const expBitsBN = bignumber_1.BigNumber.from(expBits);
    const mantissaBitsBN = bignumber_1.BigNumber.from(mantissaBits);
    const mantissaMaskBN = bignumber_1.BigNumber.from(2).pow(mantissaBitsBN).sub(1);
    const expMaskBN = bignumber_1.BigNumber.from(2).pow(expBitsBN).sub(1);
    const exp = amount.and(expMaskBN);
    const mantissa = amount.shr(expBits).and(mantissaMaskBN);
    return mantissa.mul(expBaseBN.pow(exp));
}
function PrefixInteger(num, length) {
    for (var len = (num + '').length; len < length; len = num.length) {
        num = '0' + num;
    }
    return num;
}
//# sourceMappingURL=index.js.map