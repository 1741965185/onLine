"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTxId = exports.verifySignature = exports.signMessage = exports.signSerializedTransaction = exports.transfer = exports.createAccount = exports.getNewAddress = exports.checkName = void 0;
const txBuilder_1 = require("./txBuilder");
const types_1 = require("./types");
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const action_1 = require("./action");
const numeric_1 = require("./numeric");
const serialize_1 = require("./serialize");
const pako_1 = require("pako");
function checkName(name) {
    const regex = new RegExp(/^[.1-5a-z]{0,12}[.1-5a-j]?$/);
    return regex.test(name);
}
exports.checkName = checkName;
function getNewAddress(creator, newAccount, newAccountActivePrivateKeyBase58, ram, net, cpu, transfer, precision, symbol, common) {
    if (!checkName(creator)) {
        throw new Error('invalid creator name');
    }
    if (!checkName(newAccount)) {
        throw new Error('invalid newAccount name');
    }
    const privateKey = (0, numeric_1.stringToPrivateKey)(newAccountActivePrivateKeyBase58);
    const publicKey = crypto_lib_1.signUtil.secp256k1.publicKeyCreate(privateKey.data, true);
    return createAccount({
        creator: creator,
        newAccount: newAccount,
        pubKey: (0, numeric_1.publicKeyToString)({
            type: types_1.KeyType.k1,
            data: publicKey,
        }),
        buyRam: {
            payer: creator,
            receiver: newAccount,
            quantity: (0, action_1.toAssetString)(ram, precision, symbol),
        },
        delegate: {
            from: creator,
            receiver: newAccount,
            stakeNet: (0, action_1.toAssetString)(net, precision, symbol),
            stakeCPU: (0, action_1.toAssetString)(cpu, precision, symbol),
            transfer: transfer
        },
        common: common
    });
}
exports.getNewAddress = getNewAddress;
function createAccount(param) {
    const actions = [
        (0, action_1.NewAccountAction)(param.creator, param.newAccount, param.pubKey),
        (0, action_1.delegateAction)(param.delegate),
        (0, action_1.buyRamAction)(param.buyRam),
    ];
    const abiMap = new Map();
    abiMap.set('eosio', action_1.eosioAbi);
    return buildTransaction(param.common, actions, abiMap);
}
exports.createAccount = createAccount;
function transfer(param) {
    if (!checkName(param.from)) {
        throw new Error('invalid from name');
    }
    if (!checkName(param.to)) {
        throw new Error('invalid to name');
    }
    const actions = [
        (0, action_1.transferAction)(param),
    ];
    const abiMap = new Map();
    if (param.contract) {
        abiMap.set(param.contract, action_1.eosioTokenAbi);
    }
    else {
        abiMap.set('eosio.token', action_1.eosioTokenAbi);
    }
    return buildTransaction(param.common, actions, abiMap);
}
exports.transfer = transfer;
function buildTransaction(param, actions, abiMap) {
    const builder = new txBuilder_1.TxBuilder(param.chainId);
    const config = {
        privateKeys: param.privateKey,
        compression: param.compression,
        refBlockNumber: param.refBlockNumber,
        refBlockId: param.refBlockId,
        refBlockTimestamp: param.refBlockTimestamp,
        expireSeconds: param.expireSeconds,
    };
    const transaction = {
        actions: actions,
    };
    const t = builder.build(transaction, config, abiMap);
    return JSON.stringify(t);
}
function signSerializedTransaction(chainId, privateKeys, serializedTransaction, serializedContextFreeData) {
    const builder = new txBuilder_1.TxBuilder(chainId);
    const serializedTransactionRaw = crypto_lib_1.base.fromHex(serializedTransaction);
    const serializedContextFreeDataRaw = serializedContextFreeData ? crypto_lib_1.base.fromHex(serializedContextFreeData) : undefined;
    return builder.sign(privateKeys, serializedTransactionRaw, serializedContextFreeDataRaw);
}
exports.signSerializedTransaction = signSerializedTransaction;
function signMessage(chainId, privateKey, serializedTransaction, serializedContextFreeData) {
    return signSerializedTransaction(chainId, [privateKey], serializedTransaction, serializedContextFreeData)[0];
}
exports.signMessage = signMessage;
function verifySignature(chainId, signature, serializedTransaction, serializedContextFreeData) {
    const key = (0, numeric_1.stringToSignature)(signature);
    const serializedTransactionRaw = crypto_lib_1.base.fromHex(serializedTransaction);
    const serializedContextFreeDataRaw = serializedContextFreeData ? crypto_lib_1.base.fromHex(serializedContextFreeData) : undefined;
    const digest = (0, numeric_1.digestFromSerializedData)(chainId, serializedTransactionRaw, serializedContextFreeDataRaw);
    const e = (0, numeric_1.signatureToElliptic)(key.data);
    const publicKey = crypto_lib_1.signUtil.secp256k1.recover(e.signatureBytes, e.recoveryParam, digest, true);
    if (!publicKey) {
        throw new Error("recover publicKey error");
    }
    return (0, numeric_1.publicKeyToLegacyString)({ type: types_1.KeyType.k1, data: publicKey });
}
exports.verifySignature = verifySignature;
function getTxId(tx) {
    let serializedTransaction;
    if (tx.compression) {
        serializedTransaction = (0, pako_1.inflate)((0, serialize_1.hexToUint8Array)(tx.packed_trx));
    }
    else {
        serializedTransaction = (0, serialize_1.hexToUint8Array)(tx.packed_trx);
    }
    return crypto_lib_1.base.toHex(crypto_lib_1.base.sha256(Buffer.from(serializedTransaction)));
}
exports.getTxId = getTxId;
//# sourceMappingURL=api.js.map