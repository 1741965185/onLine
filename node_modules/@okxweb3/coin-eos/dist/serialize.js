"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeActionData = exports.serializeAction = exports.supportedAbiVersion = exports.transactionHeader = exports.createTransactionExtensionTypes = exports.createTransactionTypes = exports.createAbiTypes = exports.createInitialTypes = exports.symbolToString = exports.stringToSymbol = exports.blockTimestampToDate = exports.dateToBlockTimestamp = exports.timePointSecToDate = exports.dateToTimePointSec = exports.timePointToDate = exports.dateToTimePoint = exports.hexToUint8Array = exports.arrayToHex = exports.getTypesFromAbi = exports.getType = exports.SerializerState = exports.SerialBuffer = void 0;
const numeric = __importStar(require("./numeric"));
const types_1 = require("./types");
const x_textencoder_1 = require("@polkadot/x-textencoder");
const x_textdecoder_1 = require("@polkadot/x-textdecoder");
const textEncoder = new x_textencoder_1.TextEncoder();
const textDecoder = new x_textdecoder_1.TextDecoder();
class SerialBuffer {
    constructor(array) {
        this.readPos = 0;
        this.array = array || new Uint8Array(1024);
        this.length = array ? array.length : 0;
    }
    reserve(size) {
        if (this.length + size <= this.array.length) {
            return;
        }
        let l = this.array.length;
        while (this.length + size > l) {
            l = Math.ceil(l * 1.5);
        }
        const newArray = new Uint8Array(l);
        newArray.set(this.array);
        this.array = newArray;
    }
    haveReadData() {
        return this.readPos < this.length;
    }
    restartRead() {
        this.readPos = 0;
    }
    asUint8Array() {
        return new Uint8Array(this.array.buffer, this.array.byteOffset, this.length);
    }
    pushArray(v) {
        this.reserve(v.length);
        this.array.set(v, this.length);
        this.length += v.length;
    }
    push(...v) {
        this.pushArray(v);
    }
    get() {
        if (this.readPos < this.length) {
            return this.array[this.readPos++];
        }
        throw new Error('Read past end of buffer');
    }
    pushUint8ArrayChecked(v, len) {
        if (v.length !== len) {
            throw new Error('Binary data has incorrect size');
        }
        this.pushArray(v);
    }
    getUint8Array(len) {
        if (this.readPos + len > this.length) {
            throw new Error('Read past end of buffer');
        }
        const result = new Uint8Array(this.array.buffer, this.array.byteOffset + this.readPos, len);
        this.readPos += len;
        return result;
    }
    skip(len) {
        if (this.readPos + len > this.length) {
            throw new Error('Read past end of buffer');
        }
        this.readPos += len;
    }
    pushUint16(v) {
        this.push((v >> 0) & 0xff, (v >> 8) & 0xff);
    }
    getUint16() {
        let v = 0;
        v |= this.get() << 0;
        v |= this.get() << 8;
        return v;
    }
    pushUint32(v) {
        this.push((v >> 0) & 0xff, (v >> 8) & 0xff, (v >> 16) & 0xff, (v >> 24) & 0xff);
    }
    getUint32() {
        let v = 0;
        v |= this.get() << 0;
        v |= this.get() << 8;
        v |= this.get() << 16;
        v |= this.get() << 24;
        return v >>> 0;
    }
    pushNumberAsUint64(v) {
        this.pushUint32(v >>> 0);
        this.pushUint32(Math.floor(v / 4294967296) >>> 0);
    }
    getUint64AsNumber() {
        const low = this.getUint32();
        const high = this.getUint32();
        return (high >>> 0) * 4294967296 + (low >>> 0);
    }
    pushVaruint32(v) {
        while (true) {
            if (v >>> 7) {
                this.push(0x80 | (v & 0x7f));
                v = v >>> 7;
            }
            else {
                this.push(v);
                break;
            }
        }
    }
    getVaruint32() {
        let v = 0;
        let bit = 0;
        while (true) {
            const b = this.get();
            v |= (b & 0x7f) << bit;
            bit += 7;
            if (!(b & 0x80)) {
                break;
            }
        }
        return v >>> 0;
    }
    pushVarint32(v) {
        this.pushVaruint32((v << 1) ^ (v >> 31));
    }
    getVarint32() {
        const v = this.getVaruint32();
        if (v & 1) {
            return (~v >> 1) | 2147483648;
        }
        else {
            return v >>> 1;
        }
    }
    pushFloat32(v) {
        this.pushArray(new Uint8Array(new Float32Array([v]).buffer));
    }
    getFloat32() {
        return new Float32Array(this.getUint8Array(4).slice().buffer)[0];
    }
    pushFloat64(v) {
        this.pushArray(new Uint8Array(new Float64Array([v]).buffer));
    }
    getFloat64() {
        return new Float64Array(this.getUint8Array(8).slice().buffer)[0];
    }
    pushName(s) {
        const regex = new RegExp(/^[.1-5a-z]{0,12}[.1-5a-j]?$/);
        if (!regex.test(s)) {
            throw new Error('Name should be less than 13 characters, or less than 14 if last character is between 1-5 or a-j, and only contain the following symbols .12345abcdefghijklmnopqrstuvwxyz');
        }
        const charToSymbol = (c) => {
            if (c >= 'a'.charCodeAt(0) && c <= 'z'.charCodeAt(0)) {
                return c - 'a'.charCodeAt(0) + 6;
            }
            if (c >= '1'.charCodeAt(0) && c <= '5'.charCodeAt(0)) {
                return c - '1'.charCodeAt(0) + 1;
            }
            return 0;
        };
        const a = new Uint8Array(8);
        let bit = 63;
        for (let i = 0; i < s.length; ++i) {
            let c = charToSymbol(s.charCodeAt(i));
            if (bit < 5) {
                c = c << 1;
            }
            for (let j = 4; j >= 0; --j) {
                if (bit >= 0) {
                    a[Math.floor(bit / 8)] |= ((c >> j) & 1) << bit % 8;
                    --bit;
                }
            }
        }
        this.pushArray(a);
    }
    getName() {
        const a = this.getUint8Array(8);
        let result = '';
        for (let bit = 63; bit >= 0;) {
            let c = 0;
            for (let i = 0; i < 5; ++i) {
                if (bit >= 0) {
                    c = (c << 1) | ((a[Math.floor(bit / 8)] >> bit % 8) & 1);
                    --bit;
                }
            }
            if (c >= 6) {
                result += String.fromCharCode(c + 'a'.charCodeAt(0) - 6);
            }
            else if (c >= 1) {
                result += String.fromCharCode(c + '1'.charCodeAt(0) - 1);
            }
            else {
                result += '.';
            }
        }
        while (result.endsWith('.')) {
            result = result.substr(0, result.length - 1);
        }
        return result;
    }
    pushBytes(v) {
        this.pushVaruint32(v.length);
        this.pushArray(v);
    }
    getBytes() {
        return this.getUint8Array(this.getVaruint32());
    }
    pushString(v) {
        this.pushBytes(textEncoder.encode(v));
    }
    getString() {
        return textDecoder.decode(this.getBytes());
    }
    pushSymbolCode(name) {
        const a = [];
        a.push(...textEncoder.encode(name));
        while (a.length < 8) {
            a.push(0);
        }
        this.pushArray(a.slice(0, 8));
    }
    getSymbolCode() {
        const a = this.getUint8Array(8);
        let len;
        for (len = 0; len < a.length; ++len) {
            if (!a[len]) {
                break;
            }
        }
        return textDecoder.decode(new Uint8Array(a.buffer, a.byteOffset, len));
    }
    pushSymbol({ name, precision, }) {
        if (!/^[A-Z]{1,7}$/.test(name)) {
            throw new Error('Expected symbol to be A-Z and between one and seven characters');
        }
        const a = [precision & 0xff];
        a.push(...textEncoder.encode(name));
        while (a.length < 8) {
            a.push(0);
        }
        this.pushArray(a.slice(0, 8));
    }
    getSymbol() {
        const precision = this.get();
        const a = this.getUint8Array(7);
        let len;
        for (len = 0; len < a.length; ++len) {
            if (!a[len]) {
                break;
            }
        }
        const name = textDecoder.decode(new Uint8Array(a.buffer, a.byteOffset, len));
        return { name, precision };
    }
    pushAsset(s) {
        s = s.trim();
        let pos = 0;
        let amount = '';
        let precision = 0;
        if (s[pos] === '-') {
            amount += '-';
            ++pos;
        }
        let foundDigit = false;
        while (pos < s.length &&
            s.charCodeAt(pos) >= '0'.charCodeAt(0) &&
            s.charCodeAt(pos) <= '9'.charCodeAt(0)) {
            foundDigit = true;
            amount += s[pos];
            ++pos;
        }
        if (!foundDigit) {
            throw new Error('Asset must begin with a number');
        }
        if (s[pos] === '.') {
            ++pos;
            while (pos < s.length &&
                s.charCodeAt(pos) >= '0'.charCodeAt(0) &&
                s.charCodeAt(pos) <= '9'.charCodeAt(0)) {
                amount += s[pos];
                ++precision;
                ++pos;
            }
        }
        const name = s.substr(pos).trim();
        this.pushArray(numeric.signedDecimalToBinary(8, amount));
        this.pushSymbol({ name, precision });
    }
    getAsset() {
        const amount = this.getUint8Array(8);
        const { name, precision } = this.getSymbol();
        let s = numeric.signedBinaryToDecimal(amount, precision + 1);
        if (precision) {
            s =
                s.substr(0, s.length - precision) +
                    '.' +
                    s.substr(s.length - precision);
        }
        return s + ' ' + name;
    }
    pushPublicKey(s) {
        const key = numeric.stringToPublicKey(s);
        this.push(key.type);
        this.pushArray(key.data);
    }
    getPublicKey() {
        const type = this.get();
        let data;
        if (type === types_1.KeyType.wa) {
            const begin = this.readPos;
            this.skip(34);
            this.skip(this.getVaruint32());
            data = new Uint8Array(this.array.buffer, this.array.byteOffset + begin, this.readPos - begin);
        }
        else {
            data = this.getUint8Array(types_1.publicKeyDataSize);
        }
        return numeric.publicKeyToString({ type, data });
    }
    pushPrivateKey(s) {
        const key = numeric.stringToPrivateKey(s);
        this.push(key.type);
        this.pushArray(key.data);
    }
    getPrivateKey() {
        const type = this.get();
        const data = this.getUint8Array(types_1.privateKeyDataSize);
        return numeric.privateKeyToString({ type, data });
    }
    pushSignature(s) {
        const key = numeric.stringToSignature(s);
        this.push(key.type);
        this.pushArray(key.data);
    }
    getSignature() {
        const type = this.get();
        let data;
        if (type === types_1.KeyType.wa) {
            const begin = this.readPos;
            this.skip(65);
            this.skip(this.getVaruint32());
            this.skip(this.getVaruint32());
            data = new Uint8Array(this.array.buffer, this.array.byteOffset + begin, this.readPos - begin);
        }
        else {
            data = this.getUint8Array(types_1.signatureDataSize);
        }
        return numeric.signatureToString({ type, data });
    }
}
exports.SerialBuffer = SerialBuffer;
class SerializerState {
    constructor(options = {}) {
        this.skippedBinaryExtension = false;
        this.options = options;
    }
}
exports.SerializerState = SerializerState;
function serializeUnknown(buffer, data) {
    throw new Error("Don't know how to serialize " + this.name);
}
function deserializeUnknown(buffer) {
    throw new Error("Don't know how to deserialize " + this.name);
}
function serializeStruct(buffer, data, state = new SerializerState(), allowExtensions = true) {
    if (typeof data !== 'object') {
        throw new Error('expected object containing data: ' + JSON.stringify(data));
    }
    if (this.base) {
        this.base.serialize(buffer, data, state, allowExtensions);
    }
    for (const field of this.fields) {
        if (field.name in data) {
            if (state.skippedBinaryExtension) {
                throw new Error('unexpected ' + this.name + '.' + field.name);
            }
            field.type?.serialize(buffer, data[field.name], state, allowExtensions && field === this.fields[this.fields.length - 1]);
        }
        else {
            if (allowExtensions && field.type?.extensionOf) {
                state.skippedBinaryExtension = true;
            }
            else {
                throw new Error('missing ' +
                    this.name +
                    '.' +
                    field.name +
                    ' (type=' +
                    field.type?.name +
                    ')');
            }
        }
    }
}
function deserializeStruct(buffer, state = new SerializerState(), allowExtensions = true) {
    let result;
    if (this.base) {
        result = this.base.deserialize(buffer, state, allowExtensions);
    }
    else {
        result = {};
    }
    for (const field of this.fields) {
        if (allowExtensions && field.type?.extensionOf && !buffer.haveReadData()) {
            state.skippedBinaryExtension = true;
        }
        else {
            result[field.name] = field.type?.deserialize(buffer, state, allowExtensions);
        }
    }
    return result;
}
function serializeVariant(buffer, data, state, allowExtensions) {
    if (!Array.isArray(data) ||
        data.length !== 2 ||
        typeof data[0] !== 'string') {
        throw new Error('expected variant: ["type", value]');
    }
    const i = this.fields.findIndex((field) => field.name === data[0]);
    if (i < 0) {
        throw new Error(`type "${data[0]}" is not valid for variant`);
    }
    buffer.pushVaruint32(i);
    this.fields[i].type?.serialize(buffer, data[1], state, allowExtensions);
}
function deserializeVariant(buffer, state, allowExtensions) {
    const i = buffer.getVaruint32();
    if (i >= this.fields.length) {
        throw new Error(`type index ${i} is not valid for variant`);
    }
    const field = this.fields[i];
    return [field.name, field.type?.deserialize(buffer, state, allowExtensions)];
}
function serializeArray(buffer, data, state, allowExtensions) {
    buffer.pushVaruint32(data.length);
    for (const item of data) {
        this.arrayOf?.serialize(buffer, item, state, false);
    }
}
function deserializeArray(buffer, state, allowExtensions) {
    const len = buffer.getVaruint32();
    const result = [];
    for (let i = 0; i < len; ++i) {
        result.push(this.arrayOf?.deserialize(buffer, state, false));
    }
    return result;
}
function serializeOptional(buffer, data, state, allowExtensions) {
    if (data === null || data === undefined) {
        buffer.push(0);
    }
    else {
        buffer.push(1);
        this.optionalOf?.serialize(buffer, data, state, allowExtensions);
    }
}
function deserializeOptional(buffer, state, allowExtensions) {
    if (buffer.get()) {
        return this.optionalOf?.deserialize(buffer, state, allowExtensions);
    }
    else {
        return null;
    }
}
function serializeExtension(buffer, data, state, allowExtensions) {
    this.extensionOf?.serialize(buffer, data, state, allowExtensions);
}
function deserializeExtension(buffer, state, allowExtensions) {
    return this.extensionOf?.deserialize(buffer, state, allowExtensions);
}
function serializeObject(buffer, data, state, allowExtensions) {
    const entries = Object.entries(data);
    buffer.pushVaruint32(entries.length);
    for (const [key, value] of entries) {
        const keyType = this.fields[0].type;
        const dataType = this.fields[1].type;
        keyType?.serialize(buffer, key, state, allowExtensions);
        dataType?.serialize(buffer, value, state, allowExtensions);
    }
}
function deserializeObject(buffer, state, allowExtensions) {
    const len = buffer.getVaruint32();
    const result = {};
    for (let i = 0; i < len; ++i) {
        const keyType = this.fields[0].type;
        const dataType = this.fields[1].type;
        const key = keyType?.deserialize(buffer, state, allowExtensions);
        result[key] = dataType?.deserialize(buffer, state, allowExtensions);
    }
    return result;
}
function serializePair(buffer, data, state, allowExtensions) {
    buffer.pushVaruint32(data.length);
    data.forEach((item) => {
        this.fields[0].type?.serialize(buffer, item[0], state, allowExtensions);
        this.fields[1].type?.serialize(buffer, item[1], state, allowExtensions);
    });
}
function deserializePair(buffer, state, allowExtensions) {
    const result = [];
    const len = buffer.getVaruint32();
    for (let i = 0; i < len; ++i) {
        result.push(this.fields[0].type?.deserialize(buffer, state, allowExtensions));
        result.push(this.fields[1].type?.deserialize(buffer, state, allowExtensions));
    }
    return result;
}
const createType = (attrs) => {
    return {
        name: '<missing name>',
        aliasOfName: '',
        arrayOf: undefined,
        optionalOf: undefined,
        extensionOf: undefined,
        baseName: '',
        base: undefined,
        fields: [],
        serialize: serializeUnknown,
        deserialize: deserializeUnknown,
        ...attrs,
    };
};
const getType = (types, name) => {
    const type = types.get(name);
    if (type && type.aliasOfName) {
        return (0, exports.getType)(types, type.aliasOfName);
    }
    if (type) {
        return type;
    }
    if (name.endsWith('[]')) {
        return createType({
            name,
            arrayOf: (0, exports.getType)(types, name.substr(0, name.length - 2)),
            serialize: serializeArray,
            deserialize: deserializeArray,
        });
    }
    if (name.endsWith('?')) {
        return createType({
            name,
            optionalOf: (0, exports.getType)(types, name.substr(0, name.length - 1)),
            serialize: serializeOptional,
            deserialize: deserializeOptional,
        });
    }
    if (name.endsWith('$')) {
        return createType({
            name,
            extensionOf: (0, exports.getType)(types, name.substr(0, name.length - 1)),
            serialize: serializeExtension,
            deserialize: deserializeExtension,
        });
    }
    throw new Error('Unknown type: ' + name);
};
exports.getType = getType;
const getTypesFromAbi = (initialTypes, abi) => {
    const types = new Map(initialTypes);
    if (abi && abi.types) {
        for (const { new_type_name, type } of abi.types) {
            types.set(new_type_name, createType({ name: new_type_name, aliasOfName: type }));
        }
    }
    if (abi && abi.structs) {
        for (const { name, base, fields } of abi.structs) {
            types.set(name, createType({
                name,
                baseName: base,
                fields: fields.map(({ name: n, type }) => ({
                    name: n,
                    typeName: type,
                    type: undefined,
                })),
                serialize: serializeStruct,
                deserialize: deserializeStruct,
            }));
        }
    }
    if (abi && abi.variants) {
        for (const { name, types: t } of abi.variants) {
            types.set(name, createType({
                name,
                fields: t.map((s) => ({ name: s, typeName: s, type: undefined })),
                serialize: serializeVariant,
                deserialize: deserializeVariant,
            }));
        }
    }
    for (const [name, type] of types) {
        if (type.baseName) {
            type.base = (0, exports.getType)(types, type.baseName);
        }
        for (const field of type.fields) {
            field.type = (0, exports.getType)(types, field.typeName);
        }
    }
    return types;
};
exports.getTypesFromAbi = getTypesFromAbi;
const checkRange = (orig, converted) => {
    if (Number.isNaN(+orig) ||
        Number.isNaN(+converted) ||
        (typeof orig !== 'number' && typeof orig !== 'string')) {
        throw new Error('Expected number');
    }
    if (+orig !== +converted) {
        throw new Error('Number is out of range');
    }
    return +orig;
};
const arrayToHex = (data) => {
    let result = '';
    for (const x of data) {
        result += ('00' + x.toString(16)).slice(-2);
    }
    return result.toUpperCase();
};
exports.arrayToHex = arrayToHex;
const hexToUint8Array = (hex) => {
    if (typeof hex !== 'string') {
        throw new Error('Expected string containing hex digits');
    }
    if (hex.length % 2) {
        throw new Error('Odd number of hex digits');
    }
    const l = hex.length / 2;
    const result = new Uint8Array(l);
    for (let i = 0; i < l; ++i) {
        const x = parseInt(hex.substr(i * 2, 2), 16);
        if (Number.isNaN(x)) {
            throw new Error('Expected hex string');
        }
        result[i] = x;
    }
    return result;
};
exports.hexToUint8Array = hexToUint8Array;
const checkDateParse = (date) => {
    const result = Date.parse(date);
    if (Number.isNaN(result)) {
        throw new Error('Invalid time format');
    }
    return result;
};
const dateToTimePoint = (date) => {
    return Math.round(checkDateParse(date + 'Z') * 1000);
};
exports.dateToTimePoint = dateToTimePoint;
const timePointToDate = (us) => {
    const s = new Date(us / 1000).toISOString();
    return s.substr(0, s.length - 1);
};
exports.timePointToDate = timePointToDate;
const dateToTimePointSec = (date) => {
    return Math.round(checkDateParse(date + 'Z') / 1000);
};
exports.dateToTimePointSec = dateToTimePointSec;
const timePointSecToDate = (sec) => {
    const s = new Date(sec * 1000).toISOString();
    return s.substr(0, s.length - 1);
};
exports.timePointSecToDate = timePointSecToDate;
const dateToBlockTimestamp = (date) => {
    return Math.round((checkDateParse(date + 'Z') - 946684800000) / 500);
};
exports.dateToBlockTimestamp = dateToBlockTimestamp;
const blockTimestampToDate = (slot) => {
    const s = new Date(slot * 500 + 946684800000).toISOString();
    return s.substr(0, s.length - 1);
};
exports.blockTimestampToDate = blockTimestampToDate;
const stringToSymbol = (s) => {
    if (typeof s !== 'string') {
        throw new Error('Expected string containing symbol');
    }
    const m = s.match(/^([0-9]+),([A-Z]+)$/);
    if (!m) {
        throw new Error('Invalid symbol');
    }
    return { name: m[2], precision: +m[1] };
};
exports.stringToSymbol = stringToSymbol;
const symbolToString = ({ name, precision, }) => {
    return precision + ',' + name;
};
exports.symbolToString = symbolToString;
const createInitialTypes = () => {
    const result = new Map(Object.entries({
        bool: createType({
            name: 'bool',
            serialize: (buffer, data) => {
                if (!(typeof data === 'boolean' ||
                    (typeof data === 'number' && (data === 1 || data === 0)))) {
                    throw new Error('Expected boolean or number equal to 1 or 0');
                }
                buffer.push(data ? 1 : 0);
            },
            deserialize: (buffer) => {
                return !!buffer.get();
            },
        }),
        uint8: createType({
            name: 'uint8',
            serialize: (buffer, data) => {
                buffer.push(checkRange(data, data & 0xff));
            },
            deserialize: (buffer) => {
                return buffer.get();
            },
        }),
        int8: createType({
            name: 'int8',
            serialize: (buffer, data) => {
                buffer.push(checkRange(data, (data << 24) >> 24));
            },
            deserialize: (buffer) => {
                return (buffer.get() << 24) >> 24;
            },
        }),
        uint16: createType({
            name: 'uint16',
            serialize: (buffer, data) => {
                buffer.pushUint16(checkRange(data, data & 0xffff));
            },
            deserialize: (buffer) => {
                return buffer.getUint16();
            },
        }),
        int16: createType({
            name: 'int16',
            serialize: (buffer, data) => {
                buffer.pushUint16(checkRange(data, (data << 16) >> 16));
            },
            deserialize: (buffer) => {
                return (buffer.getUint16() << 16) >> 16;
            },
        }),
        uint32: createType({
            name: 'uint32',
            serialize: (buffer, data) => {
                buffer.pushUint32(checkRange(data, data >>> 0));
            },
            deserialize: (buffer) => {
                return buffer.getUint32();
            },
        }),
        uint64: createType({
            name: 'uint64',
            serialize: (buffer, data) => {
                buffer.pushArray(numeric.decimalToBinary(8, '' + data));
            },
            deserialize: (buffer) => {
                return numeric.binaryToDecimal(buffer.getUint8Array(8));
            },
        }),
        int64: createType({
            name: 'int64',
            serialize: (buffer, data) => {
                buffer.pushArray(numeric.signedDecimalToBinary(8, '' + data));
            },
            deserialize: (buffer) => {
                return numeric.signedBinaryToDecimal(buffer.getUint8Array(8));
            },
        }),
        int32: createType({
            name: 'int32',
            serialize: (buffer, data) => {
                buffer.pushUint32(checkRange(data, data | 0));
            },
            deserialize: (buffer) => {
                return buffer.getUint32() | 0;
            },
        }),
        varuint32: createType({
            name: 'varuint32',
            serialize: (buffer, data) => {
                buffer.pushVaruint32(checkRange(data, data >>> 0));
            },
            deserialize: (buffer) => {
                return buffer.getVaruint32();
            },
        }),
        varint32: createType({
            name: 'varint32',
            serialize: (buffer, data) => {
                buffer.pushVarint32(checkRange(data, data | 0));
            },
            deserialize: (buffer) => {
                return buffer.getVarint32();
            },
        }),
        uint128: createType({
            name: 'uint128',
            serialize: (buffer, data) => {
                buffer.pushArray(numeric.decimalToBinary(16, '' + data));
            },
            deserialize: (buffer) => {
                return numeric.binaryToDecimal(buffer.getUint8Array(16));
            },
        }),
        int128: createType({
            name: 'int128',
            serialize: (buffer, data) => {
                buffer.pushArray(numeric.signedDecimalToBinary(16, '' + data));
            },
            deserialize: (buffer) => {
                return numeric.signedBinaryToDecimal(buffer.getUint8Array(16));
            },
        }),
        float32: createType({
            name: 'float32',
            serialize: (buffer, data) => {
                buffer.pushFloat32(data);
            },
            deserialize: (buffer) => {
                return buffer.getFloat32();
            },
        }),
        float64: createType({
            name: 'float64',
            serialize: (buffer, data) => {
                buffer.pushFloat64(data);
            },
            deserialize: (buffer) => {
                return buffer.getFloat64();
            },
        }),
        float128: createType({
            name: 'float128',
            serialize: (buffer, data) => {
                buffer.pushUint8ArrayChecked((0, exports.hexToUint8Array)(data), 16);
            },
            deserialize: (buffer) => {
                return (0, exports.arrayToHex)(buffer.getUint8Array(16));
            },
        }),
        bytes: createType({
            name: 'bytes',
            serialize: (buffer, data) => {
                if (data instanceof Uint8Array || Array.isArray(data)) {
                    buffer.pushBytes(data);
                }
                else {
                    buffer.pushBytes((0, exports.hexToUint8Array)(data));
                }
            },
            deserialize: (buffer, state) => {
                if (state && state.options.bytesAsUint8Array) {
                    return buffer.getBytes();
                }
                else {
                    return (0, exports.arrayToHex)(buffer.getBytes());
                }
            },
        }),
        string: createType({
            name: 'string',
            serialize: (buffer, data) => {
                buffer.pushString(data);
            },
            deserialize: (buffer) => {
                return buffer.getString();
            },
        }),
        name: createType({
            name: 'name',
            serialize: (buffer, data) => {
                buffer.pushName(data);
            },
            deserialize: (buffer) => {
                return buffer.getName();
            },
        }),
        time_point: createType({
            name: 'time_point',
            serialize: (buffer, data) => {
                buffer.pushNumberAsUint64((0, exports.dateToTimePoint)(data));
            },
            deserialize: (buffer) => {
                return (0, exports.timePointToDate)(buffer.getUint64AsNumber());
            },
        }),
        time_point_sec: createType({
            name: 'time_point_sec',
            serialize: (buffer, data) => {
                buffer.pushUint32((0, exports.dateToTimePointSec)(data));
            },
            deserialize: (buffer) => {
                return (0, exports.timePointSecToDate)(buffer.getUint32());
            },
        }),
        block_timestamp_type: createType({
            name: 'block_timestamp_type',
            serialize: (buffer, data) => {
                buffer.pushUint32((0, exports.dateToBlockTimestamp)(data));
            },
            deserialize: (buffer) => {
                return (0, exports.blockTimestampToDate)(buffer.getUint32());
            },
        }),
        symbol_code: createType({
            name: 'symbol_code',
            serialize: (buffer, data) => {
                buffer.pushSymbolCode(data);
            },
            deserialize: (buffer) => {
                return buffer.getSymbolCode();
            },
        }),
        symbol: createType({
            name: 'symbol',
            serialize: (buffer, data) => {
                buffer.pushSymbol((0, exports.stringToSymbol)(data));
            },
            deserialize: (buffer) => {
                return (0, exports.symbolToString)(buffer.getSymbol());
            },
        }),
        asset: createType({
            name: 'asset',
            serialize: (buffer, data) => {
                buffer.pushAsset(data);
            },
            deserialize: (buffer) => {
                return buffer.getAsset();
            },
        }),
        checksum160: createType({
            name: 'checksum160',
            serialize: (buffer, data) => {
                buffer.pushUint8ArrayChecked((0, exports.hexToUint8Array)(data), 20);
            },
            deserialize: (buffer) => {
                return (0, exports.arrayToHex)(buffer.getUint8Array(20));
            },
        }),
        checksum256: createType({
            name: 'checksum256',
            serialize: (buffer, data) => {
                buffer.pushUint8ArrayChecked((0, exports.hexToUint8Array)(data), 32);
            },
            deserialize: (buffer) => {
                return (0, exports.arrayToHex)(buffer.getUint8Array(32));
            },
        }),
        checksum512: createType({
            name: 'checksum512',
            serialize: (buffer, data) => {
                buffer.pushUint8ArrayChecked((0, exports.hexToUint8Array)(data), 64);
            },
            deserialize: (buffer) => {
                return (0, exports.arrayToHex)(buffer.getUint8Array(64));
            },
        }),
        public_key: createType({
            name: 'public_key',
            serialize: (buffer, data) => {
                buffer.pushPublicKey(data);
            },
            deserialize: (buffer) => {
                return buffer.getPublicKey();
            },
        }),
        private_key: createType({
            name: 'private_key',
            serialize: (buffer, data) => {
                buffer.pushPrivateKey(data);
            },
            deserialize: (buffer) => {
                return buffer.getPrivateKey();
            },
        }),
        signature: createType({
            name: 'signature',
            serialize: (buffer, data) => {
                buffer.pushSignature(data);
            },
            deserialize: (buffer) => {
                return buffer.getSignature();
            },
        }),
    }));
    result.set('extended_asset', createType({
        name: 'extended_asset',
        baseName: '',
        fields: [
            { name: 'quantity', typeName: 'asset', type: result.get('asset') },
            { name: 'contract', typeName: 'name', type: result.get('name') },
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct,
    }));
    return result;
};
exports.createInitialTypes = createInitialTypes;
const createAbiTypes = () => {
    const initialTypes = (0, exports.createInitialTypes)();
    initialTypes.set('extensions_entry', createType({
        name: 'extensions_entry',
        baseName: '',
        fields: [
            { name: 'tag', typeName: 'uint16', type: undefined },
            { name: 'value', typeName: 'bytes', type: undefined },
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct,
    }));
    initialTypes.set('type_def', createType({
        name: 'type_def',
        baseName: '',
        fields: [
            { name: 'new_type_name', typeName: 'string', type: undefined },
            { name: 'type', typeName: 'string', type: undefined },
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct,
    }));
    initialTypes.set('field_def', createType({
        name: 'field_def',
        baseName: '',
        fields: [
            { name: 'name', typeName: 'string', type: undefined },
            { name: 'type', typeName: 'string', type: undefined },
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct,
    }));
    initialTypes.set('struct_def', createType({
        name: 'struct_def',
        baseName: '',
        fields: [
            { name: 'name', typeName: 'string', type: undefined },
            { name: 'base', typeName: 'string', type: undefined },
            { name: 'fields', typeName: 'field_def[]', type: undefined },
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct,
    }));
    initialTypes.set('action_def', createType({
        name: 'action_def',
        baseName: '',
        fields: [
            { name: 'name', typeName: 'name', type: undefined },
            { name: 'type', typeName: 'string', type: undefined },
            { name: 'ricardian_contract', typeName: 'string', type: undefined },
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct,
    }));
    initialTypes.set('table_def', createType({
        name: 'table_def',
        baseName: '',
        fields: [
            { name: 'name', typeName: 'name', type: undefined },
            { name: 'index_type', typeName: 'string', type: undefined },
            { name: 'key_names', typeName: 'string[]', type: undefined },
            { name: 'key_types', typeName: 'string[]', type: undefined },
            { name: 'type', typeName: 'string', type: undefined },
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct,
    }));
    initialTypes.set('clause_pair', createType({
        name: 'clause_pair',
        baseName: '',
        fields: [
            { name: 'id', typeName: 'string', type: undefined },
            { name: 'body', typeName: 'string', type: undefined },
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct,
    }));
    initialTypes.set('error_message', createType({
        name: 'error_message',
        baseName: '',
        fields: [
            { name: 'error_code', typeName: 'uint64', type: undefined },
            { name: 'error_msg', typeName: 'string', type: undefined },
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct,
    }));
    initialTypes.set('variant_def', createType({
        name: 'variant_def',
        baseName: '',
        fields: [
            { name: 'name', typeName: 'string', type: undefined },
            { name: 'types', typeName: 'string[]', type: undefined },
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct,
    }));
    initialTypes.set('action_result', createType({
        name: 'action_result',
        baseName: '',
        fields: [
            { name: 'name', typeName: 'name', type: undefined },
            { name: 'result_type', typeName: 'string', type: undefined },
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct,
    }));
    initialTypes.set('primary_key_index_def', createType({
        name: 'primary_key_index_def',
        baseName: '',
        fields: [
            { name: 'name', typeName: 'name', type: undefined },
            { name: 'type', typeName: 'string', type: undefined },
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct,
    }));
    initialTypes.set('secondary_index_def', createType({
        name: 'secondary_index_def',
        baseName: '',
        fields: [{ name: 'type', typeName: 'string', type: undefined }],
        serialize: serializeStruct,
        deserialize: deserializeStruct,
    }));
    initialTypes.set('secondary_indices', createType({
        name: 'secondary_indices',
        baseName: '',
        fields: [
            { name: 'name', typeName: 'name', type: undefined },
            {
                name: 'secondary_index_def',
                typeName: 'secondary_index_def',
                type: undefined,
            },
        ],
        serialize: serializeObject,
        deserialize: deserializeObject,
    }));
    initialTypes.set('kv_table_entry_def', createType({
        name: 'kv_table_entry_def',
        baseName: '',
        fields: [
            { name: 'type', typeName: 'string', type: undefined },
            {
                name: 'primary_index',
                typeName: 'primary_key_index_def',
                type: undefined,
            },
            {
                name: 'secondary_indices',
                typeName: 'secondary_indices',
                type: undefined,
            },
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct,
    }));
    initialTypes.set('kv_table', createType({
        name: 'kv_table',
        baseName: '',
        fields: [
            { name: 'name', typeName: 'name', type: undefined },
            {
                name: 'kv_table_entry_def',
                typeName: 'kv_table_entry_def',
                type: undefined,
            },
        ],
        serialize: serializeObject,
        deserialize: deserializeObject,
    }));
    initialTypes.set('abi_def', createType({
        name: 'abi_def',
        baseName: '',
        fields: [
            { name: 'version', typeName: 'string', type: undefined },
            { name: 'types', typeName: 'type_def[]', type: undefined },
            { name: 'structs', typeName: 'struct_def[]', type: undefined },
            { name: 'actions', typeName: 'action_def[]', type: undefined },
            { name: 'tables', typeName: 'table_def[]', type: undefined },
            {
                name: 'ricardian_clauses',
                typeName: 'clause_pair[]',
                type: undefined,
            },
            {
                name: 'error_messages',
                typeName: 'error_message[]',
                type: undefined,
            },
            {
                name: 'abi_extensions',
                typeName: 'extensions_entry[]',
                type: undefined,
            },
            { name: 'variants', typeName: 'variant_def[]$', type: undefined },
            {
                name: 'action_results',
                typeName: 'action_result[]$',
                type: undefined,
            },
            { name: 'kv_tables', typeName: 'kv_table$', type: undefined },
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct,
    }));
    return initialTypes;
};
exports.createAbiTypes = createAbiTypes;
const createTransactionTypes = () => {
    const initialTypes = (0, exports.createInitialTypes)();
    initialTypes.set('permission_level', createType({
        name: 'permission_level',
        baseName: '',
        fields: [
            { name: 'actor', typeName: 'name', type: undefined },
            { name: 'permission', typeName: 'name', type: undefined },
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct,
    }));
    initialTypes.set('action', createType({
        name: 'action',
        baseName: '',
        fields: [
            { name: 'account', typeName: 'name', type: undefined },
            { name: 'name', typeName: 'name', type: undefined },
            {
                name: 'authorization',
                typeName: 'permission_level[]',
                type: undefined,
            },
            { name: 'data', typeName: 'bytes', type: undefined },
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct,
    }));
    initialTypes.set('extension', createType({
        name: 'extension',
        baseName: '',
        fields: [
            { name: 'type', typeName: 'uint16', type: undefined },
            { name: 'data', typeName: 'bytes', type: undefined },
        ],
        serialize: serializePair,
        deserialize: deserializePair,
    }));
    initialTypes.set('transaction_header', createType({
        name: 'transaction_header',
        baseName: '',
        fields: [
            { name: 'expiration', typeName: 'time_point_sec', type: undefined },
            { name: 'ref_block_num', typeName: 'uint16', type: undefined },
            { name: 'ref_block_prefix', typeName: 'uint32', type: undefined },
            { name: 'max_net_usage_words', typeName: 'varuint32', type: undefined },
            { name: 'max_cpu_usage_ms', typeName: 'uint8', type: undefined },
            { name: 'delay_sec', typeName: 'varuint32', type: undefined },
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct,
    }));
    initialTypes.set('transaction', createType({
        name: 'transaction',
        baseName: 'transaction_header',
        fields: [
            { name: 'context_free_actions', typeName: 'action[]', type: undefined },
            { name: 'actions', typeName: 'action[]', type: undefined },
            {
                name: 'transaction_extensions',
                typeName: 'extension',
                type: undefined,
            },
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct,
    }));
    return initialTypes;
};
exports.createTransactionTypes = createTransactionTypes;
const createTransactionExtensionTypes = () => {
    const initialTypes = (0, exports.createInitialTypes)();
    initialTypes.set('resource_payer', createType({
        name: 'resource_payer',
        baseName: '',
        fields: [
            { name: 'payer', typeName: 'name', type: undefined },
            { name: 'max_net_bytes', typeName: 'uint64', type: undefined },
            { name: 'max_cpu_us', typeName: 'uint64', type: undefined },
            { name: 'max_memory_bytes', typeName: 'uint64', type: undefined },
        ],
        serialize: serializeStruct,
        deserialize: deserializeStruct,
    }));
    return initialTypes;
};
exports.createTransactionExtensionTypes = createTransactionExtensionTypes;
const reverseHex = (h) => {
    return h.substr(6, 2) + h.substr(4, 2) + h.substr(2, 2) + h.substr(0, 2);
};
const transactionHeader = (refBlock, expireSeconds) => {
    const prefix = parseInt(reverseHex(refBlock.id.substr(16, 8)), 16);
    return {
        expiration: (0, exports.timePointSecToDate)((0, exports.dateToTimePointSec)(refBlock.timestamp) + expireSeconds),
        ref_block_num: refBlock.block_num & 0xffff,
        ref_block_prefix: prefix,
    };
};
exports.transactionHeader = transactionHeader;
const supportedAbiVersion = (version) => {
    return version.startsWith('eosio::abi/1.');
};
exports.supportedAbiVersion = supportedAbiVersion;
const serializeAction = (contract, account, name, authorization, data) => {
    return {
        account,
        name,
        authorization,
        data: (0, exports.serializeActionData)(contract, account, name, data),
    };
};
exports.serializeAction = serializeAction;
const serializeActionData = (contract, account, name, data) => {
    const action = contract.actions.get(name);
    if (!action) {
        throw new Error(`Unknown action ${name} in contract ${account}`);
    }
    const buffer = new SerialBuffer();
    action.serialize(buffer, data);
    return (0, exports.arrayToHex)(buffer.asUint8Array());
};
exports.serializeActionData = serializeActionData;
//# sourceMappingURL=serialize.js.map