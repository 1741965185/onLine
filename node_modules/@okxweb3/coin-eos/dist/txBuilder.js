"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxBuilder = void 0;
const serialize_1 = require("./serialize");
const types_1 = require("./types");
const numeric_1 = require("./numeric");
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const pako_1 = require("pako");
const ec = new crypto_lib_1.elliptic.ec('secp256k1');
class TxBuilder {
    constructor(chainId) {
        this.chainId = chainId;
        this.abiTypes = (0, serialize_1.getTypesFromAbi)((0, serialize_1.createAbiTypes)());
        this.transactionTypes = (0, serialize_1.getTypesFromAbi)((0, serialize_1.createTransactionTypes)());
    }
    getTransactionAbiMap(transaction, abiMap) {
        const actions = (transaction.context_free_actions || []).concat(transaction.actions);
        const accounts = actions.map((action) => action.account);
        const uniqueAccounts = new Set(accounts);
        const destMap = new Map();
        uniqueAccounts.forEach(acc => {
            const abiStr = abiMap.get(acc);
            if (abiStr) {
                const abiU8 = (0, numeric_1.base64ToBinary)(abiStr);
                destMap.set(acc, this.rawAbiToJson(abiU8));
            }
        });
        return destMap;
    }
    serializeTransactionExtensions(transaction, resource_payer) {
        let transaction_extensions = [];
        if (resource_payer) {
            const extensionBuffer = new serialize_1.SerialBuffer();
            const types = (0, serialize_1.getTypesFromAbi)((0, serialize_1.createTransactionExtensionTypes)());
            types.get('resource_payer').serialize(extensionBuffer, resource_payer);
            transaction_extensions = [...transaction_extensions, [1, (0, serialize_1.arrayToHex)(extensionBuffer.asUint8Array())]];
        }
        return transaction_extensions;
    }
    ;
    serializeActions(actions, abiMap) {
        const actionArray = [];
        for (const { account, name, authorization, data } of actions) {
            const abi = abiMap.get(account);
            if (abi) {
                const contract = this.getContract(abi);
                const sa = (0, serialize_1.serializeAction)(contract, account, name, authorization, data);
                actionArray.push(sa);
            }
        }
        return actionArray;
    }
    getContract(abi) {
        const types = (0, serialize_1.getTypesFromAbi)((0, serialize_1.createInitialTypes)(), abi);
        const actions = new Map();
        for (const { name, type } of abi.actions) {
            actions.set(name, (0, serialize_1.getType)(types, type));
        }
        return { types, actions };
    }
    rawAbiToJson(rawAbi) {
        const buffer = new serialize_1.SerialBuffer(rawAbi);
        if (!(0, serialize_1.supportedAbiVersion)(buffer.getString())) {
            throw new Error('Unsupported abi version');
        }
        buffer.restartRead();
        return this.abiTypes.get('abi_def').deserialize(buffer);
    }
    serializeTransaction(transaction) {
        const buffer = new serialize_1.SerialBuffer();
        this.serialize(buffer, 'transaction', {
            max_net_usage_words: 0,
            max_cpu_usage_ms: 0,
            delay_sec: 0,
            context_free_actions: [],
            transaction_extensions: [],
            ...transaction,
        });
        return buffer.asUint8Array();
    }
    serialize(buffer, type, value) {
        this.transactionTypes.get(type).serialize(buffer, value);
    }
    serializeContextFreeData(contextFreeData) {
        if (!contextFreeData || !contextFreeData.length) {
            return undefined;
        }
        const buffer = new serialize_1.SerialBuffer();
        buffer.pushVaruint32(contextFreeData.length);
        for (const data of contextFreeData) {
            buffer.pushBytes(data);
        }
        return buffer.asUint8Array();
    }
    deflateSerializedArray(serializedArray) {
        return (0, pako_1.deflate)(serializedArray, { level: 9 });
    }
    build(transaction, config, abiMap) {
        const refBlockInfo = { block_num: config.refBlockNumber, id: config.refBlockId, timestamp: config.refBlockTimestamp };
        const header = (0, serialize_1.transactionHeader)(refBlockInfo, config.expireSeconds);
        transaction.expiration = header.expiration;
        transaction.ref_block_num = header.ref_block_num;
        transaction.ref_block_prefix = header.ref_block_prefix;
        const transactionAbiMap = this.getTransactionAbiMap(transaction, abiMap);
        transaction.transaction_extensions = this.serializeTransactionExtensions(transaction, config.resource_payer);
        transaction.context_free_actions = this.serializeActions(transaction.context_free_actions || [], transactionAbiMap);
        transaction.actions = this.serializeActions(transaction.actions, transactionAbiMap);
        const serializedTransaction = this.serializeTransaction(transaction);
        const serializedContextFreeData = this.serializeContextFreeData(transaction.context_free_data);
        const signatures = this.sign(config.privateKeys, serializedTransaction, serializedContextFreeData);
        if (config.compression) {
            const compressedSerializedTransaction = this.deflateSerializedArray(serializedTransaction);
            const compressedSerializedContextFreeData = this.deflateSerializedArray(serializedContextFreeData || new Uint8Array(0));
            return {
                signatures: signatures,
                compression: true,
                packed_context_free_data: (0, serialize_1.arrayToHex)(compressedSerializedContextFreeData || new Uint8Array(0)),
                packed_trx: (0, serialize_1.arrayToHex)(compressedSerializedTransaction || new Uint8Array(0))
            };
        }
        else {
            return {
                signatures: signatures,
                compression: false,
                packed_context_free_data: (0, serialize_1.arrayToHex)(serializedContextFreeData || new Uint8Array(0)),
                packed_trx: (0, serialize_1.arrayToHex)(serializedTransaction || new Uint8Array(0))
            };
        }
    }
    sign(privateKeys, serializedTransaction, serializedContextFreeData) {
        const digest = (0, numeric_1.digestFromSerializedData)(this.chainId, serializedTransaction, serializedContextFreeData);
        const signatures = [];
        for (const key of privateKeys) {
            const privateKey = (0, numeric_1.stringToPrivateKey)(key).data;
            const isCanonical = (sigData) => !(sigData[1] & 0x80) && !(sigData[1] === 0 && !(sigData[2] & 0x80))
                && !(sigData[33] & 0x80) && !(sigData[33] === 0 && !(sigData[34] & 0x80));
            let tries = 0;
            let signature;
            do {
                const rawSign = ec.sign(Array.from(digest), Buffer.from(privateKey), { canonical: true, pers: [++tries] });
                let eosioRecoveryParam = rawSign.recoveryParam + 27;
                if (rawSign.recoveryParam <= 3) {
                    eosioRecoveryParam += 4;
                }
                const d = new Uint8Array([eosioRecoveryParam].concat(...rawSign.toBytes()));
                signature = { type: types_1.KeyType.k1, data: d };
            } while (!isCanonical(signature.data));
            const result = (0, numeric_1.signatureToString)(signature);
            signatures.push(result);
        }
        return signatures;
    }
}
exports.TxBuilder = TxBuilder;
//# sourceMappingURL=txBuilder.js.map