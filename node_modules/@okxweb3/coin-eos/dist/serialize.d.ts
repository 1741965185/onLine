import { Abi, Authorization, BlockTaposInfo, SerializedAction, TransactionHeader } from './types';
export declare class SerialBuffer {
    length: number;
    array: Uint8Array;
    readPos: number;
    constructor(array?: Uint8Array);
    reserve(size: number): void;
    haveReadData(): boolean;
    restartRead(): void;
    asUint8Array(): Uint8Array;
    pushArray(v: number[] | Uint8Array): void;
    push(...v: number[]): void;
    get(): number;
    pushUint8ArrayChecked(v: Uint8Array, len: number): void;
    getUint8Array(len: number): Uint8Array;
    skip(len: number): void;
    pushUint16(v: number): void;
    getUint16(): number;
    pushUint32(v: number): void;
    getUint32(): number;
    pushNumberAsUint64(v: number): void;
    getUint64AsNumber(): number;
    pushVaruint32(v: number): void;
    getVaruint32(): number;
    pushVarint32(v: number): void;
    getVarint32(): number;
    pushFloat32(v: number): void;
    getFloat32(): number;
    pushFloat64(v: number): void;
    getFloat64(): number;
    pushName(s: string): void;
    getName(): string;
    pushBytes(v: number[] | Uint8Array): void;
    getBytes(): Uint8Array;
    pushString(v: string): void;
    getString(): string;
    pushSymbolCode(name: string): void;
    getSymbolCode(): string;
    pushSymbol({ name, precision, }: {
        name: string;
        precision: number;
    }): void;
    getSymbol(): {
        name: string;
        precision: number;
    };
    pushAsset(s: string): void;
    getAsset(): string;
    pushPublicKey(s: string): void;
    getPublicKey(): string;
    pushPrivateKey(s: string): void;
    getPrivateKey(): string;
    pushSignature(s: string): void;
    getSignature(): string;
}
export interface SerializerOptions {
    bytesAsUint8Array?: boolean;
}
export declare class SerializerState {
    options: SerializerOptions;
    skippedBinaryExtension: boolean;
    constructor(options?: SerializerOptions);
}
export interface Field {
    name: string;
    typeName: string;
    type?: Type;
}
export interface Type {
    name: string;
    aliasOfName: string;
    arrayOf?: Type;
    optionalOf?: Type;
    extensionOf?: Type;
    baseName: string;
    base?: Type;
    fields: Field[];
    serialize: (buffer: SerialBuffer, data: any, state?: SerializerState, allowExtensions?: boolean) => void;
    deserialize: (buffer: SerialBuffer, state?: SerializerState, allowExtensions?: boolean) => any;
}
export declare const getType: (types: Map<string, Type>, name: string) => Type;
export declare const getTypesFromAbi: (initialTypes: Map<string, Type>, abi?: Abi) => Map<string, Type>;
export interface Contract {
    actions: Map<string, Type>;
    types: Map<string, Type>;
}
export declare const arrayToHex: (data: Uint8Array) => string;
export declare const hexToUint8Array: (hex: string) => Uint8Array;
export declare const dateToTimePoint: (date: string) => number;
export declare const timePointToDate: (us: number) => string;
export declare const dateToTimePointSec: (date: string) => number;
export declare const timePointSecToDate: (sec: number) => string;
export declare const dateToBlockTimestamp: (date: string) => number;
export declare const blockTimestampToDate: (slot: number) => string;
export declare const stringToSymbol: (s: string) => {
    name: string;
    precision: number;
};
export declare const symbolToString: ({ name, precision, }: {
    name: string;
    precision: number;
}) => string;
export declare const createInitialTypes: () => Map<string, Type>;
export declare const createAbiTypes: () => Map<string, Type>;
export declare const createTransactionTypes: () => Map<string, Type>;
export declare const createTransactionExtensionTypes: () => Map<string, Type>;
export declare const transactionHeader: (refBlock: BlockTaposInfo, expireSeconds: number) => TransactionHeader;
export declare const supportedAbiVersion: (version: string) => boolean;
export declare const serializeAction: (contract: Contract, account: string, name: string, authorization: Authorization[], data: any) => SerializedAction;
export declare const serializeActionData: (contract: Contract, account: string, name: string, data: any) => string;
