"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WaxWallet = exports.EosWallet = void 0;
const coin_base_1 = require("@okxweb3/coin-base");
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const index_1 = require("./index");
class EosWallet extends coin_base_1.BaseWallet {
    getAmountString(amount, precision, symbol) {
        precision = precision == null || undefined ? 4 : precision;
        symbol = symbol == null || undefined ? 'EOS' : symbol;
        return (0, index_1.toAssetString)(Number(amount), precision, symbol);
    }
    getTokenAmountString(amount, precision, symbol) {
        return (0, index_1.toAssetString)(Number(amount), precision, symbol);
    }
    async getRandomPrivateKey() {
        return Promise.resolve((0, index_1.privateKeyToLegacyString)({
            type: index_1.KeyType.k1,
            data: crypto_lib_1.base.fromHex(await super.getRandomPrivateKey()),
        }));
    }
    async getDerivedPrivateKey(param) {
        return Promise.resolve((0, index_1.privateKeyToLegacyString)({
            type: index_1.KeyType.k1,
            data: crypto_lib_1.base.fromHex(await super.getDerivedPrivateKey(param)),
        }));
    }
    async getDerivedPath(param) {
        return `m/44'/194'/0'/0/${param.index}`;
    }
    async getNewAddress(param) {
        try {
            const privateKey = (0, index_1.stringToPrivateKey)(param.privateKey);
            (0, coin_base_1.assertBufferLength)(privateKey.data, index_1.privateKeyDataSize);
            const publicKey = crypto_lib_1.signUtil.secp256k1.publicKeyCreate(privateKey.data, true);
            return Promise.resolve({
                address: "",
                publicKey: (0, index_1.publicKeyToLegacyString)({
                    type: index_1.KeyType.k1,
                    data: publicKey,
                }),
            });
        }
        catch (e) {
        }
        return Promise.reject(coin_base_1.NewAddressError);
    }
    async validPrivateKey(param) {
        let isValid;
        try {
            const privateKey = (0, index_1.stringToPrivateKey)(param.privateKey);
            isValid = privateKey.data.length == index_1.privateKeyDataSize;
        }
        catch (e) {
            isValid = false;
        }
        const data = {
            isValid: isValid,
            privateKey: param.privateKey
        };
        return Promise.resolve(data);
    }
    validAddress(param) {
        throw new Error('Method not implemented.');
    }
    async signTransaction(param) {
        try {
            const type = param.data.type;
            if (type === 1) {
                const createAccountParam = {
                    creator: param.data.creator,
                    newAccount: param.data.newAccount,
                    pubKey: param.data.pubKey,
                    buyRam: {
                        ...param.data.buyRam,
                        quantity: this.getAmountString(param.data.buyRam.quantity),
                    },
                    delegate: {
                        ...param.data.delegate,
                        stakeNet: this.getAmountString(param.data.delegate.stakeNet),
                        stakeCPU: this.getAmountString(param.data.delegate.stakeCPU),
                    },
                    common: {
                        ...param.data.common,
                        privateKey: [param.privateKey],
                    },
                };
                return Promise.resolve((0, index_1.createAccount)(createAccountParam));
            }
            else if (type === 2) {
                let privateKeys = [];
                if (param.data.requiredKeys) {
                    for (let i = 0; i < param.data.requiredKeys.length; i++) {
                        privateKeys.push(param.privateKey);
                    }
                }
                if (privateKeys.length == 0) {
                    privateKeys.push(param.privateKey);
                }
                const signatures = (0, index_1.signSerializedTransaction)(param.data.chainId, privateKeys, param.data.serializedTransaction);
                return Promise.resolve({
                    signatures: signatures,
                    serializedTransaction: param.data.serializedTransaction
                });
            }
            else {
                const transferParam = {
                    from: param.data.from,
                    to: param.data.to,
                    amount: this.getAmountString(param.data.amount, param.data.precision, param.data.symbol),
                    memo: param.data.memo,
                    contract: param.data.contract,
                    common: {
                        ...param.data.common,
                        privateKey: [param.privateKey],
                    },
                };
                return Promise.resolve((0, index_1.transfer)(transferParam));
            }
        }
        catch (e) {
            return Promise.reject(coin_base_1.SignTxError);
        }
    }
    calcTxHash(param) {
        try {
            const tx = typeof param.data === "string" ? JSON.parse(param.data) : param.data;
            return Promise.resolve((0, index_1.getTxId)(tx));
        }
        catch (e) {
            return Promise.reject(coin_base_1.CalcTxHashError);
        }
    }
}
exports.EosWallet = EosWallet;
class WaxWallet extends EosWallet {
    getAmountString(amount, precision, symbol) {
        precision = precision == null || undefined ? 8 : precision;
        symbol = symbol == null || undefined ? 'WAX' : symbol;
        return (0, index_1.toAssetString)(Number(amount), precision, symbol);
    }
    async getDerivedPath(param) {
        return `m/44'/14001'/0'/0/${param.index}`;
    }
}
exports.WaxWallet = WaxWallet;
//# sourceMappingURL=EosWallet.js.map