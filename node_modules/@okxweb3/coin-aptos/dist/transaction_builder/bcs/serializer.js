"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Serializer = void 0;
const consts_1 = require("./consts");
class Serializer {
    constructor() {
        this.buffer = new ArrayBuffer(64);
        this.offset = 0;
    }
    ensureBufferWillHandleSize(bytes) {
        while (this.buffer.byteLength < this.offset + bytes) {
            const newBuffer = new ArrayBuffer(this.buffer.byteLength * 2);
            new Uint8Array(newBuffer).set(new Uint8Array(this.buffer));
            this.buffer = newBuffer;
        }
    }
    serialize(values) {
        this.ensureBufferWillHandleSize(values.length);
        new Uint8Array(this.buffer, this.offset).set(values);
        this.offset += values.length;
    }
    serializeWithFunction(fn, bytesLength, value) {
        this.ensureBufferWillHandleSize(bytesLength);
        const dv = new DataView(this.buffer, this.offset);
        fn.apply(dv, [0, value, true]);
        this.offset += bytesLength;
    }
    serializeStr(value) {
        const textEncoder = new TextEncoder();
        this.serializeBytes(textEncoder.encode(value));
    }
    serializeBytes(value) {
        this.serializeU32AsUleb128(value.length);
        this.serialize(value);
    }
    serializeFixedBytes(value) {
        this.serialize(value);
    }
    serializeBool(value) {
        if (typeof value !== "boolean") {
            throw new Error("Value needs to be a boolean");
        }
        const byteValue = value ? 1 : 0;
        this.serialize(new Uint8Array([byteValue]));
    }
    serializeU8(value) {
        this.serialize(new Uint8Array([value]));
    }
    serializeU16(value) {
        this.serializeWithFunction(DataView.prototype.setUint16, 2, value);
    }
    serializeU32(value) {
        this.serializeWithFunction(DataView.prototype.setUint32, 4, value);
    }
    serializeU64(value) {
        const low = BigInt(value.toString()) & BigInt(consts_1.MAX_U32_NUMBER);
        const high = BigInt(value.toString()) >> BigInt(32);
        this.serializeU32(Number(low));
        this.serializeU32(Number(high));
    }
    serializeU128(value) {
        const low = BigInt(value.toString()) & consts_1.MAX_U64_BIG_INT;
        const high = BigInt(value.toString()) >> BigInt(64);
        this.serializeU64(low);
        this.serializeU64(high);
    }
    serializeU256(value) {
        const low = BigInt(value.toString()) & consts_1.MAX_U128_BIG_INT;
        const high = BigInt(value.toString()) >> BigInt(128);
        this.serializeU128(low);
        this.serializeU128(high);
    }
    serializeU32AsUleb128(val) {
        let value = val;
        const valueArray = [];
        while (value >>> 7 !== 0) {
            valueArray.push((value & 0x7f) | 0x80);
            value >>>= 7;
        }
        valueArray.push(value);
        this.serialize(new Uint8Array(valueArray));
    }
    getBytes() {
        return new Uint8Array(this.buffer).slice(0, this.offset);
    }
}
__decorate([
    checkNumberRange(0, consts_1.MAX_U8_NUMBER)
], Serializer.prototype, "serializeU8", null);
__decorate([
    checkNumberRange(0, consts_1.MAX_U16_NUMBER)
], Serializer.prototype, "serializeU16", null);
__decorate([
    checkNumberRange(0, consts_1.MAX_U32_NUMBER)
], Serializer.prototype, "serializeU32", null);
__decorate([
    checkNumberRange(BigInt(0), consts_1.MAX_U64_BIG_INT)
], Serializer.prototype, "serializeU64", null);
__decorate([
    checkNumberRange(BigInt(0), consts_1.MAX_U128_BIG_INT)
], Serializer.prototype, "serializeU128", null);
__decorate([
    checkNumberRange(BigInt(0), consts_1.MAX_U256_BIG_INT)
], Serializer.prototype, "serializeU256", null);
__decorate([
    checkNumberRange(0, consts_1.MAX_U32_NUMBER)
], Serializer.prototype, "serializeU32AsUleb128", null);
exports.Serializer = Serializer;
function checkNumberRange(minValue, maxValue, message) {
    return (target, propertyKey, descriptor) => {
        const childFunction = descriptor.value;
        descriptor.value = function deco(value) {
            const valueBigInt = BigInt(value.toString());
            if (valueBigInt > BigInt(maxValue.toString()) || valueBigInt < BigInt(minValue.toString())) {
                throw new Error(message || "Value is out of range");
            }
            childFunction.apply(this, [value]);
        };
        return descriptor;
    };
}
//# sourceMappingURL=serializer.js.map