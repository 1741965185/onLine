"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Deserializer = void 0;
const consts_1 = require("./consts");
class Deserializer {
    constructor(data) {
        this.buffer = new ArrayBuffer(data.length);
        new Uint8Array(this.buffer).set(data, 0);
        this.offset = 0;
    }
    read(length) {
        if (this.offset + length > this.buffer.byteLength) {
            throw new Error("Reached to the end of buffer");
        }
        const bytes = this.buffer.slice(this.offset, this.offset + length);
        this.offset += length;
        return bytes;
    }
    deserializeStr() {
        const value = this.deserializeBytes();
        const textDecoder = new TextDecoder();
        return textDecoder.decode(value);
    }
    deserializeBytes() {
        const len = this.deserializeUleb128AsU32();
        return new Uint8Array(this.read(len));
    }
    deserializeFixedBytes(len) {
        return new Uint8Array(this.read(len));
    }
    deserializeBool() {
        const bool = new Uint8Array(this.read(1))[0];
        if (bool !== 1 && bool !== 0) {
            throw new Error("Invalid boolean value");
        }
        return bool === 1;
    }
    deserializeU8() {
        return new DataView(this.read(1)).getUint8(0);
    }
    deserializeU16() {
        return new DataView(this.read(2)).getUint16(0, true);
    }
    deserializeU32() {
        return new DataView(this.read(4)).getUint32(0, true);
    }
    deserializeU64() {
        const low = this.deserializeU32();
        const high = this.deserializeU32();
        return BigInt((BigInt(high) << BigInt(32)) | BigInt(low));
    }
    deserializeU128() {
        const low = this.deserializeU64();
        const high = this.deserializeU64();
        return BigInt((high << BigInt(64)) | low);
    }
    deserializeU256() {
        const low = this.deserializeU128();
        const high = this.deserializeU128();
        return BigInt((high << BigInt(128)) | low);
    }
    deserializeUleb128AsU32() {
        let value = BigInt(0);
        let shift = 0;
        while (value < consts_1.MAX_U32_NUMBER) {
            const byte = this.deserializeU8();
            value |= BigInt(byte & 0x7f) << BigInt(shift);
            if ((byte & 0x80) === 0) {
                break;
            }
            shift += 7;
        }
        if (value > consts_1.MAX_U32_NUMBER) {
            throw new Error("Overflow while parsing uleb128-encoded uint32 value");
        }
        return Number(value);
    }
}
exports.Deserializer = Deserializer;
//# sourceMappingURL=deserializer.js.map