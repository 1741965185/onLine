"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildRawTransactionByABI = exports.fetchABI = exports.TransactionBuilderABI = exports.TransactionBuilderMultiEd25519 = exports.TransactionBuilderEd25519 = exports.TransactionBuilder = void 0;
const sha3_1 = require("@noble/hashes/sha3");
const aptos_types_1 = require("./aptos_types");
const bcs_1 = require("./bcs");
const hex_string_1 = require("../hex_string");
const abi_1 = require("./aptos_types/abi");
const builder_utils_1 = require("./builder_utils");
const aptos_types_2 = require("./aptos_types");
const utils_1 = require("../utils");
const RAW_TRANSACTION_SALT = "APTOS::RawTransaction";
const RAW_TRANSACTION_WITH_DATA_SALT = "APTOS::RawTransactionWithData";
class TransactionBuilder {
    constructor(signingFunction, rawTxnBuilder) {
        this.rawTxnBuilder = rawTxnBuilder;
        this.signingFunction = signingFunction;
    }
    build(func, ty_tags, args) {
        if (!this.rawTxnBuilder) {
            throw new Error("this.rawTxnBuilder doesn't exist.");
        }
        return this.rawTxnBuilder.build(func, ty_tags, args);
    }
    static getSigningMessage(rawTxn) {
        const hash = sha3_1.sha3_256.create();
        if (rawTxn instanceof aptos_types_1.RawTransaction) {
            hash.update(RAW_TRANSACTION_SALT);
        }
        else if (rawTxn instanceof aptos_types_1.MultiAgentRawTransaction) {
            hash.update(RAW_TRANSACTION_WITH_DATA_SALT);
        }
        else {
            throw new Error("Unknown transaction type.");
        }
        const prefix = hash.digest();
        const body = (0, bcs_1.bcsToBytes)(rawTxn);
        const mergedArray = new Uint8Array(prefix.length + body.length);
        mergedArray.set(prefix);
        mergedArray.set(body, prefix.length);
        return mergedArray;
    }
}
exports.TransactionBuilder = TransactionBuilder;
class TransactionBuilderEd25519 extends TransactionBuilder {
    constructor(signingFunction, publicKey, rawTxnBuilder) {
        super(signingFunction, rawTxnBuilder);
        this.publicKey = publicKey;
    }
    rawToSigned(rawTxn) {
        const signingMessage = TransactionBuilder.getSigningMessage(rawTxn);
        const signature = this.signingFunction(signingMessage);
        const authenticator = new aptos_types_1.TransactionAuthenticatorEd25519(new aptos_types_1.Ed25519PublicKey(this.publicKey), signature);
        return new aptos_types_1.SignedTransaction(rawTxn, authenticator);
    }
    sign(rawTxn) {
        return (0, bcs_1.bcsToBytes)(this.rawToSigned(rawTxn));
    }
}
exports.TransactionBuilderEd25519 = TransactionBuilderEd25519;
class TransactionBuilderMultiEd25519 extends TransactionBuilder {
    constructor(signingFunction, publicKey) {
        super(signingFunction);
        this.publicKey = publicKey;
    }
    rawToSigned(rawTxn) {
        const signingMessage = TransactionBuilder.getSigningMessage(rawTxn);
        const signature = this.signingFunction(signingMessage);
        const authenticator = new aptos_types_1.TransactionAuthenticatorMultiEd25519(this.publicKey, signature);
        return new aptos_types_1.SignedTransaction(rawTxn, authenticator);
    }
    sign(rawTxn) {
        return (0, bcs_1.bcsToBytes)(this.rawToSigned(rawTxn));
    }
}
exports.TransactionBuilderMultiEd25519 = TransactionBuilderMultiEd25519;
class TransactionBuilderABI {
    constructor(abis, builderConfig) {
        this.abiMap = new Map();
        abis.forEach((abi) => {
            const deserializer = new bcs_1.Deserializer(abi);
            const scriptABI = abi_1.ScriptABI.deserialize(deserializer);
            let k;
            if (scriptABI instanceof abi_1.EntryFunctionABI) {
                const funcABI = scriptABI;
                const { address: addr, name: moduleName } = funcABI.module_name;
                k = `${hex_string_1.HexString.fromUint8Array(addr.address).toShortString()}::${moduleName.value}::${funcABI.name}`;
            }
            else {
                const funcABI = scriptABI;
                k = funcABI.name;
            }
            if (this.abiMap.has(k)) {
                throw new Error("Found conflicting ABI interfaces");
            }
            this.abiMap.set(k, scriptABI);
        });
        this.builderConfig = {
            maxGasAmount: BigInt(utils_1.DEFAULT_MAX_GAS_AMOUNT),
            expSecFromNow: utils_1.DEFAULT_TXN_EXP_SEC_FROM_NOW,
            ...builderConfig,
        };
    }
    static toBCSArgs(abiArgs, args) {
        if (abiArgs.length !== args.length) {
            throw new Error("Wrong number of args provided.");
        }
        return args.map((arg, i) => {
            const serializer = new bcs_1.Serializer();
            (0, builder_utils_1.serializeArg)(arg, abiArgs[i].type_tag, serializer);
            return serializer.getBytes();
        });
    }
    static toTransactionArguments(abiArgs, args) {
        if (abiArgs.length !== args.length) {
            throw new Error("Wrong number of args provided.");
        }
        return args.map((arg, i) => (0, builder_utils_1.argToTransactionArgument)(arg, abiArgs[i].type_tag));
    }
    setSequenceNumber(seqNumber) {
        this.builderConfig.sequenceNumber = BigInt(seqNumber);
    }
    buildTransactionPayload(func, ty_tags, args) {
        const typeTags = ty_tags.map((ty_arg) => new aptos_types_2.TypeTagParser(ty_arg).parseTypeTag());
        let payload;
        if (!this.abiMap.has(func)) {
            throw new Error(`Cannot find function: ${func}`);
        }
        const scriptABI = this.abiMap.get(func);
        if (scriptABI instanceof abi_1.EntryFunctionABI) {
            const funcABI = scriptABI;
            const bcsArgs = TransactionBuilderABI.toBCSArgs(funcABI.args, args);
            payload = new aptos_types_1.TransactionPayloadEntryFunction(new aptos_types_1.EntryFunction(funcABI.module_name, new aptos_types_1.Identifier(funcABI.name), typeTags, bcsArgs));
        }
        else if (scriptABI instanceof abi_1.TransactionScriptABI) {
            const funcABI = scriptABI;
            const scriptArgs = TransactionBuilderABI.toTransactionArguments(funcABI.args, args);
            payload = new aptos_types_1.TransactionPayloadScript(new aptos_types_1.Script(funcABI.code, typeTags, scriptArgs));
        }
        else {
            throw new Error("Unknown ABI format.");
        }
        return payload;
    }
    build(func, ty_tags, args) {
        const { sender, sequenceNumber, gasUnitPrice, maxGasAmount, expSecFromNow, chainId } = this.builderConfig;
        if (!gasUnitPrice) {
            throw new Error("No gasUnitPrice provided.");
        }
        const senderAccount = sender instanceof aptos_types_1.AccountAddress ? sender : aptos_types_1.AccountAddress.fromHex(sender);
        const expTimestampSec = BigInt(Math.floor(Date.now() / 1000) + Number(expSecFromNow));
        const payload = this.buildTransactionPayload(func, ty_tags, args);
        if (payload) {
            return new aptos_types_1.RawTransaction(senderAccount, BigInt(sequenceNumber), payload, BigInt(maxGasAmount), BigInt(gasUnitPrice), expTimestampSec, new aptos_types_1.ChainId(Number(chainId)));
        }
        throw new Error("Invalid ABI.");
    }
}
exports.TransactionBuilderABI = TransactionBuilderABI;
function fetchABI(modules) {
    const abis = modules
        .map((module) => module.abi)
        .flatMap((abi) => abi.exposed_functions
        .filter((ef) => ef.is_entry)
        .map((ef) => ({
        fullName: `${abi.address}::${abi.name}::${ef.name}`,
        ...ef,
    })));
    const abiMap = new Map();
    abis.forEach((abi) => {
        abiMap.set(abi.fullName, abi);
    });
    return abiMap;
}
exports.fetchABI = fetchABI;
function buildRawTransactionByABI(modules, builderConfig, func, ty_tags, args) {
    const normlize = (s) => s.replace(/^0[xX]0*/g, "0x");
    func = normlize(func);
    const funcNameParts = func.split("::");
    if (funcNameParts.length !== 3) {
        throw new Error("'func' needs to be a fully qualified function name in format <address>::<module>::<function>, e.g. 0x1::coin::transfer");
    }
    const [addr, module] = func.split('::');
    const abiMap = fetchABI(modules);
    if (!abiMap.has(func)) {
        throw new Error(`${func} doesn't exist.`);
    }
    const funcAbi = abiMap.get(func);
    if (!funcAbi) {
        throw Error('abi miss');
    }
    const abiArgs = funcAbi.params.filter((param) => param !== "signer" && param !== "&signer");
    const typeArgABIs = abiArgs.map((abiArg, i) => new abi_1.ArgumentABI(`var${i}`, new aptos_types_2.TypeTagParser(abiArg, ty_tags).parseTypeTag()));
    const entryFunctionABI = new abi_1.EntryFunctionABI(funcAbi.name, aptos_types_1.ModuleId.fromStr(`${addr}::${module}`), "", funcAbi.generic_type_params.map((_, i) => new abi_1.TypeArgumentABI(`${i}`)), typeArgABIs);
    const builderABI = new TransactionBuilderABI([(0, bcs_1.bcsToBytes)(entryFunctionABI)], builderConfig);
    return builderABI.build(func, ty_tags, args);
}
exports.buildRawTransactionByABI = buildRawTransactionByABI;
//# sourceMappingURL=builder.js.map