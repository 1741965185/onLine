"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiEd25519Signature = exports.MultiEd25519PublicKey = void 0;
const ed25519_1 = require("./ed25519");
const MAX_SIGNATURES_SUPPORTED = 32;
class MultiEd25519PublicKey {
    constructor(public_keys, threshold) {
        this.public_keys = public_keys;
        this.threshold = threshold;
        if (threshold > MAX_SIGNATURES_SUPPORTED) {
            throw new Error(`"threshold" cannot be larger than ${MAX_SIGNATURES_SUPPORTED}`);
        }
    }
    toBytes() {
        const bytes = new Uint8Array(this.public_keys.length * ed25519_1.Ed25519PublicKey.LENGTH + 1);
        this.public_keys.forEach((k, i) => {
            bytes.set(k.value, i * ed25519_1.Ed25519PublicKey.LENGTH);
        });
        bytes[this.public_keys.length * ed25519_1.Ed25519PublicKey.LENGTH] = this.threshold;
        return bytes;
    }
    serialize(serializer) {
        serializer.serializeBytes(this.toBytes());
    }
    static deserialize(deserializer) {
        const bytes = deserializer.deserializeBytes();
        const threshold = bytes[bytes.length - 1];
        const keys = [];
        for (let i = 0; i < bytes.length - 1; i += ed25519_1.Ed25519PublicKey.LENGTH) {
            const begin = i;
            keys.push(new ed25519_1.Ed25519PublicKey(bytes.subarray(begin, begin + ed25519_1.Ed25519PublicKey.LENGTH)));
        }
        return new MultiEd25519PublicKey(keys, threshold);
    }
}
exports.MultiEd25519PublicKey = MultiEd25519PublicKey;
class MultiEd25519Signature {
    constructor(signatures, bitmap) {
        this.signatures = signatures;
        this.bitmap = bitmap;
        if (bitmap.length !== MultiEd25519Signature.BITMAP_LEN) {
            throw new Error(`"bitmap" length should be ${MultiEd25519Signature.BITMAP_LEN}`);
        }
    }
    toBytes() {
        const bytes = new Uint8Array(this.signatures.length * ed25519_1.Ed25519Signature.LENGTH + MultiEd25519Signature.BITMAP_LEN);
        this.signatures.forEach((k, i) => {
            bytes.set(k.value, i * ed25519_1.Ed25519Signature.LENGTH);
        });
        bytes.set(this.bitmap, this.signatures.length * ed25519_1.Ed25519Signature.LENGTH);
        return bytes;
    }
    static createBitmap(bits) {
        const firstBitInByte = 128;
        const bitmap = new Uint8Array([0, 0, 0, 0]);
        const dupCheckSet = new Set();
        bits.forEach((bit) => {
            if (bit >= MAX_SIGNATURES_SUPPORTED) {
                throw new Error(`Invalid bit value ${bit}.`);
            }
            if (dupCheckSet.has(bit)) {
                throw new Error("Duplicated bits detected.");
            }
            dupCheckSet.add(bit);
            const byteOffset = Math.floor(bit / 8);
            let byte = bitmap[byteOffset];
            byte |= firstBitInByte >> bit % 8;
            bitmap[byteOffset] = byte;
        });
        return bitmap;
    }
    serialize(serializer) {
        serializer.serializeBytes(this.toBytes());
    }
    static deserialize(deserializer) {
        const bytes = deserializer.deserializeBytes();
        const bitmap = bytes.subarray(bytes.length - 4);
        const sigs = [];
        for (let i = 0; i < bytes.length - bitmap.length; i += ed25519_1.Ed25519Signature.LENGTH) {
            const begin = i;
            sigs.push(new ed25519_1.Ed25519Signature(bytes.subarray(begin, begin + ed25519_1.Ed25519Signature.LENGTH)));
        }
        return new MultiEd25519Signature(sigs, bitmap);
    }
}
exports.MultiEd25519Signature = MultiEd25519Signature;
MultiEd25519Signature.BITMAP_LEN = 4;
//# sourceMappingURL=multi_ed25519.js.map