"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validSignedTransaction = exports.signMessage = exports.createRawTransactionByABI = exports.generateBCSSimulateTransaction = exports.generateBCSTransaction = exports.claimNFTTokenPayload = exports.offerNFTTokenPayloadObject = exports.offerNFTTokenPayload = exports.createNFTTokenPayload = exports.createNFTCollectionPayload = exports.transferCoin = exports.burnCoin = exports.mintCoin = exports.registerCoin = exports.transferPayload = exports.simulateTransaction = exports.createRawTransaction = exports.transfer = void 0;
const hex_string_1 = require("./hex_string");
const aptos_account_1 = require("./aptos_account");
const transaction_builder_1 = require("./transaction_builder");
const aptos_types_1 = require("./transaction_builder/aptos_types");
const bcs_1 = require("./transaction_builder/bcs");
const crypto_lib_1 = require("@okxweb3/crypto-lib");
function transfer(account, recipientAddress, amount, sequenceNumber, chainId, maxGasAmount, gasUnitPrice, expirationTimestampSecs) {
    const payload = transferPayload(recipientAddress, amount);
    const rawTxn = createRawTransaction(account.address(), payload, sequenceNumber, chainId, maxGasAmount, gasUnitPrice, expirationTimestampSecs);
    return generateBCSTransaction(account, rawTxn);
}
exports.transfer = transfer;
function createRawTransaction(sender, payload, sequenceNumber, chainId, maxGasAmount, gasUnitPrice, expirationTimestampSecs) {
    return new transaction_builder_1.TxnBuilderTypes.RawTransaction(transaction_builder_1.TxnBuilderTypes.AccountAddress.fromHex(sender), sequenceNumber, payload, maxGasAmount, gasUnitPrice, expirationTimestampSecs, new transaction_builder_1.TxnBuilderTypes.ChainId(chainId));
}
exports.createRawTransaction = createRawTransaction;
function simulateTransaction(account, payload, sequenceNumber, chainId, maxGasAmount, gasUnitPrice, expirationTimestampSecs) {
    const rawTransaction = createRawTransaction(account.address(), payload, sequenceNumber, chainId, maxGasAmount, gasUnitPrice, expirationTimestampSecs);
    return generateBCSSimulateTransaction(account, rawTransaction);
}
exports.simulateTransaction = simulateTransaction;
function transferPayload(recipientAddress, amount) {
    return new transaction_builder_1.TxnBuilderTypes.TransactionPayloadEntryFunction(transaction_builder_1.TxnBuilderTypes.EntryFunction.natural('0x1::aptos_account', 'transfer', [], [transaction_builder_1.BCS.bcsToBytes(transaction_builder_1.TxnBuilderTypes.AccountAddress.fromHex(recipientAddress)), transaction_builder_1.BCS.bcsSerializeUint64(amount),
    ]));
}
exports.transferPayload = transferPayload;
function registerCoin(tyArg) {
    const token = new transaction_builder_1.TxnBuilderTypes.TypeTagStruct(transaction_builder_1.TxnBuilderTypes.StructTag.fromString(tyArg));
    return new transaction_builder_1.TxnBuilderTypes.TransactionPayloadEntryFunction(transaction_builder_1.TxnBuilderTypes.EntryFunction.natural("0x1::managed_coin", "register", [token], []));
}
exports.registerCoin = registerCoin;
function mintCoin(tyArg, receiverAddress, amount) {
    const token = new transaction_builder_1.TxnBuilderTypes.TypeTagStruct(transaction_builder_1.TxnBuilderTypes.StructTag.fromString(tyArg));
    return new transaction_builder_1.TxnBuilderTypes.TransactionPayloadEntryFunction(transaction_builder_1.TxnBuilderTypes.EntryFunction.natural("0x1::managed_coin", "mint", [token], [transaction_builder_1.BCS.bcsToBytes(transaction_builder_1.TxnBuilderTypes.AccountAddress.fromHex(receiverAddress)), transaction_builder_1.BCS.bcsSerializeUint64(amount)]));
}
exports.mintCoin = mintCoin;
function burnCoin(tyArg, amount) {
    const token = new transaction_builder_1.TxnBuilderTypes.TypeTagStruct(transaction_builder_1.TxnBuilderTypes.StructTag.fromString(tyArg));
    return new transaction_builder_1.TxnBuilderTypes.TransactionPayloadEntryFunction(transaction_builder_1.TxnBuilderTypes.EntryFunction.natural("0x1::managed_coin", "burn", [token], [transaction_builder_1.BCS.bcsSerializeUint64(amount)]));
}
exports.burnCoin = burnCoin;
function transferCoin(tyArg, receiverAddress, amount) {
    const token = new transaction_builder_1.TxnBuilderTypes.TypeTagStruct(transaction_builder_1.TxnBuilderTypes.StructTag.fromString(tyArg));
    return new transaction_builder_1.TxnBuilderTypes.TransactionPayloadEntryFunction(transaction_builder_1.TxnBuilderTypes.EntryFunction.natural("0x1::coin", "transfer", [token], [transaction_builder_1.BCS.bcsToBytes(transaction_builder_1.TxnBuilderTypes.AccountAddress.fromHex(receiverAddress)), transaction_builder_1.BCS.bcsSerializeUint64(amount)]));
}
exports.transferCoin = transferCoin;
function serializeVectorBool(vecBool) {
    const serializer = new transaction_builder_1.BCS.Serializer();
    serializer.serializeU32AsUleb128(vecBool.length);
    vecBool.forEach((el) => {
        serializer.serializeBool(el);
    });
    return serializer.getBytes();
}
function createNFTCollectionPayload(name, description, uri) {
    const NUMBER_MAX = 9007199254740991;
    return new transaction_builder_1.TxnBuilderTypes.TransactionPayloadEntryFunction(transaction_builder_1.TxnBuilderTypes.EntryFunction.natural("0x3::token", "create_collection_script", [], [
        transaction_builder_1.BCS.bcsSerializeStr(name),
        transaction_builder_1.BCS.bcsSerializeStr(description),
        transaction_builder_1.BCS.bcsSerializeStr(uri),
        transaction_builder_1.BCS.bcsSerializeUint64(NUMBER_MAX),
        serializeVectorBool([false, false, false]),
    ]));
}
exports.createNFTCollectionPayload = createNFTCollectionPayload;
function createNFTTokenPayload(account, collection_name, name, description, supply, uri) {
    const NUMBER_MAX = 9007199254740991;
    const serializer = new transaction_builder_1.BCS.Serializer();
    serializer.serializeU32AsUleb128(0);
    return new transaction_builder_1.TxnBuilderTypes.TransactionPayloadEntryFunction(transaction_builder_1.TxnBuilderTypes.EntryFunction.natural("0x3::token", "create_token_script", [], [
        transaction_builder_1.BCS.bcsSerializeStr(collection_name),
        transaction_builder_1.BCS.bcsSerializeStr(name),
        transaction_builder_1.BCS.bcsSerializeStr(description),
        transaction_builder_1.BCS.bcsSerializeUint64(supply),
        transaction_builder_1.BCS.bcsSerializeUint64(NUMBER_MAX),
        transaction_builder_1.BCS.bcsSerializeStr(uri),
        transaction_builder_1.BCS.bcsToBytes(transaction_builder_1.TxnBuilderTypes.AccountAddress.fromHex(account.address())),
        transaction_builder_1.BCS.bcsSerializeUint64(0),
        transaction_builder_1.BCS.bcsSerializeUint64(0),
        serializeVectorBool([false, false, false, false, false]),
        serializer.getBytes(),
        serializer.getBytes(),
        serializer.getBytes(),
    ]));
}
exports.createNFTTokenPayload = createNFTTokenPayload;
function offerNFTTokenPayload(receiver, creator, collection_name, token_name, version, amount) {
    return new transaction_builder_1.TxnBuilderTypes.TransactionPayloadEntryFunction(transaction_builder_1.TxnBuilderTypes.EntryFunction.natural("0x3::token_transfers", "offer_script", [], [
        transaction_builder_1.BCS.bcsToBytes(transaction_builder_1.TxnBuilderTypes.AccountAddress.fromHex(receiver.hex())),
        transaction_builder_1.BCS.bcsToBytes(transaction_builder_1.TxnBuilderTypes.AccountAddress.fromHex(creator.hex())),
        transaction_builder_1.BCS.bcsSerializeStr(collection_name),
        transaction_builder_1.BCS.bcsSerializeStr(token_name),
        transaction_builder_1.BCS.bcsSerializeUint64(version),
        transaction_builder_1.BCS.bcsSerializeUint64(amount),
    ]));
}
exports.offerNFTTokenPayload = offerNFTTokenPayload;
function offerNFTTokenPayloadObject(nftObject, receiver, amount) {
    return new transaction_builder_1.TxnBuilderTypes.TransactionPayloadEntryFunction(transaction_builder_1.TxnBuilderTypes.EntryFunction.natural("0x1::object", "transfer", [aptos_types_1.StructTag.fromString("0x1::object::ObjectCore")], [
        transaction_builder_1.BCS.bcsToBytes(transaction_builder_1.TxnBuilderTypes.AccountAddress.fromHex(nftObject.hex())),
        transaction_builder_1.BCS.bcsToBytes(transaction_builder_1.TxnBuilderTypes.AccountAddress.fromHex(receiver.hex())),
        transaction_builder_1.BCS.bcsSerializeUint64(amount),
    ]));
}
exports.offerNFTTokenPayloadObject = offerNFTTokenPayloadObject;
function claimNFTTokenPayload(sender, creator, collection_name, token_name, version) {
    return new transaction_builder_1.TxnBuilderTypes.TransactionPayloadEntryFunction(transaction_builder_1.TxnBuilderTypes.EntryFunction.natural("0x3::token_transfers", "claim_script", [], [
        transaction_builder_1.BCS.bcsToBytes(transaction_builder_1.TxnBuilderTypes.AccountAddress.fromHex(sender.hex())),
        transaction_builder_1.BCS.bcsToBytes(transaction_builder_1.TxnBuilderTypes.AccountAddress.fromHex(creator.hex())),
        transaction_builder_1.BCS.bcsSerializeStr(collection_name),
        transaction_builder_1.BCS.bcsSerializeStr(token_name),
        transaction_builder_1.BCS.bcsSerializeUint64(version),
    ]));
}
exports.claimNFTTokenPayload = claimNFTTokenPayload;
function generateBCSTransaction(accountFrom, rawTxn) {
    const txnBuilder = new transaction_builder_1.TransactionBuilderEd25519((signingMessage) => {
        const sigHexStr = accountFrom.signBuffer(Buffer.from(signingMessage));
        return new transaction_builder_1.TxnBuilderTypes.Ed25519Signature(sigHexStr.toUint8Array());
    }, accountFrom.pubKey().toUint8Array());
    return txnBuilder.sign(rawTxn);
}
exports.generateBCSTransaction = generateBCSTransaction;
function generateBCSSimulateTransaction(accountFrom, rawTxn) {
    const txnBuilder = new transaction_builder_1.TransactionBuilderEd25519((signingMessage) => {
        const signature = new Uint8Array(64);
        return new transaction_builder_1.TxnBuilderTypes.Ed25519Signature(signature);
    }, accountFrom.pubKey().toUint8Array());
    return txnBuilder.sign(rawTxn);
}
exports.generateBCSSimulateTransaction = generateBCSSimulateTransaction;
function createRawTransactionByABI(sender, sequenceNumber, chainId, maxGasAmount, gasUnitPrice, expirationTimestampSecs, callData, moduleAbi) {
    const builderConfig = {
        sender: sender,
        sequenceNumber: sequenceNumber,
        gasUnitPrice: gasUnitPrice,
        maxGasAmount: maxGasAmount,
        expSecFromNow: expirationTimestampSecs.toString(),
        chainId: chainId,
    };
    const data = JSON.parse(callData);
    const modules = JSON.parse(moduleAbi);
    return (0, transaction_builder_1.buildRawTransactionByABI)(modules, builderConfig, data.function, data.type_arguments || data.typeArguments, data.arguments || data.functionArguments);
}
exports.createRawTransactionByABI = createRawTransactionByABI;
async function signMessage(message, privateKey) {
    const textEncoder = new TextEncoder();
    const signingMessage = Buffer.from(textEncoder.encode(message));
    const accountFrom = aptos_account_1.AptosAccount.fromPrivateKey(hex_string_1.HexString.ensure(privateKey));
    const sigHexStr = accountFrom.signBuffer(signingMessage);
    return Promise.resolve(sigHexStr.hex());
}
exports.signMessage = signMessage;
function validSignedTransaction(tx, skipCheckSig) {
    const transaction = aptos_types_1.SignedTransaction.deserialize(new bcs_1.Deserializer(crypto_lib_1.base.fromHex(tx)));
    const auth = transaction.authenticator;
    const publicKey = auth.public_key.value;
    const signature = auth.signature.value;
    const hash = transaction_builder_1.TransactionBuilder.getSigningMessage(transaction.raw_txn);
    if (!skipCheckSig && !crypto_lib_1.signUtil.ed25519.verify(hash, signature, publicKey)) {
        throw Error("signature error");
    }
    return transaction;
}
exports.validSignedTransaction = validSignedTransaction;
//# sourceMappingURL=client.js.map