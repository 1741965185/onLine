"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AptosWallet = void 0;
const coin_base_1 = require("@okxweb3/coin-base");
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const index_1 = require("./index");
const client = __importStar(require("./client"));
const v2_1 = require("./v2");
const apiEndpoints_1 = require("./v2/utils/apiEndpoints");
const transactionSubmission_1 = require("./v2/internal/transactionSubmission");
const aptos_types_1 = require("./transaction_builder/aptos_types");
const bcs_1 = require("./transaction_builder/bcs");
class AptosWallet extends coin_base_1.BaseWallet {
    async getDerivedPath(param) {
        return `m/44'/637'/${param.index}'/0'/0'`;
    }
    async getRandomPrivateKey() {
        try {
            return Promise.resolve("0x" + (0, coin_base_1.ed25519_getRandomPrivateKey)(false, "hex"));
        }
        catch (e) {
            return Promise.reject(coin_base_1.GenPrivateKeyError);
        }
    }
    async getDerivedPrivateKey(param) {
        try {
            const key = await (0, coin_base_1.ed25519_getDerivedPrivateKey)(param, false, "hex");
            return Promise.resolve("0x" + key);
        }
        catch (e) {
            return Promise.reject(coin_base_1.GenPrivateKeyError);
        }
    }
    checkPrivateKey(privateKey) {
        if (!crypto_lib_1.base.validateHexString(privateKey)) {
            return false;
        }
        const keyBytes = crypto_lib_1.base.fromHex(privateKey.toLowerCase());
        return keyBytes.length == 32 || keyBytes.length == 64;
    }
    GetTransactionHash(txHex) {
        const bcsBytes = crypto_lib_1.base.fromHex(txHex);
        const prefix = crypto_lib_1.base.sha3_256(Buffer.from("APTOS::Transaction"));
        const message = Buffer.concat([Buffer.from(prefix), Buffer.of(0x0), Buffer.from(bcsBytes)]);
        const txHash = crypto_lib_1.base.sha3_256(message);
        return crypto_lib_1.base.toHex(txHash, true);
    }
    getNewAddress(param) {
        try {
            if (!this.checkPrivateKey(param.privateKey)) {
                return Promise.reject(coin_base_1.NewAddressError);
            }
            const account = index_1.AptosAccount.fromPrivateKey(index_1.HexString.ensure(param.privateKey));
            let address = account.address().hex();
            if (param.addressType && param.addressType === "short") {
                address = account.address().toShortString();
            }
            let data = {
                address: address || "",
                publicKey: account.pubKey().hex()
            };
            return Promise.resolve(data);
        }
        catch (e) {
            return Promise.reject(coin_base_1.NewAddressError);
        }
    }
    validPrivateKey(param) {
        let isValid = this.checkPrivateKey(param.privateKey);
        const data = {
            isValid: isValid,
            privateKey: param.privateKey
        };
        return Promise.resolve(data);
    }
    signTransaction(param) {
        try {
            const account = index_1.AptosAccount.fromPrivateKey(index_1.HexString.ensure(param.privateKey));
            const ap = param.data;
            let sender = account.address();
            if (ap.base.sender) {
                sender = index_1.HexString.ensure(ap.base.sender);
            }
            const privateKey = index_1.HexString.ensure(param.privateKey).toString();
            const ed25519PrivateKey = new v2_1.Ed25519PrivateKey(privateKey.slice(2, 66));
            const senderAccount = v2_1.Account.fromPrivateKey({ privateKey: ed25519PrivateKey });
            const senderAddress = senderAccount.accountAddress;
            const tp = ap.type;
            let tx;
            switch (tp) {
                case "transfer": {
                    const baseParam = ap.base;
                    const data = ap.data;
                    const payload = (0, index_1.transferPayload)(data.recipientAddress, BigInt(data.amount));
                    const rawTxn = (0, index_1.createRawTransaction)(sender, payload, BigInt(baseParam.sequenceNumber), baseParam.chainId, BigInt(baseParam.maxGasAmount), BigInt(baseParam.gasUnitPrice), BigInt(baseParam.expirationTimestampSecs));
                    tx = (0, index_1.generateBCSTransaction)(account, rawTxn);
                    break;
                }
                case "tokenTransfer": {
                    const baseParam = ap.base;
                    const data = ap.data;
                    const payload = (0, index_1.transferCoin)(data.tyArg, data.recipientAddress, BigInt(data.amount));
                    const rawTxn = (0, index_1.createRawTransaction)(sender, payload, BigInt(baseParam.sequenceNumber), baseParam.chainId, BigInt(baseParam.maxGasAmount), BigInt(baseParam.gasUnitPrice), BigInt(baseParam.expirationTimestampSecs));
                    tx = (0, index_1.generateBCSTransaction)(account, rawTxn);
                    break;
                }
                case "tokenMint": {
                    const baseParam = ap.base;
                    const data = ap.data;
                    const payload = (0, index_1.mintCoin)(data.tyArg, data.recipientAddress, BigInt(data.amount));
                    const rawTxn = (0, index_1.createRawTransaction)(sender, payload, BigInt(baseParam.sequenceNumber), baseParam.chainId, BigInt(baseParam.maxGasAmount), BigInt(baseParam.gasUnitPrice), BigInt(baseParam.expirationTimestampSecs));
                    tx = (0, index_1.generateBCSTransaction)(account, rawTxn);
                    break;
                }
                case "tokenBurn": {
                    const baseParam = ap.base;
                    const data = ap.data;
                    const payload = (0, index_1.burnCoin)(data.tyArg, BigInt(data.amount));
                    const rawTxn = (0, index_1.createRawTransaction)(sender, payload, BigInt(baseParam.sequenceNumber), baseParam.chainId, BigInt(baseParam.maxGasAmount), BigInt(baseParam.gasUnitPrice), BigInt(baseParam.expirationTimestampSecs));
                    tx = (0, index_1.generateBCSTransaction)(account, rawTxn);
                    break;
                }
                case "tokenRegister": {
                    const baseParam = ap.base;
                    const data = ap.data;
                    const payload = (0, index_1.registerCoin)(data.tyArg);
                    const rawTxn = (0, index_1.createRawTransaction)(sender, payload, BigInt(baseParam.sequenceNumber), baseParam.chainId, BigInt(baseParam.maxGasAmount), BigInt(baseParam.gasUnitPrice), BigInt(baseParam.expirationTimestampSecs));
                    tx = (0, index_1.generateBCSTransaction)(account, rawTxn);
                    break;
                }
                case "dapp": {
                    const baseParam = ap.base;
                    const data = ap.data;
                    if (data.type == 2) {
                        const deserializer = new bcs_1.Deserializer(crypto_lib_1.base.fromHex(data.data));
                        const payload = aptos_types_1.TransactionPayload.deserialize(deserializer);
                        const rawTxn = (0, index_1.createRawTransaction)(sender, payload, BigInt(baseParam.sequenceNumber), baseParam.chainId, BigInt(baseParam.maxGasAmount), BigInt(baseParam.gasUnitPrice), BigInt(baseParam.expirationTimestampSecs));
                        tx = (0, index_1.generateBCSTransaction)(account, rawTxn);
                    }
                    else {
                        const rawTxn = (0, index_1.createRawTransactionByABI)(sender, BigInt(baseParam.sequenceNumber), baseParam.chainId, BigInt(baseParam.maxGasAmount), BigInt(baseParam.gasUnitPrice), BigInt(baseParam.expirationTimestampSecs), data.data, data.abi);
                        tx = (0, index_1.generateBCSTransaction)(account, rawTxn);
                    }
                    break;
                }
                case "simulate": {
                    const baseParam = ap.base;
                    const data = ap.data;
                    if (data.type == 2) {
                        const deserializer = new bcs_1.Deserializer(crypto_lib_1.base.fromHex(data.data));
                        const payload = aptos_types_1.TransactionPayload.deserialize(deserializer);
                        const rawTxn = (0, index_1.createRawTransaction)(sender, payload, BigInt(baseParam.sequenceNumber), baseParam.chainId, BigInt(baseParam.maxGasAmount), BigInt(baseParam.gasUnitPrice), BigInt(baseParam.expirationTimestampSecs));
                        tx = (0, index_1.generateBCSSimulateTransaction)(account, rawTxn);
                    }
                    else {
                        const rawTxn = (0, index_1.createRawTransactionByABI)(sender, BigInt(baseParam.sequenceNumber), baseParam.chainId, BigInt(baseParam.maxGasAmount), BigInt(baseParam.gasUnitPrice), BigInt(baseParam.expirationTimestampSecs), data.data, data.abi);
                        tx = (0, index_1.generateBCSSimulateTransaction)(account, rawTxn);
                    }
                    break;
                }
                case "offerNftObject": {
                    const baseParam = ap.base;
                    const data = ap.data;
                    const payload = (0, index_1.offerNFTTokenPayloadObject)(index_1.HexString.ensure(data.nftObject), index_1.HexString.ensure(data.receiver), BigInt(data.amount));
                    const rawTxn = (0, index_1.createRawTransaction)(sender, payload, BigInt(baseParam.sequenceNumber), baseParam.chainId, BigInt(baseParam.maxGasAmount), BigInt(baseParam.gasUnitPrice), BigInt(baseParam.expirationTimestampSecs));
                    tx = (0, index_1.generateBCSTransaction)(account, rawTxn);
                    break;
                }
                case "offerNft": {
                    const baseParam = ap.base;
                    const data = ap.data;
                    const payload = (0, index_1.offerNFTTokenPayload)(index_1.HexString.ensure(data.receiver), index_1.HexString.ensure(data.creator), data.collectionName, data.tokenName, BigInt(data.version), BigInt(data.amount));
                    const rawTxn = (0, index_1.createRawTransaction)(sender, payload, BigInt(baseParam.sequenceNumber), baseParam.chainId, BigInt(baseParam.maxGasAmount), BigInt(baseParam.gasUnitPrice), BigInt(baseParam.expirationTimestampSecs));
                    tx = (0, index_1.generateBCSTransaction)(account, rawTxn);
                    break;
                }
                case "claimNft": {
                    const baseParam = ap.base;
                    const data = ap.data;
                    const payload = (0, index_1.claimNFTTokenPayload)(index_1.HexString.ensure(data.sender), index_1.HexString.ensure(data.creator), data.collectionName, data.tokenName, BigInt(data.version));
                    const rawTxn = (0, index_1.createRawTransaction)(sender, payload, BigInt(baseParam.sequenceNumber), baseParam.chainId, BigInt(baseParam.maxGasAmount), BigInt(baseParam.gasUnitPrice), BigInt(baseParam.expirationTimestampSecs));
                    tx = (0, index_1.generateBCSTransaction)(account, rawTxn);
                    break;
                }
                case "offerNft_simulate": {
                    const baseParam = ap.base;
                    const data = ap.data;
                    const payload = (0, index_1.offerNFTTokenPayload)(index_1.HexString.ensure(data.receiver), index_1.HexString.ensure(data.creator), data.collectionName, data.tokenName, BigInt(data.version), BigInt(data.amount));
                    const rawTxn = (0, index_1.createRawTransaction)(sender, payload, BigInt(baseParam.sequenceNumber), baseParam.chainId, BigInt(baseParam.maxGasAmount), BigInt(baseParam.gasUnitPrice), BigInt(baseParam.expirationTimestampSecs));
                    tx = (0, index_1.generateBCSSimulateTransaction)(account, rawTxn);
                    break;
                }
                case "claimNft_simulate": {
                    const baseParam = ap.base;
                    const data = ap.data;
                    const payload = (0, index_1.claimNFTTokenPayload)(index_1.HexString.ensure(data.sender), index_1.HexString.ensure(data.creator), data.collectionName, data.tokenName, BigInt(data.version));
                    const rawTxn = (0, index_1.createRawTransaction)(sender, payload, BigInt(baseParam.sequenceNumber), baseParam.chainId, BigInt(baseParam.maxGasAmount), BigInt(baseParam.gasUnitPrice), BigInt(baseParam.expirationTimestampSecs));
                    tx = (0, index_1.generateBCSSimulateTransaction)(account, rawTxn);
                    break;
                }
                case "simple_transaction": {
                    const baseParam = ap.base;
                    const data = ap.data;
                    const network = baseParam.chainId == 1 ? apiEndpoints_1.Network.MAINNET : apiEndpoints_1.Network.TESTNET;
                    const m = "{\"abi\":{\"address\":\"0x1\",\"name\":\"aptos_account\",\"friends\":[\"0x1::genesis\",\"0x1::resource_account\"],\"exposed_functions\":[{\"name\":\"assert_account_exists\",\"visibility\":\"public\",\"is_entry\":false,\"is_view\":false,\"generic_type_params\":[],\"params\":[\"address\"],\"return\":[]},{\"name\":\"assert_account_is_registered_for_apt\",\"visibility\":\"public\",\"is_entry\":false,\"is_view\":false,\"generic_type_params\":[],\"params\":[\"address\"],\"return\":[]},{\"name\":\"batch_transfer\",\"visibility\":\"public\",\"is_entry\":true,\"is_view\":false,\"generic_type_params\":[],\"params\":[\"&signer\",\"vector<address>\",\"vector<u64>\"],\"return\":[]},{\"name\":\"batch_transfer_coins\",\"visibility\":\"public\",\"is_entry\":true,\"is_view\":false,\"generic_type_params\":[{\"constraints\":[]}],\"params\":[\"&signer\",\"vector<address>\",\"vector<u64>\"],\"return\":[]},{\"name\":\"can_receive_direct_coin_transfers\",\"visibility\":\"public\",\"is_entry\":false,\"is_view\":true,\"generic_type_params\":[],\"params\":[\"address\"],\"return\":[\"bool\"]},{\"name\":\"create_account\",\"visibility\":\"public\",\"is_entry\":true,\"is_view\":false,\"generic_type_params\":[],\"params\":[\"address\"],\"return\":[]},{\"name\":\"deposit_coins\",\"visibility\":\"public\",\"is_entry\":false,\"is_view\":false,\"generic_type_params\":[{\"constraints\":[]}],\"params\":[\"address\",\"0x1::coin::Coin<T0>\"],\"return\":[]},{\"name\":\"set_allow_direct_coin_transfers\",\"visibility\":\"public\",\"is_entry\":true,\"is_view\":false,\"generic_type_params\":[],\"params\":[\"&signer\",\"bool\"],\"return\":[]},{\"name\":\"transfer\",\"visibility\":\"public\",\"is_entry\":true,\"is_view\":false,\"generic_type_params\":[],\"params\":[\"&signer\",\"address\",\"u64\"],\"return\":[]},{\"name\":\"transfer_coins\",\"visibility\":\"public\",\"is_entry\":true,\"is_view\":false,\"generic_type_params\":[{\"constraints\":[]}],\"params\":[\"&signer\",\"address\",\"u64\"],\"return\":[]}],\"structs\":[{\"name\":\"DirectCoinTransferConfigUpdatedEvent\",\"is_native\":false,\"abilities\":[\"drop\",\"store\"],\"generic_type_params\":[],\"fields\":[{\"name\":\"new_allow_direct_transfers\",\"type\":\"bool\"}]},{\"name\":\"DirectTransferConfig\",\"is_native\":false,\"abilities\":[\"key\"],\"generic_type_params\":[],\"fields\":[{\"name\":\"allow_arbitrary_coin_transfers\",\"type\":\"bool\"},{\"name\":\"update_coin_transfer_events\",\"type\":\"0x1::event::EventHandle<0x1::aptos_account::DirectCoinTransferConfigUpdatedEvent>\"}]}]}}";
                    const moveModule = data.moveModule == undefined ? m : data.moveModule;
                    const aptosConfig = new v2_1.AptosConfig({ network: network, moveModule: moveModule });
                    const transaction = new v2_1.Transaction(aptosConfig);
                    if (data.signAsFeePayer) {
                        const rawTransactionHex = data.rawTransaction;
                        const deserializer = new v2_1.Deserializer(crypto_lib_1.base.fromHex(rawTransactionHex));
                        const rawTransaction = v2_1.RawTransaction.deserialize(deserializer);
                        const rawTx = new v2_1.SimpleTransaction(rawTransaction, v2_1.AccountAddress.ZERO);
                        const sponsorSignature = transaction.signAsFeePayer({
                            signer: senderAccount,
                            transaction: rawTx
                        });
                        const raw = {
                            rawTransaction: rawTx.rawTransaction.bcsToHex().toString(),
                            sponsorSignature: sponsorSignature.bcsToHex().toString(),
                        };
                        return Promise.resolve(raw);
                    }
                    const functionArguments = data.functionArguments === undefined ? [data.recipientAddress, data.amount] : data.functionArguments;
                    const res = transaction.build.simple({
                        sender: senderAddress,
                        withFeePayer: data.withFeePayer,
                        data: {
                            function: data.function,
                            typeArguments: data.tyArg,
                            functionArguments: functionArguments,
                        },
                        options: {
                            maxGasAmount: Number(baseParam.maxGasAmount),
                            gasUnitPrice: Number(baseParam.gasUnitPrice),
                            expireTimestamp: Number(baseParam.expirationTimestampSecs),
                            chainId: Number(baseParam.chainId),
                            accountSequenceNumber: Number(baseParam.sequenceNumber),
                        },
                    }).then(rawTx => {
                        const senderSignature = transaction.sign({ signer: senderAccount, transaction: rawTx });
                        const raw = {
                            rawTransaction: rawTx.rawTransaction.bcsToHex().toString(),
                            senderSignature: senderSignature.bcsToHex().toString(),
                        };
                        return raw;
                    });
                    return res;
                }
                case "fungible_asset_transfer": {
                    const baseParam = ap.base;
                    const data = ap.data;
                    const aptosConfig = new v2_1.AptosConfig({ network: apiEndpoints_1.Network.MAINNET });
                    const fungibleAsset = new v2_1.FungibleAsset(aptosConfig);
                    const metadataAddress = data.fungibleAssetMetadataAddress;
                    const amount = BigInt(data.amount);
                    const res = fungibleAsset.transferFungibleAsset({
                        sender: senderAccount,
                        fungibleAssetMetadataAddress: v2_1.AccountAddress.from(metadataAddress),
                        recipient: data.recipientAddress,
                        amount: amount,
                        options: {
                            maxGasAmount: Number(baseParam.maxGasAmount),
                            gasUnitPrice: Number(baseParam.gasUnitPrice),
                            expireTimestamp: Number(baseParam.expirationTimestampSecs),
                            chainId: Number(baseParam.chainId),
                            accountSequenceNumber: Number(baseParam.sequenceNumber),
                        },
                    }).then(transferFungibleAssetRawTransaction => {
                        const authenticator = (0, transactionSubmission_1.signTransaction)({
                            signer: senderAccount,
                            transaction: transferFungibleAssetRawTransaction
                        });
                        const signedTx = (0, v2_1.generateSignedTransaction)({
                            transaction: transferFungibleAssetRawTransaction,
                            senderAuthenticator: authenticator,
                        });
                        return crypto_lib_1.base.toHex(signedTx);
                    });
                    return res;
                }
                case "simulate_fungible_asset_transfer": {
                    const baseParam = ap.base;
                    const data = ap.data;
                    const aptosConfig = new v2_1.AptosConfig({ network: apiEndpoints_1.Network.MAINNET });
                    const fungibleAsset = new v2_1.FungibleAsset(aptosConfig);
                    const metadataAddress = data.fungibleAssetMetadataAddress;
                    const amount = BigInt(data.amount);
                    const res = fungibleAsset.transferFungibleAsset({
                        sender: senderAccount,
                        fungibleAssetMetadataAddress: v2_1.AccountAddress.from(metadataAddress),
                        recipient: data.recipientAddress,
                        amount: amount,
                        options: {
                            maxGasAmount: Number(baseParam.maxGasAmount),
                            gasUnitPrice: Number(baseParam.gasUnitPrice),
                            expireTimestamp: Number(baseParam.expirationTimestampSecs),
                            chainId: Number(baseParam.chainId),
                            accountSequenceNumber: Number(baseParam.sequenceNumber),
                        },
                    }).then(transferFungibleAssetRawTransaction => {
                        const signedTx = (0, v2_1.generateSignedTransactionForSimulation)({
                            transaction: transferFungibleAssetRawTransaction,
                            signerPublicKey: senderAccount.publicKey,
                        });
                        return crypto_lib_1.base.toHex(signedTx);
                    });
                    return res;
                }
                default:
                    return Promise.reject(coin_base_1.SignTxError);
            }
            return Promise.resolve(crypto_lib_1.base.toHex(tx));
        }
        catch (e) {
            return Promise.reject(coin_base_1.SignTxError);
        }
    }
    validAddress(param) {
        let isValid;
        try {
            if (param.address.match(/^0x[0-9A-Fa-f]{62,64}$/) || param.address.match(/^[0-9A-Fa-f]{64}$/)) {
                isValid = true;
            }
            else {
                isValid = false;
            }
        }
        catch (e) {
            isValid = false;
        }
        let data = {
            isValid: isValid,
            address: param.address
        };
        return Promise.resolve(data);
    }
    async signMessage(param) {
        try {
            const message = param.data;
            let data = await client.signMessage(message, param.privateKey);
            if (data.startsWith("0x")) {
                data = data.substring(2);
            }
            return Promise.resolve(data);
        }
        catch (e) {
            return Promise.reject(coin_base_1.SignTxError);
        }
    }
    async signMessageByPayload(param) {
        try {
            const messagePayload = param.data;
            const prefix = "APTOS";
            let addr;
            let application;
            let chainId;
            let fullMessage = prefix;
            if (messagePayload?.address) {
                const account = new index_1.AptosAccount(crypto_lib_1.base.fromHex(param.privateKey));
                addr = account.address().hex();
                fullMessage = fullMessage.concat("\naddress: ", addr);
            }
            if (messagePayload?.application) {
                application = messagePayload.dAppDomain == undefined ? "" : messagePayload.dAppDomain;
                fullMessage = fullMessage.concat("\napplication: ", application);
            }
            if (messagePayload.chainId) {
                chainId = messagePayload.chain_id == undefined ? 0 : messagePayload.chain_id;
                fullMessage = fullMessage.concat("\nchainId: ", chainId.toString());
            }
            fullMessage = fullMessage.concat("\nmessage: ", messagePayload.message);
            fullMessage = fullMessage.concat("\nnonce: ", messagePayload.nonce);
            let signature = await client.signMessage(fullMessage, param.privateKey);
            if (signature.startsWith("0x")) {
                signature = signature.substring(2);
            }
            let res = {
                address: addr,
                application: application,
                chainId: chainId,
                fullMessage: fullMessage,
                message: messagePayload.message,
                nonce: messagePayload.nonce,
                prefix: prefix,
                signature: signature
            };
            return Promise.resolve(res);
        }
        catch (e) {
            return Promise.reject(coin_base_1.SignMsgError);
        }
    }
    async calcTxHash(param) {
        try {
            return Promise.resolve(this.GetTransactionHash(param.data));
        }
        catch (e) {
            return Promise.reject(coin_base_1.CalcTxHashError);
        }
    }
    async validSignedTransaction(param) {
        try {
            const skipCheckSign = param.data ? param.data.skipCheckSign : undefined;
            const ret = client.validSignedTransaction(param.tx, skipCheckSign || false);
            return Promise.resolve((0, coin_base_1.jsonStringifyUniform)(ret));
        }
        catch (e) {
            return Promise.reject(coin_base_1.validSignedTransactionError);
        }
    }
}
exports.AptosWallet = AptosWallet;
//# sourceMappingURL=AptosWallet.js.map