"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SingleKeyAccount = void 0;
const account_1 = require("../transactions/authenticator/account");
const types_1 = require("../types");
const accountAddress_1 = require("../core/accountAddress");
const crypto_1 = require("../core/crypto");
const signingMessage_1 = require("../transactions/transactionBuilder/signingMessage");
class SingleKeyAccount {
    constructor(args) {
        this.signingScheme = types_1.SigningScheme.SingleKey;
        const { privateKey, address } = args;
        this.privateKey = privateKey;
        this.publicKey = new crypto_1.AnyPublicKey(privateKey.publicKey());
        this.accountAddress = address ? accountAddress_1.AccountAddress.from(address) : this.publicKey.authKey().derivedAddress();
    }
    static generate(args = {}) {
        const { scheme = types_1.SigningSchemeInput.Ed25519 } = args;
        let privateKey;
        switch (scheme) {
            case types_1.SigningSchemeInput.Ed25519:
                privateKey = crypto_1.Ed25519PrivateKey.generate();
                break;
            case types_1.SigningSchemeInput.Secp256k1Ecdsa:
                privateKey = crypto_1.Secp256k1PrivateKey.generate();
                break;
            default:
                throw new Error(`Unsupported signature scheme ${scheme}`);
        }
        return new SingleKeyAccount({ privateKey });
    }
    static fromDerivationPath(args) {
        const { scheme = types_1.SigningSchemeInput.Ed25519, path, mnemonic } = args;
        let privateKey;
        switch (scheme) {
            case types_1.SigningSchemeInput.Ed25519:
                privateKey = crypto_1.Ed25519PrivateKey.fromDerivationPath(path, mnemonic);
                break;
            case types_1.SigningSchemeInput.Secp256k1Ecdsa:
                privateKey = crypto_1.Secp256k1PrivateKey.fromDerivationPath(path, mnemonic);
                break;
            default:
                throw new Error(`Unsupported signature scheme ${scheme}`);
        }
        return new SingleKeyAccount({ privateKey });
    }
    verifySignature(args) {
        return this.publicKey.verifySignature(args);
    }
    signWithAuthenticator(message) {
        return new account_1.AccountAuthenticatorSingleKey(this.publicKey, this.sign(message));
    }
    signTransactionWithAuthenticator(transaction) {
        return new account_1.AccountAuthenticatorSingleKey(this.publicKey, this.signTransaction(transaction));
    }
    sign(message) {
        return new crypto_1.AnySignature(this.privateKey.sign(message));
    }
    signTransaction(transaction) {
        return this.sign((0, signingMessage_1.generateSigningMessageForTransaction)(transaction));
    }
}
exports.SingleKeyAccount = SingleKeyAccount;
//# sourceMappingURL=SingleKeyAccount.js.map