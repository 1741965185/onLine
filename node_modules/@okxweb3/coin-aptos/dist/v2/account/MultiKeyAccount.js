"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiKeyAccount = void 0;
const crypto_1 = require("../core/crypto");
const types_1 = require("../types");
const account_1 = require("../transactions/authenticator/account");
class MultiKeyAccount {
    constructor(args) {
        const { multiKey, signers } = args;
        this.publicKey = multiKey;
        this.signingScheme = types_1.SigningScheme.MultiKey;
        this.accountAddress = this.publicKey.authKey().derivedAddress();
        const bitPositions = [];
        for (const signer of signers) {
            bitPositions.push(this.publicKey.getIndex(signer.publicKey));
        }
        const signersAndBitPosition = signers.map((signer, index) => [signer, bitPositions[index]]);
        signersAndBitPosition.sort((a, b) => a[1] - b[1]);
        this.signers = signersAndBitPosition.map((value) => value[0]);
        this.signerIndicies = signersAndBitPosition.map((value) => value[1]);
        this.signaturesBitmap = this.publicKey.createBitmap({ bits: bitPositions });
    }
    static fromPublicKeysAndSigners(args) {
        const { publicKeys, signaturesRequired, signers } = args;
        const multiKey = new crypto_1.MultiKey({ publicKeys, signaturesRequired });
        return new MultiKeyAccount({ multiKey, signers });
    }
    static isMultiKeySigner(account) {
        return account instanceof MultiKeyAccount;
    }
    signWithAuthenticator(message) {
        return new account_1.AccountAuthenticatorMultiKey(this.publicKey, this.sign(message));
    }
    signTransactionWithAuthenticator(transaction) {
        return new account_1.AccountAuthenticatorMultiKey(this.publicKey, this.signTransaction(transaction));
    }
    sign(data) {
        const signatures = [];
        for (const signer of this.signers) {
            signatures.push(signer.sign(data));
        }
        return new crypto_1.MultiKeySignature({ signatures, bitmap: this.signaturesBitmap });
    }
    signTransaction(transaction) {
        const signatures = [];
        for (const signer of this.signers) {
            signatures.push(signer.signTransaction(transaction));
        }
        return new crypto_1.MultiKeySignature({ signatures, bitmap: this.signaturesBitmap });
    }
    verifySignature(args) {
        const { message, signature } = args;
        const isSignerIndiciesSorted = this.signerIndicies.every((value, i) => i === 0 || value >= this.signerIndicies[i - 1]);
        if (!isSignerIndiciesSorted) {
            return false;
        }
        for (let i = 0; i < signature.signatures.length; i += 1) {
            const singleSignature = signature.signatures[i];
            const publicKey = this.publicKey.publicKeys[this.signerIndicies[i]];
            if (!publicKey.verifySignature({ message, signature: singleSignature })) {
                return false;
            }
        }
        return true;
    }
}
exports.MultiKeyAccount = MultiKeyAccount;
//# sourceMappingURL=MultiKeyAccount.js.map