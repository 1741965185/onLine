"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ed25519Account = void 0;
const account_1 = require("../transactions/authenticator/account");
const types_1 = require("../types");
const accountAddress_1 = require("../core/accountAddress");
const crypto_1 = require("../core/crypto");
const signingMessage_1 = require("../transactions/transactionBuilder/signingMessage");
class Ed25519Account {
    constructor(args) {
        this.signingScheme = types_1.SigningScheme.Ed25519;
        const { privateKey, address } = args;
        this.privateKey = privateKey;
        this.publicKey = privateKey.publicKey();
        this.accountAddress = address ? accountAddress_1.AccountAddress.from(address) : this.publicKey.authKey().derivedAddress();
    }
    static generate() {
        const privateKey = crypto_1.Ed25519PrivateKey.generate();
        return new Ed25519Account({ privateKey });
    }
    static fromDerivationPath(args) {
        const { path, mnemonic } = args;
        const privateKey = crypto_1.Ed25519PrivateKey.fromDerivationPath(path, mnemonic);
        return new Ed25519Account({ privateKey });
    }
    verifySignature(args) {
        return this.publicKey.verifySignature(args);
    }
    signWithAuthenticator(message) {
        return new account_1.AccountAuthenticatorEd25519(this.publicKey, this.privateKey.sign(message));
    }
    signTransactionWithAuthenticator(transaction) {
        return new account_1.AccountAuthenticatorEd25519(this.publicKey, this.signTransaction(transaction));
    }
    sign(message) {
        return this.privateKey.sign(message);
    }
    signTransaction(transaction) {
        return this.sign((0, signingMessage_1.generateSigningMessageForTransaction)(transaction));
    }
}
exports.Ed25519Account = Ed25519Account;
//# sourceMappingURL=Ed25519Account.js.map