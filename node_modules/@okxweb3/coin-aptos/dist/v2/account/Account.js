"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Account = void 0;
const types_1 = require("../types");
const crypto_1 = require("../core/crypto");
const Ed25519Account_1 = require("./Ed25519Account");
const SingleKeyAccount_1 = require("./SingleKeyAccount");
class Account {
    static generate(args = {}) {
        const { scheme = types_1.SigningSchemeInput.Ed25519, legacy = true } = args;
        if (scheme === types_1.SigningSchemeInput.Ed25519 && legacy) {
            return Ed25519Account_1.Ed25519Account.generate();
        }
        return SingleKeyAccount_1.SingleKeyAccount.generate({ scheme });
    }
    static fromPrivateKey(args) {
        const { privateKey, address, legacy = true } = args;
        if (privateKey instanceof crypto_1.Ed25519PrivateKey && legacy) {
            return new Ed25519Account_1.Ed25519Account({
                privateKey,
                address,
            });
        }
        return new SingleKeyAccount_1.SingleKeyAccount({ privateKey, address });
    }
    static fromPrivateKeyAndAddress(args) {
        return this.fromPrivateKey(args);
    }
    static fromDerivationPath(args) {
        const { scheme = types_1.SigningSchemeInput.Ed25519, mnemonic, path, legacy = true } = args;
        if (scheme === types_1.SigningSchemeInput.Ed25519 && legacy) {
            return Ed25519Account_1.Ed25519Account.fromDerivationPath({ mnemonic, path });
        }
        return SingleKeyAccount_1.SingleKeyAccount.fromDerivationPath({ scheme, mnemonic, path });
    }
    static authKey(args) {
        const { publicKey } = args;
        return publicKey.authKey();
    }
    verifySignature(args) {
        return this.publicKey.verifySignature(args);
    }
}
exports.Account = Account;
//# sourceMappingURL=Account.js.map