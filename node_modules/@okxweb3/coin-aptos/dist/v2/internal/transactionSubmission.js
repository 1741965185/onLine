"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rotateAuthKey = exports.publicPackageTransaction = exports.signAndSubmitTransaction = exports.submitTransaction = exports.simulateTransaction = exports.signTransaction = exports.getSigningMessage = exports.buildRawTransaction = exports.buildTransactionPayload = exports.generateTransaction = void 0;
const bcs_1 = require("../bcs");
const account_1 = require("../account");
const accountAddress_1 = require("../core/accountAddress");
const rotationProofChallenge_1 = require("../transactions/instances/rotationProofChallenge");
const transactionBuilder_1 = require("../transactions/transactionBuilder/transactionBuilder");
const transactions_1 = require("../transactions");
async function generateTransaction(args) {
    const payload = await buildTransactionPayload(args);
    return buildRawTransaction(args, payload);
}
exports.generateTransaction = generateTransaction;
async function buildTransactionPayload(args) {
    const { aptosConfig, data } = args;
    let generateTransactionPayloadData;
    let payload;
    if ("bytecode" in data) {
        payload = await (0, transactionBuilder_1.generateTransactionPayload)(data);
    }
    else if ("multisigAddress" in data) {
        generateTransactionPayloadData = {
            aptosConfig,
            multisigAddress: data.multisigAddress,
            function: data.function,
            functionArguments: data.functionArguments,
            typeArguments: data.typeArguments,
            abi: data.abi,
        };
        payload = await (0, transactionBuilder_1.generateTransactionPayload)(generateTransactionPayloadData);
    }
    else {
        generateTransactionPayloadData = {
            aptosConfig,
            function: data.function,
            functionArguments: data.functionArguments,
            typeArguments: data.typeArguments,
            abi: data.abi,
        };
        payload = await (0, transactionBuilder_1.generateTransactionPayload)(generateTransactionPayloadData);
    }
    return payload;
}
exports.buildTransactionPayload = buildTransactionPayload;
async function buildRawTransaction(args, payload) {
    const { aptosConfig, sender, options } = args;
    let feePayerAddress;
    if (isFeePayerTransactionInput(args)) {
        feePayerAddress = accountAddress_1.AccountAddress.ZERO.toString();
    }
    if (isMultiAgentTransactionInput(args)) {
        const { secondarySignerAddresses } = args;
        return (0, transactionBuilder_1.buildTransaction)({
            aptosConfig,
            sender,
            payload,
            options,
            secondarySignerAddresses,
            feePayerAddress,
        });
    }
    return (0, transactionBuilder_1.buildTransaction)({
        aptosConfig,
        sender,
        payload,
        options,
        feePayerAddress,
    });
}
exports.buildRawTransaction = buildRawTransaction;
function isFeePayerTransactionInput(data) {
    return data.withFeePayer === true;
}
function isMultiAgentTransactionInput(data) {
    return "secondarySignerAddresses" in data;
}
function getSigningMessage(args) {
    const { transaction } = args;
    return (0, transactions_1.generateSigningMessageForTransaction)(transaction);
}
exports.getSigningMessage = getSigningMessage;
function signTransaction(args) {
    const { signer, transaction } = args;
    return signer.signTransactionWithAuthenticator(transaction);
}
exports.signTransaction = signTransaction;
async function simulateTransaction(args) {
    const { aptosConfig, transaction, signerPublicKey, secondarySignersPublicKeys, feePayerPublicKey, options } = args;
    return (0, transactionBuilder_1.generateSignedTransactionForSimulation)({
        transaction,
        signerPublicKey,
        secondarySignersPublicKeys,
        feePayerPublicKey,
        options,
    });
}
exports.simulateTransaction = simulateTransaction;
async function submitTransaction(args) {
    return (0, transactionBuilder_1.generateSignedTransaction)({ ...args });
}
exports.submitTransaction = submitTransaction;
async function signAndSubmitTransaction(args) {
    const { aptosConfig, signer, transaction } = args;
    const authenticator = signTransaction({ signer, transaction });
    return submitTransaction({
        aptosConfig,
        transaction,
        senderAuthenticator: authenticator,
    });
}
exports.signAndSubmitTransaction = signAndSubmitTransaction;
const packagePublishAbi = {
    typeParameters: [],
    parameters: [transactions_1.TypeTagVector.u8(), new transactions_1.TypeTagVector(transactions_1.TypeTagVector.u8())],
};
async function publicPackageTransaction(args) {
    const { aptosConfig, account, metadataBytes, moduleBytecode, options } = args;
    const totalByteCode = moduleBytecode.map((bytecode) => bcs_1.MoveVector.U8(bytecode));
    return generateTransaction({
        aptosConfig,
        sender: accountAddress_1.AccountAddress.from(account),
        data: {
            function: "0x1::code::publish_package_txn",
            functionArguments: [bcs_1.MoveVector.U8(metadataBytes), new bcs_1.MoveVector(totalByteCode)],
            abi: packagePublishAbi,
        },
        options,
    });
}
exports.publicPackageTransaction = publicPackageTransaction;
const rotateAuthKeyAbi = {
    typeParameters: [],
    parameters: [
        new transactions_1.TypeTagU8(),
        transactions_1.TypeTagVector.u8(),
        new transactions_1.TypeTagU8(),
        transactions_1.TypeTagVector.u8(),
        transactions_1.TypeTagVector.u8(),
        transactions_1.TypeTagVector.u8(),
    ],
};
async function rotateAuthKey(args) {
    const { aptosConfig, fromAccount, toNewPrivateKey, sequenceNumber, authenticationKey } = args;
    const newAccount = account_1.Account.fromPrivateKey({ privateKey: toNewPrivateKey, legacy: true });
    const challenge = new rotationProofChallenge_1.RotationProofChallenge({
        sequenceNumber: BigInt(sequenceNumber),
        originator: fromAccount.accountAddress,
        currentAuthKey: accountAddress_1.AccountAddress.from(authenticationKey),
        newPublicKey: newAccount.publicKey,
    });
    const challengeHex = challenge.bcsToBytes();
    const proofSignedByCurrentPrivateKey = fromAccount.sign(challengeHex);
    const proofSignedByNewPrivateKey = newAccount.sign(challengeHex);
    const rawTxn = await generateTransaction({
        aptosConfig,
        sender: fromAccount.accountAddress,
        data: {
            function: "0x1::account::rotate_authentication_key",
            functionArguments: [
                new bcs_1.U8(fromAccount.signingScheme),
                bcs_1.MoveVector.U8(fromAccount.publicKey.toUint8Array()),
                new bcs_1.U8(newAccount.signingScheme),
                bcs_1.MoveVector.U8(newAccount.publicKey.toUint8Array()),
                bcs_1.MoveVector.U8(proofSignedByCurrentPrivateKey.toUint8Array()),
                bcs_1.MoveVector.U8(proofSignedByNewPrivateKey.toUint8Array()),
            ],
            abi: rotateAuthKeyAbi,
        },
    });
    return signAndSubmitTransaction({
        aptosConfig,
        signer: fromAccount,
        transaction: rawTxn,
    });
}
exports.rotateAuthKey = rotateAuthKey;
//# sourceMappingURL=transactionSubmission.js.map