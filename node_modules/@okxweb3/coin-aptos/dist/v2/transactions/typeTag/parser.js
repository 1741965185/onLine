"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseTypeTag = exports.TypeTagParserError = exports.TypeTagParserErrorType = void 0;
const _1 = require(".");
const core_1 = require("../../core");
const identifier_1 = require("../instances/identifier");
function isValidIdentifier(str) {
    return !!str.match(/^[_a-zA-Z0-9]+$/);
}
function isValidWhitespaceCharacter(char) {
    return !!char.match(/\s/);
}
function isGeneric(str) {
    return !!str.match(/^T[0-9]+$/);
}
function consumeWhitespace(tagStr, pos) {
    let i = pos;
    for (; i < tagStr.length; i += 1) {
        const innerChar = tagStr[i];
        if (!isValidWhitespaceCharacter(innerChar)) {
            break;
        }
    }
    return i;
}
var TypeTagParserErrorType;
(function (TypeTagParserErrorType) {
    TypeTagParserErrorType["InvalidTypeTag"] = "unknown type";
    TypeTagParserErrorType["UnexpectedGenericType"] = "unexpected generic type";
    TypeTagParserErrorType["UnexpectedTypeArgumentClose"] = "unexpected '>'";
    TypeTagParserErrorType["UnexpectedWhitespaceCharacter"] = "unexpected whitespace character";
    TypeTagParserErrorType["UnexpectedComma"] = "unexpected ','";
    TypeTagParserErrorType["TypeArgumentCountMismatch"] = "type argument count doesn't match expected amount";
    TypeTagParserErrorType["MissingTypeArgumentClose"] = "no matching '>' for '<'";
    TypeTagParserErrorType["UnexpectedPrimitiveTypeArguments"] = "primitive types not expected to have type arguments";
    TypeTagParserErrorType["UnexpectedVectorTypeArgumentCount"] = "vector type expected to have exactly one type argument";
    TypeTagParserErrorType["UnexpectedStructFormat"] = "unexpected struct format, must be of the form 0xaddress::module_name::struct_name";
    TypeTagParserErrorType["InvalidModuleNameCharacter"] = "module name must only contain alphanumeric or '_' characters";
    TypeTagParserErrorType["InvalidStructNameCharacter"] = "struct name must only contain alphanumeric or '_' characters";
})(TypeTagParserErrorType = exports.TypeTagParserErrorType || (exports.TypeTagParserErrorType = {}));
class TypeTagParserError extends Error {
    constructor(typeTagStr, invalidReason) {
        super(`Failed to parse typeTag '${typeTagStr}', ${invalidReason}`);
    }
}
exports.TypeTagParserError = TypeTagParserError;
function parseTypeTag(typeStr, options) {
    const allowGenerics = options?.allowGenerics ?? false;
    const saved = [];
    let innerTypes = [];
    let curTypes = [];
    let cur = 0;
    let currentStr = "";
    let expectedTypes = 1;
    while (cur < typeStr.length) {
        const char = typeStr[cur];
        if (char === "<") {
            saved.push({
                savedExpectedTypes: expectedTypes,
                savedStr: currentStr,
                savedTypes: curTypes,
            });
            currentStr = "";
            curTypes = [];
            expectedTypes = 1;
        }
        else if (char === ">") {
            if (currentStr !== "") {
                const newType = parseTypeTagInner(currentStr, innerTypes, allowGenerics);
                curTypes.push(newType);
            }
            const savedPop = saved.pop();
            if (savedPop === undefined) {
                throw new TypeTagParserError(typeStr, TypeTagParserErrorType.UnexpectedTypeArgumentClose);
            }
            if (expectedTypes !== curTypes.length) {
                throw new TypeTagParserError(typeStr, TypeTagParserErrorType.TypeArgumentCountMismatch);
            }
            const { savedStr, savedTypes, savedExpectedTypes } = savedPop;
            innerTypes = curTypes;
            curTypes = savedTypes;
            currentStr = savedStr;
            expectedTypes = savedExpectedTypes;
        }
        else if (char === ",") {
            if (currentStr.length !== 0) {
                const newType = parseTypeTagInner(currentStr, innerTypes, allowGenerics);
                innerTypes = [];
                curTypes.push(newType);
                currentStr = "";
                expectedTypes += 1;
            }
        }
        else if (isValidWhitespaceCharacter(char)) {
            let parsedTypeTag = false;
            if (currentStr.length !== 0) {
                const newType = parseTypeTagInner(currentStr, innerTypes, allowGenerics);
                innerTypes = [];
                curTypes.push(newType);
                currentStr = "";
                parsedTypeTag = true;
            }
            cur = consumeWhitespace(typeStr, cur);
            const nextChar = typeStr[cur];
            if (cur < typeStr.length && parsedTypeTag && nextChar !== "," && nextChar !== ">") {
                throw new TypeTagParserError(typeStr, TypeTagParserErrorType.UnexpectedWhitespaceCharacter);
            }
            continue;
        }
        else {
            currentStr += char;
        }
        cur += 1;
    }
    if (saved.length > 0) {
        throw new TypeTagParserError(typeStr, TypeTagParserErrorType.MissingTypeArgumentClose);
    }
    switch (curTypes.length) {
        case 0:
            return parseTypeTagInner(currentStr, innerTypes, allowGenerics);
        case 1:
            if (currentStr === "") {
                return curTypes[0];
            }
            throw new TypeTagParserError(typeStr, TypeTagParserErrorType.UnexpectedComma);
        default:
            throw new TypeTagParserError(typeStr, TypeTagParserErrorType.UnexpectedWhitespaceCharacter);
    }
}
exports.parseTypeTag = parseTypeTag;
function parseTypeTagInner(str, types, allowGenerics) {
    switch (str) {
        case "&signer":
            if (types.length > 0) {
                throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedPrimitiveTypeArguments);
            }
            return new _1.TypeTagReference(new _1.TypeTagSigner());
        case "signer":
            if (types.length > 0) {
                throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedPrimitiveTypeArguments);
            }
            return new _1.TypeTagSigner();
        case "bool":
            if (types.length > 0) {
                throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedPrimitiveTypeArguments);
            }
            return new _1.TypeTagBool();
        case "address":
            if (types.length > 0) {
                throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedPrimitiveTypeArguments);
            }
            return new _1.TypeTagAddress();
        case "u8":
            if (types.length > 0) {
                throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedPrimitiveTypeArguments);
            }
            return new _1.TypeTagU8();
        case "u16":
            if (types.length > 0) {
                throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedPrimitiveTypeArguments);
            }
            return new _1.TypeTagU16();
        case "u32":
            if (types.length > 0) {
                throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedPrimitiveTypeArguments);
            }
            return new _1.TypeTagU32();
        case "u64":
            if (types.length > 0) {
                throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedPrimitiveTypeArguments);
            }
            return new _1.TypeTagU64();
        case "u128":
            if (types.length > 0) {
                throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedPrimitiveTypeArguments);
            }
            return new _1.TypeTagU128();
        case "u256":
            if (types.length > 0) {
                throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedPrimitiveTypeArguments);
            }
            return new _1.TypeTagU256();
        case "vector":
            if (types.length !== 1) {
                throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedVectorTypeArgumentCount);
            }
            return new _1.TypeTagVector(types[0]);
        default:
            if (isGeneric(str)) {
                if (allowGenerics) {
                    return new _1.TypeTagGeneric(Number(str.split("T")[1]));
                }
                throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedGenericType);
            }
            if (!str.match(/:/)) {
                throw new TypeTagParserError(str, TypeTagParserErrorType.InvalidTypeTag);
            }
            const structParts = str.split("::");
            if (structParts.length !== 3) {
                throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedStructFormat);
            }
            if (!isValidIdentifier(structParts[1])) {
                throw new TypeTagParserError(str, TypeTagParserErrorType.InvalidModuleNameCharacter);
            }
            if (!isValidIdentifier(structParts[2])) {
                throw new TypeTagParserError(str, TypeTagParserErrorType.InvalidStructNameCharacter);
            }
            return new _1.TypeTagStruct(new _1.StructTag(core_1.AccountAddress.fromString(structParts[0]), new identifier_1.Identifier(structParts[1]), new identifier_1.Identifier(structParts[2]), types));
    }
}
//# sourceMappingURL=parser.js.map