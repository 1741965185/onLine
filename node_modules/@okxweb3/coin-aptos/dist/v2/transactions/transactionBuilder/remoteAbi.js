"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkOrConvertArgument = exports.convertArgument = exports.fetchEntryFunctionAbi = exports.standardizeTypeTags = void 0;
const parser_1 = require("../typeTag/parser");
const typeTag_1 = require("../typeTag");
const bcs_1 = require("../../bcs");
const core_1 = require("../../core");
const helpers_1 = require("./helpers");
function standardizeTypeTags(typeArguments) {
    return (typeArguments?.map((typeArg) => {
        if ((0, helpers_1.isString)(typeArg)) {
            return (0, parser_1.parseTypeTag)(typeArg);
        }
        return typeArg;
    }) ?? []);
}
exports.standardizeTypeTags = standardizeTypeTags;
async function fetchEntryFunctionAbi(moduleAddress, moduleName, functionName, aptosConfig) {
    const module = JSON.parse(aptosConfig?.moveModule);
    const functionAbi = module?.abi?.exposed_functions.find((func) => func.name === functionName);
    if (!functionAbi) {
        throw new Error(`Could not find entry function ABI for '${moduleAddress}::${moduleName}::${functionName}'`);
    }
    if (!functionAbi.is_entry) {
        throw new Error(`'${moduleAddress}::${moduleName}::${functionName}' is not an entry function`);
    }
    const first = (0, helpers_1.findFirstNonSignerArg)(functionAbi);
    const params = [];
    for (let i = first; i < functionAbi.params.length; i += 1) {
        params.push((0, parser_1.parseTypeTag)(functionAbi.params[i], { allowGenerics: true }));
    }
    return {
        typeParameters: functionAbi.generic_type_params,
        parameters: params,
    };
}
exports.fetchEntryFunctionAbi = fetchEntryFunctionAbi;
function convertArgument(functionName, functionAbi, arg, position, genericTypeParams) {
    if (position >= functionAbi.parameters.length) {
        throw new Error(`Too many arguments for '${functionName}', expected ${functionAbi.parameters.length}`);
    }
    const param = functionAbi.parameters[position];
    return checkOrConvertArgument(arg, param, position, genericTypeParams);
}
exports.convertArgument = convertArgument;
function checkOrConvertArgument(arg, param, position, genericTypeParams) {
    if ((0, helpers_1.isEncodedEntryFunctionArgument)(arg)) {
        checkType(param, arg, position);
        return arg;
    }
    return parseArg(arg, param, position, genericTypeParams);
}
exports.checkOrConvertArgument = checkOrConvertArgument;
function parseArg(arg, param, position, genericTypeParams) {
    if (param.isBool()) {
        if ((0, helpers_1.isBool)(arg)) {
            return new bcs_1.Bool(arg);
        }
        (0, helpers_1.throwTypeMismatch)("boolean", position);
    }
    if (param.isAddress()) {
        if ((0, helpers_1.isString)(arg)) {
            return core_1.AccountAddress.fromString(arg);
        }
        (0, helpers_1.throwTypeMismatch)("string | AccountAddress", position);
    }
    if (param.isU8()) {
        if ((0, helpers_1.isNumber)(arg)) {
            return new bcs_1.U8(arg);
        }
        (0, helpers_1.throwTypeMismatch)("number", position);
    }
    if (param.isU16()) {
        if ((0, helpers_1.isNumber)(arg)) {
            return new bcs_1.U16(arg);
        }
        (0, helpers_1.throwTypeMismatch)("number", position);
    }
    if (param.isU32()) {
        if ((0, helpers_1.isNumber)(arg)) {
            return new bcs_1.U32(arg);
        }
        (0, helpers_1.throwTypeMismatch)("number", position);
    }
    if (param.isU64()) {
        if ((0, helpers_1.isLargeNumber)(arg)) {
            return new bcs_1.U64(BigInt(arg));
        }
        (0, helpers_1.throwTypeMismatch)("bigint | number | string", position);
    }
    if (param.isU128()) {
        if ((0, helpers_1.isLargeNumber)(arg)) {
            return new bcs_1.U128(BigInt(arg));
        }
        (0, helpers_1.throwTypeMismatch)("bigint | number | string", position);
    }
    if (param.isU256()) {
        if ((0, helpers_1.isLargeNumber)(arg)) {
            return new bcs_1.U256(BigInt(arg));
        }
        (0, helpers_1.throwTypeMismatch)("bigint | number | string", position);
    }
    if (param.isGeneric()) {
        const genericIndex = param.value;
        if (genericIndex < 0 || genericIndex >= genericTypeParams.length) {
            throw new Error(`Generic argument ${param.toString()} is invalid for argument ${position}`);
        }
        return checkOrConvertArgument(arg, genericTypeParams[genericIndex], position, genericTypeParams);
    }
    if (param.isVector()) {
        if (param.value.isU8()) {
            if ((0, helpers_1.isString)(arg)) {
                const textEncoder = new TextEncoder();
                return bcs_1.MoveVector.U8(textEncoder.encode(arg));
            }
            if (arg instanceof Uint8Array) {
                return bcs_1.MoveVector.U8(arg);
            }
            if (arg instanceof ArrayBuffer) {
                return bcs_1.MoveVector.U8(new Uint8Array(arg));
            }
        }
        if (Array.isArray(arg)) {
            return new bcs_1.MoveVector(arg.map((item) => checkOrConvertArgument(item, param.value, position, genericTypeParams)));
        }
        throw new Error(`Type mismatch for argument ${position}, type '${param.toString()}'`);
    }
    if (param.isStruct()) {
        if (param.isString()) {
            if ((0, helpers_1.isString)(arg)) {
                return new bcs_1.MoveString(arg);
            }
            (0, helpers_1.throwTypeMismatch)("string", position);
        }
        if (param.isObject()) {
            if ((0, helpers_1.isString)(arg)) {
                return core_1.AccountAddress.fromString(arg);
            }
            (0, helpers_1.throwTypeMismatch)("string | AccountAddress", position);
        }
        if (param.isOption()) {
            if ((0, helpers_1.isNull)(arg)) {
                return new bcs_1.MoveOption(null);
            }
            return new bcs_1.MoveOption(checkOrConvertArgument(arg, param.value.typeArgs[0], position, genericTypeParams));
        }
        throw new Error(`Unsupported struct input type for argument ${position}, type '${param.toString()}'`);
    }
    throw new Error(`Type mismatch for argument ${position}, type '${param.toString()}'`);
}
function checkType(param, arg, position) {
    if (param.isBool()) {
        if ((0, helpers_1.isBcsBool)(arg)) {
            return;
        }
        (0, helpers_1.throwTypeMismatch)("Bool", position);
    }
    if (param.isAddress()) {
        if ((0, helpers_1.isBcsAddress)(arg)) {
            return;
        }
        (0, helpers_1.throwTypeMismatch)("AccountAddress", position);
    }
    if (param.isU8()) {
        if ((0, helpers_1.isBcsU8)(arg)) {
            return;
        }
        (0, helpers_1.throwTypeMismatch)("U8", position);
    }
    if (param.isU16()) {
        if ((0, helpers_1.isBcsU16)(arg)) {
            return;
        }
        (0, helpers_1.throwTypeMismatch)("U16", position);
    }
    if (param.isU32()) {
        if ((0, helpers_1.isBcsU32)(arg)) {
            return;
        }
        (0, helpers_1.throwTypeMismatch)("U32", position);
    }
    if (param.isU64()) {
        if ((0, helpers_1.isBcsU64)(arg)) {
            return;
        }
        (0, helpers_1.throwTypeMismatch)("U64", position);
    }
    if (param.isU128()) {
        if ((0, helpers_1.isBcsU128)(arg)) {
            return;
        }
        (0, helpers_1.throwTypeMismatch)("U128", position);
    }
    if (param.isU256()) {
        if ((0, helpers_1.isBcsU256)(arg)) {
            return;
        }
        (0, helpers_1.throwTypeMismatch)("U256", position);
    }
    if (param.isVector()) {
        if (arg instanceof bcs_1.MoveVector) {
            if (arg.values.length > 0) {
                checkType(param.value, arg.values[0], position);
            }
            return;
        }
        (0, helpers_1.throwTypeMismatch)("MoveVector", position);
    }
    if (param instanceof typeTag_1.TypeTagStruct) {
        if (param.isString()) {
            if ((0, helpers_1.isBcsString)(arg)) {
                return;
            }
            (0, helpers_1.throwTypeMismatch)("MoveString", position);
        }
        if (param.isObject()) {
            if ((0, helpers_1.isBcsAddress)(arg)) {
                return;
            }
            (0, helpers_1.throwTypeMismatch)("AccountAddress", position);
        }
        if (param.isOption()) {
            if (arg instanceof bcs_1.MoveOption) {
                if (arg.value !== undefined) {
                    checkType(param.value.typeArgs[0], arg.value, position);
                }
                return;
            }
            (0, helpers_1.throwTypeMismatch)("MoveOption", position);
        }
    }
    throw new Error(`Type mismatch for argument ${position}, expected '${param.toString()}'`);
}
//# sourceMappingURL=remoteAbi.js.map