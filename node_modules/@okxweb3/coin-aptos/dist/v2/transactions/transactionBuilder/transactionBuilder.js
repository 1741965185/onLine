"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateUserTransactionHash = exports.hashValues = exports.generateSignedTransaction = exports.getAuthenticatorForSimulation = exports.generateSignedTransactionForSimulation = exports.buildTransaction = exports.generateRawTransaction = exports.generateTransactionPayloadWithABI = exports.generateTransactionPayload = void 0;
const sha3_1 = require("@noble/hashes/sha3");
const core_1 = require("../../core");
const crypto_1 = require("../../core/crypto");
const ed25519_1 = require("../../core/crypto/ed25519");
const const_1 = require("../../utils/const");
const normalizeBundle_1 = require("../../utils/normalizeBundle");
const account_1 = require("../authenticator/account");
const transaction_1 = require("../authenticator/transaction");
const instances_1 = require("../instances");
const signedTransaction_1 = require("../instances/signedTransaction");
const remoteAbi_1 = require("./remoteAbi");
const memoize_1 = require("../../utils/memoize");
const helpers_1 = require("./helpers");
const simpleTransaction_1 = require("../instances/simpleTransaction");
const multiAgentTransaction_1 = require("../instances/multiAgentTransaction");
async function generateTransactionPayload(args) {
    if ((0, helpers_1.isScriptDataInput)(args)) {
        return generateTransactionPayloadScript(args);
    }
    const { moduleAddress, moduleName, functionName } = (0, helpers_1.getFunctionParts)(args.function);
    const functionAbi = await fetchAbi({
        key: "entry-function",
        moduleAddress,
        moduleName,
        functionName,
        aptosConfig: args.aptosConfig,
        abi: args.abi,
        fetch: remoteAbi_1.fetchEntryFunctionAbi,
    });
    return generateTransactionPayloadWithABI({ ...args, abi: functionAbi });
}
exports.generateTransactionPayload = generateTransactionPayload;
function generateTransactionPayloadWithABI(args) {
    const functionAbi = args.abi;
    const { moduleAddress, moduleName, functionName } = (0, helpers_1.getFunctionParts)(args.function);
    const typeArguments = (0, remoteAbi_1.standardizeTypeTags)(args.typeArguments);
    if (typeArguments.length !== functionAbi.typeParameters.length) {
        throw new Error(`Type argument count mismatch, expected ${functionAbi.typeParameters.length}, received ${typeArguments.length}`);
    }
    const functionArguments = args.functionArguments.map((arg, i) => (0, remoteAbi_1.convertArgument)(args.function, functionAbi, arg, i, typeArguments));
    if (functionArguments.length !== functionAbi.parameters.length) {
        throw new Error(`Too few arguments for '${moduleAddress}::${moduleName}::${functionName}', expected ${functionAbi.parameters.length} but got ${functionArguments.length}`);
    }
    const entryFunctionPayload = instances_1.EntryFunction.build(`${moduleAddress}::${moduleName}`, functionName, typeArguments, functionArguments);
    if ("multisigAddress" in args) {
        const multisigAddress = core_1.AccountAddress.from(args.multisigAddress);
        return new instances_1.TransactionPayloadMultiSig(new instances_1.MultiSig(multisigAddress, new instances_1.MultiSigTransactionPayload(entryFunctionPayload)));
    }
    return new instances_1.TransactionPayloadEntryFunction(entryFunctionPayload);
}
exports.generateTransactionPayloadWithABI = generateTransactionPayloadWithABI;
function generateTransactionPayloadScript(args) {
    return new instances_1.TransactionPayloadScript(new instances_1.Script(core_1.Hex.fromHexInput(args.bytecode).toUint8Array(), args.typeArguments ?? [], args.functionArguments));
}
async function generateRawTransaction(args) {
    const { aptosConfig, sender, payload, options, feePayerAddress } = args;
    let getSequenceNumber;
    getSequenceNumber = options?.accountSequenceNumber;
    let getGasUnitPrice;
    getGasUnitPrice = options?.gasUnitPrice;
    let getChainId;
    getChainId = options?.chainId;
    const { maxGasAmount, gasUnitPrice, expireTimestamp, chainId } = {
        maxGasAmount: options?.maxGasAmount ? BigInt(options.maxGasAmount) : BigInt(const_1.DEFAULT_MAX_GAS_AMOUNT),
        gasUnitPrice: BigInt(options?.gasUnitPrice),
        expireTimestamp: BigInt(Math.floor(Date.now() / 1000) + const_1.DEFAULT_TXN_EXP_SEC_FROM_NOW),
        ...options,
    };
    return new instances_1.RawTransaction(core_1.AccountAddress.from(sender), BigInt(getSequenceNumber), payload, BigInt(maxGasAmount), BigInt(gasUnitPrice), BigInt(expireTimestamp), new instances_1.ChainId(chainId));
}
exports.generateRawTransaction = generateRawTransaction;
async function buildTransaction(args) {
    const { aptosConfig, sender, payload, options, feePayerAddress } = args;
    const rawTxn = await generateRawTransaction({
        aptosConfig,
        sender,
        payload,
        options,
        feePayerAddress,
    });
    if ("secondarySignerAddresses" in args) {
        const signers = args.secondarySignerAddresses?.map((signer) => core_1.AccountAddress.from(signer)) ?? [];
        return new multiAgentTransaction_1.MultiAgentTransaction(rawTxn, signers, args.feePayerAddress ? core_1.AccountAddress.from(args.feePayerAddress) : undefined);
    }
    return new simpleTransaction_1.SimpleTransaction(rawTxn, args.feePayerAddress ? core_1.AccountAddress.from(args.feePayerAddress) : undefined);
}
exports.buildTransaction = buildTransaction;
function generateSignedTransactionForSimulation(args) {
    const { signerPublicKey, transaction, secondarySignersPublicKeys, feePayerPublicKey } = args;
    const accountAuthenticator = getAuthenticatorForSimulation(signerPublicKey);
    if (transaction.feePayerAddress) {
        const transactionToSign = new instances_1.FeePayerRawTransaction(transaction.rawTransaction, transaction.secondarySignerAddresses ?? [], transaction.feePayerAddress);
        let secondaryAccountAuthenticators = [];
        if (secondarySignersPublicKeys) {
            secondaryAccountAuthenticators = secondarySignersPublicKeys.map((publicKey) => getAuthenticatorForSimulation(publicKey));
        }
        const feePayerAuthenticator = getAuthenticatorForSimulation(feePayerPublicKey);
        const transactionAuthenticator = new transaction_1.TransactionAuthenticatorFeePayer(accountAuthenticator, transaction.secondarySignerAddresses ?? [], secondaryAccountAuthenticators, {
            address: transaction.feePayerAddress,
            authenticator: feePayerAuthenticator,
        });
        return new signedTransaction_1.SignedTransaction(transactionToSign.raw_txn, transactionAuthenticator).bcsToBytes();
    }
    if (transaction.secondarySignerAddresses) {
        const transactionToSign = new instances_1.MultiAgentRawTransaction(transaction.rawTransaction, transaction.secondarySignerAddresses);
        let secondaryAccountAuthenticators = [];
        secondaryAccountAuthenticators = secondarySignersPublicKeys.map((publicKey) => getAuthenticatorForSimulation(publicKey));
        const transactionAuthenticator = new transaction_1.TransactionAuthenticatorMultiAgent(accountAuthenticator, transaction.secondarySignerAddresses, secondaryAccountAuthenticators);
        return new signedTransaction_1.SignedTransaction(transactionToSign.raw_txn, transactionAuthenticator).bcsToBytes();
    }
    let transactionAuthenticator;
    if (accountAuthenticator instanceof account_1.AccountAuthenticatorEd25519) {
        transactionAuthenticator = new transaction_1.TransactionAuthenticatorEd25519(accountAuthenticator.public_key, accountAuthenticator.signature);
    }
    else if (accountAuthenticator instanceof account_1.AccountAuthenticatorSingleKey) {
        transactionAuthenticator = new transaction_1.TransactionAuthenticatorSingleSender(accountAuthenticator);
    }
    else {
        throw new Error("Invalid public key");
    }
    return new signedTransaction_1.SignedTransaction(transaction.rawTransaction, transactionAuthenticator).bcsToBytes();
}
exports.generateSignedTransactionForSimulation = generateSignedTransactionForSimulation;
function getAuthenticatorForSimulation(publicKey) {
    if (publicKey instanceof crypto_1.AnyPublicKey) {
        if (publicKey.publicKey instanceof ed25519_1.Ed25519PublicKey) {
            return new account_1.AccountAuthenticatorSingleKey(publicKey, new crypto_1.AnySignature(new ed25519_1.Ed25519Signature(new Uint8Array(64))));
        }
        if (publicKey.publicKey instanceof crypto_1.Secp256k1PublicKey) {
            return new account_1.AccountAuthenticatorSingleKey(publicKey, new crypto_1.AnySignature(new crypto_1.Secp256k1Signature(new Uint8Array(64))));
        }
    }
    return new account_1.AccountAuthenticatorEd25519(new ed25519_1.Ed25519PublicKey(publicKey.toUint8Array()), new ed25519_1.Ed25519Signature(new Uint8Array(64)));
}
exports.getAuthenticatorForSimulation = getAuthenticatorForSimulation;
function generateSignedTransaction(args) {
    const { transaction, feePayerAuthenticator, additionalSignersAuthenticators } = args;
    const senderAuthenticator = (0, normalizeBundle_1.normalizeBundle)(account_1.AccountAuthenticator, args.senderAuthenticator);
    let txnAuthenticator;
    if (transaction.feePayerAddress) {
        if (!feePayerAuthenticator) {
            throw new Error("Must provide a feePayerAuthenticator argument to generate a signed fee payer transaction");
        }
        txnAuthenticator = new transaction_1.TransactionAuthenticatorFeePayer(senderAuthenticator, transaction.secondarySignerAddresses ?? [], additionalSignersAuthenticators ?? [], {
            address: transaction.feePayerAddress,
            authenticator: feePayerAuthenticator,
        });
    }
    else if (transaction.secondarySignerAddresses) {
        if (!additionalSignersAuthenticators) {
            throw new Error("Must provide a additionalSignersAuthenticators argument to generate a signed multi agent transaction");
        }
        txnAuthenticator = new transaction_1.TransactionAuthenticatorMultiAgent(senderAuthenticator, transaction.secondarySignerAddresses, additionalSignersAuthenticators);
    }
    else if (senderAuthenticator instanceof account_1.AccountAuthenticatorEd25519) {
        txnAuthenticator = new transaction_1.TransactionAuthenticatorEd25519(senderAuthenticator.public_key, senderAuthenticator.signature);
    }
    else {
        txnAuthenticator = new transaction_1.TransactionAuthenticatorSingleSender(senderAuthenticator);
    }
    return new signedTransaction_1.SignedTransaction(transaction.rawTransaction, txnAuthenticator).bcsToBytes();
}
exports.generateSignedTransaction = generateSignedTransaction;
function hashValues(input) {
    const hash = sha3_1.sha3_256.create();
    for (const item of input) {
        hash.update(item);
    }
    return hash.digest();
}
exports.hashValues = hashValues;
const TRANSACTION_PREFIX = hashValues(["APTOS::Transaction"]);
function generateUserTransactionHash(args) {
    const signedTransaction = generateSignedTransaction(args);
    return new core_1.Hex(hashValues([TRANSACTION_PREFIX, new Uint8Array([0]), signedTransaction])).toString();
}
exports.generateUserTransactionHash = generateUserTransactionHash;
async function fetchAbi({ key, moduleAddress, moduleName, functionName, aptosConfig, abi, fetch, }) {
    if (abi !== undefined) {
        return abi;
    }
    return (0, memoize_1.memoizeAsync)(async () => fetch(moduleAddress, moduleName, functionName, aptosConfig), `${key}-${aptosConfig.network}-${moduleAddress}-${moduleName}-${functionName}`, 1000 * 60 * 5)();
}
//# sourceMappingURL=transactionBuilder.js.map