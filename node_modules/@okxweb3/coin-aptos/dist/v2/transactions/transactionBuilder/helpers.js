"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFunctionParts = exports.findFirstNonSignerArg = exports.throwTypeMismatch = exports.isScriptDataInput = exports.isBcsU256 = exports.isBcsU128 = exports.isBcsU64 = exports.isBcsU32 = exports.isBcsU16 = exports.isBcsU8 = exports.isBcsFixedBytes = exports.isBcsString = exports.isBcsAddress = exports.isBcsBool = exports.isEncodedEntryFunctionArgument = exports.isNull = exports.isLargeNumber = exports.isNumber = exports.isString = exports.isBool = void 0;
const bcs_1 = require("../../bcs");
const core_1 = require("../../core");
function isBool(arg) {
    return typeof arg === "boolean";
}
exports.isBool = isBool;
function isString(arg) {
    return typeof arg === "string";
}
exports.isString = isString;
function isNumber(arg) {
    return typeof arg === "number";
}
exports.isNumber = isNumber;
function isLargeNumber(arg) {
    return typeof arg === "number" || typeof arg === "bigint" || typeof arg === "string";
}
exports.isLargeNumber = isLargeNumber;
function isNull(arg) {
    return arg === null || arg === undefined;
}
exports.isNull = isNull;
function isEncodedEntryFunctionArgument(arg) {
    return (isBcsBool(arg) ||
        isBcsU8(arg) ||
        isBcsU16(arg) ||
        isBcsU32(arg) ||
        isBcsU64(arg) ||
        isBcsU128(arg) ||
        isBcsU256(arg) ||
        isBcsAddress(arg) ||
        isBcsString(arg) ||
        isBcsFixedBytes(arg) ||
        arg instanceof bcs_1.MoveVector ||
        arg instanceof bcs_1.MoveOption);
}
exports.isEncodedEntryFunctionArgument = isEncodedEntryFunctionArgument;
function isBcsBool(arg) {
    return arg instanceof bcs_1.Bool;
}
exports.isBcsBool = isBcsBool;
function isBcsAddress(arg) {
    return arg instanceof core_1.AccountAddress;
}
exports.isBcsAddress = isBcsAddress;
function isBcsString(arg) {
    return arg instanceof bcs_1.MoveString;
}
exports.isBcsString = isBcsString;
function isBcsFixedBytes(arg) {
    return arg instanceof bcs_1.FixedBytes;
}
exports.isBcsFixedBytes = isBcsFixedBytes;
function isBcsU8(arg) {
    return arg instanceof bcs_1.U8;
}
exports.isBcsU8 = isBcsU8;
function isBcsU16(arg) {
    return arg instanceof bcs_1.U16;
}
exports.isBcsU16 = isBcsU16;
function isBcsU32(arg) {
    return arg instanceof bcs_1.U32;
}
exports.isBcsU32 = isBcsU32;
function isBcsU64(arg) {
    return arg instanceof bcs_1.U64;
}
exports.isBcsU64 = isBcsU64;
function isBcsU128(arg) {
    return arg instanceof bcs_1.U128;
}
exports.isBcsU128 = isBcsU128;
function isBcsU256(arg) {
    return arg instanceof bcs_1.U256;
}
exports.isBcsU256 = isBcsU256;
function isScriptDataInput(arg) {
    return "bytecode" in arg;
}
exports.isScriptDataInput = isScriptDataInput;
function throwTypeMismatch(expectedType, position) {
    throw new Error(`Type mismatch for argument ${position}, expected '${expectedType}'`);
}
exports.throwTypeMismatch = throwTypeMismatch;
function findFirstNonSignerArg(functionAbi) {
    const index = functionAbi.params.findIndex((param) => param !== "signer" && param !== "&signer");
    if (index < 0) {
        return functionAbi.params.length;
    }
    return index;
}
exports.findFirstNonSignerArg = findFirstNonSignerArg;
function getFunctionParts(functionArg) {
    const funcNameParts = functionArg.split("::");
    if (funcNameParts.length !== 3) {
        throw new Error(`Invalid function ${functionArg}`);
    }
    const moduleAddress = funcNameParts[0];
    const moduleName = funcNameParts[1];
    const functionName = funcNameParts[2];
    return { moduleAddress, moduleName, functionName };
}
exports.getFunctionParts = getFunctionParts;
//# sourceMappingURL=helpers.js.map