"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiSigTransactionPayload = exports.MultiSig = exports.Script = exports.EntryFunction = exports.TransactionPayloadMultiSig = exports.TransactionPayloadEntryFunction = exports.TransactionPayloadScript = exports.TransactionPayload = exports.deserializeFromScriptArgument = void 0;
const serializer_1 = require("../../bcs/serializer");
const entryFunctionBytes_1 = require("../../bcs/serializable/entryFunctionBytes");
const movePrimitives_1 = require("../../bcs/serializable/movePrimitives");
const moveStructs_1 = require("../../bcs/serializable/moveStructs");
const core_1 = require("../../core");
const identifier_1 = require("./identifier");
const moduleId_1 = require("./moduleId");
const types_1 = require("../../types");
const typeTag_1 = require("../typeTag");
function deserializeFromScriptArgument(deserializer) {
    const index = deserializer.deserializeUleb128AsU32();
    switch (index) {
        case types_1.ScriptTransactionArgumentVariants.U8:
            return movePrimitives_1.U8.deserialize(deserializer);
        case types_1.ScriptTransactionArgumentVariants.U64:
            return movePrimitives_1.U64.deserialize(deserializer);
        case types_1.ScriptTransactionArgumentVariants.U128:
            return movePrimitives_1.U128.deserialize(deserializer);
        case types_1.ScriptTransactionArgumentVariants.Address:
            return core_1.AccountAddress.deserialize(deserializer);
        case types_1.ScriptTransactionArgumentVariants.U8Vector:
            return moveStructs_1.MoveVector.deserialize(deserializer, movePrimitives_1.U8);
        case types_1.ScriptTransactionArgumentVariants.Bool:
            return movePrimitives_1.Bool.deserialize(deserializer);
        case types_1.ScriptTransactionArgumentVariants.U16:
            return movePrimitives_1.U16.deserialize(deserializer);
        case types_1.ScriptTransactionArgumentVariants.U32:
            return movePrimitives_1.U32.deserialize(deserializer);
        case types_1.ScriptTransactionArgumentVariants.U256:
            return movePrimitives_1.U256.deserialize(deserializer);
        default:
            throw new Error(`Unknown variant index for ScriptTransactionArgument: ${index}`);
    }
}
exports.deserializeFromScriptArgument = deserializeFromScriptArgument;
class TransactionPayload extends serializer_1.Serializable {
    static deserialize(deserializer) {
        const index = deserializer.deserializeUleb128AsU32();
        switch (index) {
            case types_1.TransactionPayloadVariants.Script:
                return TransactionPayloadScript.load(deserializer);
            case types_1.TransactionPayloadVariants.EntryFunction:
                return TransactionPayloadEntryFunction.load(deserializer);
            case types_1.TransactionPayloadVariants.Multisig:
                return TransactionPayloadMultiSig.load(deserializer);
            default:
                throw new Error(`Unknown variant index for TransactionPayload: ${index}`);
        }
    }
}
exports.TransactionPayload = TransactionPayload;
class TransactionPayloadScript extends TransactionPayload {
    constructor(script) {
        super();
        this.script = script;
    }
    serialize(serializer) {
        serializer.serializeU32AsUleb128(types_1.TransactionPayloadVariants.Script);
        this.script.serialize(serializer);
    }
    static load(deserializer) {
        const script = Script.deserialize(deserializer);
        return new TransactionPayloadScript(script);
    }
}
exports.TransactionPayloadScript = TransactionPayloadScript;
class TransactionPayloadEntryFunction extends TransactionPayload {
    constructor(entryFunction) {
        super();
        this.entryFunction = entryFunction;
    }
    serialize(serializer) {
        serializer.serializeU32AsUleb128(types_1.TransactionPayloadVariants.EntryFunction);
        this.entryFunction.serialize(serializer);
    }
    static load(deserializer) {
        const entryFunction = EntryFunction.deserialize(deserializer);
        return new TransactionPayloadEntryFunction(entryFunction);
    }
}
exports.TransactionPayloadEntryFunction = TransactionPayloadEntryFunction;
class TransactionPayloadMultiSig extends TransactionPayload {
    constructor(multiSig) {
        super();
        this.multiSig = multiSig;
    }
    serialize(serializer) {
        serializer.serializeU32AsUleb128(types_1.TransactionPayloadVariants.Multisig);
        this.multiSig.serialize(serializer);
    }
    static load(deserializer) {
        const value = MultiSig.deserialize(deserializer);
        return new TransactionPayloadMultiSig(value);
    }
}
exports.TransactionPayloadMultiSig = TransactionPayloadMultiSig;
class EntryFunction {
    constructor(module_name, function_name, type_args, args) {
        this.module_name = module_name;
        this.function_name = function_name;
        this.type_args = type_args;
        this.args = args;
    }
    static build(module_id, function_name, type_args, args) {
        return new EntryFunction(moduleId_1.ModuleId.fromStr(module_id), new identifier_1.Identifier(function_name), type_args, args);
    }
    serialize(serializer) {
        this.module_name.serialize(serializer);
        this.function_name.serialize(serializer);
        serializer.serializeVector(this.type_args);
        serializer.serializeU32AsUleb128(this.args.length);
        this.args.forEach((item) => {
            item.serializeForEntryFunction(serializer);
        });
    }
    static deserialize(deserializer) {
        const module_name = moduleId_1.ModuleId.deserialize(deserializer);
        const function_name = identifier_1.Identifier.deserialize(deserializer);
        const type_args = deserializer.deserializeVector(typeTag_1.TypeTag);
        const length = deserializer.deserializeUleb128AsU32();
        const args = new Array();
        for (let i = 0; i < length; i += 1) {
            const fixedBytesLength = deserializer.deserializeUleb128AsU32();
            const fixedBytes = entryFunctionBytes_1.EntryFunctionBytes.deserialize(deserializer, fixedBytesLength);
            args.push(fixedBytes);
        }
        return new EntryFunction(module_name, function_name, type_args, args);
    }
}
exports.EntryFunction = EntryFunction;
class Script {
    constructor(bytecode, type_args, args) {
        this.bytecode = bytecode;
        this.type_args = type_args;
        this.args = args;
    }
    serialize(serializer) {
        serializer.serializeBytes(this.bytecode);
        serializer.serializeVector(this.type_args);
        serializer.serializeU32AsUleb128(this.args.length);
        this.args.forEach((item) => {
            item.serializeForScriptFunction(serializer);
        });
    }
    static deserialize(deserializer) {
        const bytecode = deserializer.deserializeBytes();
        const type_args = deserializer.deserializeVector(typeTag_1.TypeTag);
        const length = deserializer.deserializeUleb128AsU32();
        const args = new Array();
        for (let i = 0; i < length; i += 1) {
            const scriptArgument = deserializeFromScriptArgument(deserializer);
            args.push(scriptArgument);
        }
        return new Script(bytecode, type_args, args);
    }
}
exports.Script = Script;
class MultiSig {
    constructor(multisig_address, transaction_payload) {
        this.multisig_address = multisig_address;
        this.transaction_payload = transaction_payload;
    }
    serialize(serializer) {
        this.multisig_address.serialize(serializer);
        if (this.transaction_payload === undefined) {
            serializer.serializeBool(false);
        }
        else {
            serializer.serializeBool(true);
            this.transaction_payload.serialize(serializer);
        }
    }
    static deserialize(deserializer) {
        const multisig_address = core_1.AccountAddress.deserialize(deserializer);
        const payloadPresent = deserializer.deserializeBool();
        let transaction_payload;
        if (payloadPresent) {
            transaction_payload = MultiSigTransactionPayload.deserialize(deserializer);
        }
        return new MultiSig(multisig_address, transaction_payload);
    }
}
exports.MultiSig = MultiSig;
class MultiSigTransactionPayload extends serializer_1.Serializable {
    constructor(transaction_payload) {
        super();
        this.transaction_payload = transaction_payload;
    }
    serialize(serializer) {
        serializer.serializeU32AsUleb128(0);
        this.transaction_payload.serialize(serializer);
    }
    static deserialize(deserializer) {
        deserializer.deserializeUleb128AsU32();
        return new MultiSigTransactionPayload(EntryFunction.deserialize(deserializer));
    }
}
exports.MultiSigTransactionPayload = MultiSigTransactionPayload;
//# sourceMappingURL=transactionPayload.js.map