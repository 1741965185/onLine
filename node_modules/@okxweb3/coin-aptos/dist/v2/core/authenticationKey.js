"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthenticationKey = void 0;
const sha3_1 = require("@noble/hashes/sha3");
const accountAddress_1 = require("./accountAddress");
const hex_1 = require("./hex");
const serializer_1 = require("../bcs/serializer");
class AuthenticationKey extends serializer_1.Serializable {
    constructor(args) {
        super();
        const { data } = args;
        const hex = hex_1.Hex.fromHexInput(data);
        if (hex.toUint8Array().length !== AuthenticationKey.LENGTH) {
            throw new Error(`Authentication Key length should be ${AuthenticationKey.LENGTH}`);
        }
        this.data = hex;
    }
    serialize(serializer) {
        serializer.serializeFixedBytes(this.data.toUint8Array());
    }
    static deserialize(deserializer) {
        const bytes = deserializer.deserializeFixedBytes(AuthenticationKey.LENGTH);
        return new AuthenticationKey({ data: bytes });
    }
    toString() {
        return this.data.toString();
    }
    toUint8Array() {
        return this.data.toUint8Array();
    }
    static fromSchemeAndBytes(args) {
        const { scheme, input } = args;
        const inputBytes = hex_1.Hex.fromHexInput(input).toUint8Array();
        const hashInput = new Uint8Array([...inputBytes, scheme]);
        const hash = sha3_1.sha3_256.create();
        hash.update(hashInput);
        const hashDigest = hash.digest();
        return new AuthenticationKey({ data: hashDigest });
    }
    static fromPublicKeyAndScheme(args) {
        const { publicKey } = args;
        return publicKey.authKey();
    }
    static fromPublicKey(args) {
        const { publicKey } = args;
        return publicKey.authKey();
    }
    derivedAddress() {
        return new accountAddress_1.AccountAddress(this.data.toUint8Array());
    }
}
exports.AuthenticationKey = AuthenticationKey;
AuthenticationKey.LENGTH = 32;
//# sourceMappingURL=authenticationKey.js.map