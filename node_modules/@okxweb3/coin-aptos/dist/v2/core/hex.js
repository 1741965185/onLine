"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Hex = exports.HexInvalidReason = void 0;
const utils_1 = require("@noble/hashes/utils");
const common_1 = require("./common");
var HexInvalidReason;
(function (HexInvalidReason) {
    HexInvalidReason["TOO_SHORT"] = "too_short";
    HexInvalidReason["INVALID_LENGTH"] = "invalid_length";
    HexInvalidReason["INVALID_HEX_CHARS"] = "invalid_hex_chars";
})(HexInvalidReason = exports.HexInvalidReason || (exports.HexInvalidReason = {}));
class Hex {
    constructor(data) {
        this.data = data;
    }
    toUint8Array() {
        return this.data;
    }
    toStringWithoutPrefix() {
        return (0, utils_1.bytesToHex)(this.data);
    }
    toString() {
        return `0x${this.toStringWithoutPrefix()}`;
    }
    static fromHexString(str) {
        let input = str;
        if (input.startsWith("0x")) {
            input = input.slice(2);
        }
        if (input.length === 0) {
            throw new common_1.ParsingError("Hex string is too short, must be at least 1 char long, excluding the optional leading 0x.", HexInvalidReason.TOO_SHORT);
        }
        if (input.length % 2 !== 0) {
            throw new common_1.ParsingError("Hex string must be an even number of hex characters.", HexInvalidReason.INVALID_LENGTH);
        }
        try {
            return new Hex((0, utils_1.hexToBytes)(input));
        }
        catch (error) {
            throw new common_1.ParsingError(`Hex string contains invalid hex characters: ${error?.message}`, HexInvalidReason.INVALID_HEX_CHARS);
        }
    }
    static fromHexInput(hexInput) {
        if (hexInput instanceof Uint8Array)
            return new Hex(hexInput);
        return Hex.fromHexString(hexInput);
    }
    static isValid(str) {
        try {
            Hex.fromHexString(str);
            return { valid: true };
        }
        catch (error) {
            return {
                valid: false,
                invalidReason: error?.invalidReason,
                invalidReasonMessage: error?.message,
            };
        }
    }
    equals(other) {
        if (this.data.length !== other.data.length)
            return false;
        return this.data.every((value, index) => value === other.data[index]);
    }
}
exports.Hex = Hex;
//# sourceMappingURL=hex.js.map