"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ed25519Signature = exports.Ed25519PrivateKey = exports.Ed25519PublicKey = void 0;
const ed25519_1 = require("@noble/curves/ed25519");
const serializer_1 = require("../../bcs/serializer");
const authenticationKey_1 = require("../authenticationKey");
const hex_1 = require("../hex");
const types_1 = require("../../types");
const hdKey_1 = require("./hdKey");
const publicKey_1 = require("./publicKey");
const signature_1 = require("./signature");
const utils_1 = require("./utils");
const L = [
    0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
];
class Ed25519PublicKey extends publicKey_1.AccountPublicKey {
    constructor(hexInput) {
        super();
        const hex = hex_1.Hex.fromHexInput(hexInput);
        if (hex.toUint8Array().length !== Ed25519PublicKey.LENGTH) {
            throw new Error(`PublicKey length should be ${Ed25519PublicKey.LENGTH}`);
        }
        this.key = hex;
    }
    verifySignature(args) {
        const { message, signature } = args;
        if (!(signature instanceof Ed25519Signature)) {
            return false;
        }
        const messageToVerify = (0, utils_1.convertSigningMessage)(message);
        const messageBytes = hex_1.Hex.fromHexInput(messageToVerify).toUint8Array();
        const signatureBytes = signature.toUint8Array();
        const publicKeyBytes = this.key.toUint8Array();
        if (!signature.isCanonicalSignature()) {
            return false;
        }
        return ed25519_1.ed25519.verify(signatureBytes, messageBytes, publicKeyBytes);
    }
    authKey() {
        return authenticationKey_1.AuthenticationKey.fromSchemeAndBytes({
            scheme: types_1.SigningScheme.Ed25519,
            input: this.toUint8Array(),
        });
    }
    toUint8Array() {
        return this.key.toUint8Array();
    }
    serialize(serializer) {
        serializer.serializeBytes(this.key.toUint8Array());
    }
    static deserialize(deserializer) {
        const bytes = deserializer.deserializeBytes();
        return new Ed25519PublicKey(bytes);
    }
    static isPublicKey(publicKey) {
        return publicKey instanceof Ed25519PublicKey;
    }
}
exports.Ed25519PublicKey = Ed25519PublicKey;
Ed25519PublicKey.LENGTH = 32;
class Ed25519PrivateKey extends serializer_1.Serializable {
    constructor(hexInput) {
        super();
        const privateKeyHex = hex_1.Hex.fromHexInput(hexInput);
        if (privateKeyHex.toUint8Array().length !== Ed25519PrivateKey.LENGTH) {
            throw new Error(`PrivateKey length should be ${Ed25519PrivateKey.LENGTH}`);
        }
        this.signingKey = privateKeyHex;
    }
    static generate() {
        const keyPair = ed25519_1.ed25519.utils.randomPrivateKey();
        return new Ed25519PrivateKey(keyPair);
    }
    static fromDerivationPath(path, mnemonics) {
        if (!(0, hdKey_1.isValidHardenedPath)(path)) {
            throw new Error(`Invalid derivation path ${path}`);
        }
        return Ed25519PrivateKey.fromDerivationPathInner(path, (0, hdKey_1.mnemonicToSeed)(mnemonics));
    }
    static fromDerivationPathInner(path, seed, offset = hdKey_1.HARDENED_OFFSET) {
        const { key, chainCode } = (0, hdKey_1.deriveKey)(Ed25519PrivateKey.SLIP_0010_SEED, seed);
        const segments = (0, hdKey_1.splitPath)(path).map((el) => parseInt(el, 10));
        const { key: privateKey } = segments.reduce((parentKeys, segment) => (0, hdKey_1.CKDPriv)(parentKeys, segment + offset), {
            key,
            chainCode,
        });
        return new Ed25519PrivateKey(privateKey);
    }
    publicKey() {
        const bytes = ed25519_1.ed25519.getPublicKey(this.signingKey.toUint8Array());
        return new Ed25519PublicKey(bytes);
    }
    sign(message) {
        const messageToSign = (0, utils_1.convertSigningMessage)(message);
        const messageBytes = hex_1.Hex.fromHexInput(messageToSign).toUint8Array();
        const signatureBytes = ed25519_1.ed25519.sign(messageBytes, this.signingKey.toUint8Array());
        return new Ed25519Signature(signatureBytes);
    }
    toUint8Array() {
        return this.signingKey.toUint8Array();
    }
    toString() {
        return this.signingKey.toString();
    }
    serialize(serializer) {
        serializer.serializeBytes(this.toUint8Array());
    }
    static deserialize(deserializer) {
        const bytes = deserializer.deserializeBytes();
        return new Ed25519PrivateKey(bytes);
    }
    static isPrivateKey(privateKey) {
        return privateKey instanceof Ed25519PrivateKey;
    }
}
exports.Ed25519PrivateKey = Ed25519PrivateKey;
Ed25519PrivateKey.LENGTH = 32;
Ed25519PrivateKey.SLIP_0010_SEED = "ed25519 seed";
class Ed25519Signature extends signature_1.Signature {
    constructor(hexInput) {
        super();
        const data = hex_1.Hex.fromHexInput(hexInput);
        if (data.toUint8Array().length !== Ed25519Signature.LENGTH) {
            throw new Error(`Signature length should be ${Ed25519Signature.LENGTH}`);
        }
        this.data = data;
    }
    toUint8Array() {
        return this.data.toUint8Array();
    }
    serialize(serializer) {
        serializer.serializeBytes(this.data.toUint8Array());
    }
    static deserialize(deserializer) {
        const bytes = deserializer.deserializeBytes();
        return new Ed25519Signature(bytes);
    }
    isCanonicalSignature() {
        const s = this.toUint8Array().slice(32);
        for (let i = s.length - 1; i >= 0; i -= 1) {
            if (s[i] < L[i]) {
                return true;
            }
            if (s[i] > L[i]) {
                return false;
            }
        }
        return false;
    }
}
exports.Ed25519Signature = Ed25519Signature;
Ed25519Signature.LENGTH = 64;
//# sourceMappingURL=ed25519.js.map