"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiEd25519Signature = exports.MultiEd25519PublicKey = void 0;
const types_1 = require("../../types");
const authenticationKey_1 = require("../authenticationKey");
const ed25519_1 = require("./ed25519");
const publicKey_1 = require("./publicKey");
const signature_1 = require("./signature");
class MultiEd25519PublicKey extends publicKey_1.AccountPublicKey {
    constructor(args) {
        super();
        const { publicKeys, threshold } = args;
        if (publicKeys.length > MultiEd25519PublicKey.MAX_KEYS || publicKeys.length < MultiEd25519PublicKey.MIN_KEYS) {
            throw new Error(`Must have between ${MultiEd25519PublicKey.MIN_KEYS} and ` +
                `${MultiEd25519PublicKey.MAX_KEYS} public keys, inclusive`);
        }
        if (threshold < MultiEd25519PublicKey.MIN_THRESHOLD || threshold > publicKeys.length) {
            throw new Error(`Threshold must be between ${MultiEd25519PublicKey.MIN_THRESHOLD} and ${publicKeys.length}, inclusive`);
        }
        this.publicKeys = publicKeys;
        this.threshold = threshold;
    }
    verifySignature(args) {
        const { message, signature } = args;
        if (!(signature instanceof MultiEd25519Signature)) {
            return false;
        }
        const indices = [];
        for (let i = 0; i < 4; i += 1) {
            for (let j = 0; j < 8; j += 1) {
                const bitIsSet = (signature.bitmap[i] & (1 << (7 - j))) !== 0;
                if (bitIsSet) {
                    const index = i * 8 + j;
                    indices.push(index);
                }
            }
        }
        if (indices.length !== signature.signatures.length) {
            throw new Error("Bitmap and signatures length mismatch");
        }
        if (indices.length < this.threshold) {
            throw new Error("Not enough signatures");
        }
        for (let i = 0; i < indices.length; i += 1) {
            const publicKey = this.publicKeys[indices[i]];
            if (!publicKey.verifySignature({ message, signature: signature.signatures[i] })) {
                return false;
            }
        }
        return true;
    }
    authKey() {
        return authenticationKey_1.AuthenticationKey.fromSchemeAndBytes({
            scheme: types_1.SigningScheme.MultiEd25519,
            input: this.toUint8Array(),
        });
    }
    toUint8Array() {
        const bytes = new Uint8Array(this.publicKeys.length * ed25519_1.Ed25519PublicKey.LENGTH + 1);
        this.publicKeys.forEach((k, i) => {
            bytes.set(k.toUint8Array(), i * ed25519_1.Ed25519PublicKey.LENGTH);
        });
        bytes[this.publicKeys.length * ed25519_1.Ed25519PublicKey.LENGTH] = this.threshold;
        return bytes;
    }
    serialize(serializer) {
        serializer.serializeBytes(this.toUint8Array());
    }
    static deserialize(deserializer) {
        const bytes = deserializer.deserializeBytes();
        const threshold = bytes[bytes.length - 1];
        const keys = [];
        for (let i = 0; i < bytes.length - 1; i += ed25519_1.Ed25519PublicKey.LENGTH) {
            const begin = i;
            keys.push(new ed25519_1.Ed25519PublicKey(bytes.subarray(begin, begin + ed25519_1.Ed25519PublicKey.LENGTH)));
        }
        return new MultiEd25519PublicKey({ publicKeys: keys, threshold });
    }
}
exports.MultiEd25519PublicKey = MultiEd25519PublicKey;
MultiEd25519PublicKey.MAX_KEYS = 32;
MultiEd25519PublicKey.MIN_KEYS = 2;
MultiEd25519PublicKey.MIN_THRESHOLD = 1;
class MultiEd25519Signature extends signature_1.Signature {
    constructor(args) {
        super();
        const { signatures, bitmap } = args;
        if (signatures.length > MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED) {
            throw new Error(`The number of signatures cannot be greater than ${MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED}`);
        }
        this.signatures = signatures;
        if (!(bitmap instanceof Uint8Array)) {
            this.bitmap = MultiEd25519Signature.createBitmap({ bits: bitmap });
        }
        else if (bitmap.length !== MultiEd25519Signature.BITMAP_LEN) {
            throw new Error(`"bitmap" length should be ${MultiEd25519Signature.BITMAP_LEN}`);
        }
        else {
            this.bitmap = bitmap;
        }
    }
    toUint8Array() {
        const bytes = new Uint8Array(this.signatures.length * ed25519_1.Ed25519Signature.LENGTH + MultiEd25519Signature.BITMAP_LEN);
        this.signatures.forEach((k, i) => {
            bytes.set(k.toUint8Array(), i * ed25519_1.Ed25519Signature.LENGTH);
        });
        bytes.set(this.bitmap, this.signatures.length * ed25519_1.Ed25519Signature.LENGTH);
        return bytes;
    }
    serialize(serializer) {
        serializer.serializeBytes(this.toUint8Array());
    }
    static deserialize(deserializer) {
        const bytes = deserializer.deserializeBytes();
        const bitmap = bytes.subarray(bytes.length - 4);
        const signatures = [];
        for (let i = 0; i < bytes.length - bitmap.length; i += ed25519_1.Ed25519Signature.LENGTH) {
            const begin = i;
            signatures.push(new ed25519_1.Ed25519Signature(bytes.subarray(begin, begin + ed25519_1.Ed25519Signature.LENGTH)));
        }
        return new MultiEd25519Signature({ signatures, bitmap });
    }
    static createBitmap(args) {
        const { bits } = args;
        const firstBitInByte = 128;
        const bitmap = new Uint8Array([0, 0, 0, 0]);
        const dupCheckSet = new Set();
        bits.forEach((bit, index) => {
            if (bit >= MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED) {
                throw new Error(`Cannot have a signature larger than ${MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED - 1}.`);
            }
            if (dupCheckSet.has(bit)) {
                throw new Error("Duplicate bits detected.");
            }
            if (index > 0 && bit <= bits[index - 1]) {
                throw new Error("The bits need to be sorted in ascending order.");
            }
            dupCheckSet.add(bit);
            const byteOffset = Math.floor(bit / 8);
            let byte = bitmap[byteOffset];
            byte |= firstBitInByte >> bit % 8;
            bitmap[byteOffset] = byte;
        });
        return bitmap;
    }
}
exports.MultiEd25519Signature = MultiEd25519Signature;
MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED = 32;
MultiEd25519Signature.BITMAP_LEN = 4;
//# sourceMappingURL=multiEd25519.js.map