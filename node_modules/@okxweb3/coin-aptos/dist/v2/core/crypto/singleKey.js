"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnySignature = exports.AnyPublicKey = void 0;
const types_1 = require("../../types");
const authenticationKey_1 = require("../authenticationKey");
const ed25519_1 = require("./ed25519");
const publicKey_1 = require("./publicKey");
const secp256k1_1 = require("./secp256k1");
const signature_1 = require("./signature");
class AnyPublicKey extends publicKey_1.AccountPublicKey {
    constructor(publicKey) {
        super();
        this.publicKey = publicKey;
        if (publicKey instanceof ed25519_1.Ed25519PublicKey) {
            this.variant = types_1.AnyPublicKeyVariant.Ed25519;
        }
        else if (publicKey instanceof secp256k1_1.Secp256k1PublicKey) {
            this.variant = types_1.AnyPublicKeyVariant.Secp256k1;
        }
        else {
            throw new Error("Unsupported public key type");
        }
    }
    verifySignature(args) {
        const { message, signature } = args;
        if (!(signature instanceof AnySignature)) {
            return false;
        }
        return this.publicKey.verifySignature({
            message,
            signature: signature.signature,
        });
    }
    authKey() {
        return authenticationKey_1.AuthenticationKey.fromSchemeAndBytes({
            scheme: types_1.SigningScheme.SingleKey,
            input: this.toUint8Array(),
        });
    }
    toUint8Array() {
        return this.bcsToBytes();
    }
    serialize(serializer) {
        serializer.serializeU32AsUleb128(this.variant);
        this.publicKey.serialize(serializer);
    }
    static deserialize(deserializer) {
        const variantIndex = deserializer.deserializeUleb128AsU32();
        let publicKey;
        switch (variantIndex) {
            case types_1.AnyPublicKeyVariant.Ed25519:
                publicKey = ed25519_1.Ed25519PublicKey.deserialize(deserializer);
                break;
            case types_1.AnyPublicKeyVariant.Secp256k1:
                publicKey = secp256k1_1.Secp256k1PublicKey.deserialize(deserializer);
                break;
            default:
                throw new Error(`Unknown variant index for AnyPublicKey: ${variantIndex}`);
        }
        return new AnyPublicKey(publicKey);
    }
    static isPublicKey(publicKey) {
        return publicKey instanceof AnyPublicKey;
    }
    isEd25519() {
        return this.publicKey instanceof ed25519_1.Ed25519PublicKey;
    }
    isSecp256k1PublicKey() {
        return this.publicKey instanceof secp256k1_1.Secp256k1PublicKey;
    }
}
exports.AnyPublicKey = AnyPublicKey;
class AnySignature extends signature_1.Signature {
    constructor(signature) {
        super();
        this.signature = signature;
        if (signature instanceof ed25519_1.Ed25519Signature) {
            this.variant = types_1.AnySignatureVariant.Ed25519;
        }
        else if (signature instanceof secp256k1_1.Secp256k1Signature) {
            this.variant = types_1.AnySignatureVariant.Secp256k1;
        }
        else {
            throw new Error("Unsupported signature type");
        }
    }
    toUint8Array() {
        return this.bcsToBytes();
    }
    serialize(serializer) {
        serializer.serializeU32AsUleb128(this.variant);
        this.signature.serialize(serializer);
    }
    static deserialize(deserializer) {
        const variantIndex = deserializer.deserializeUleb128AsU32();
        let signature;
        switch (variantIndex) {
            case types_1.AnySignatureVariant.Ed25519:
                signature = ed25519_1.Ed25519Signature.deserialize(deserializer);
                break;
            case types_1.AnySignatureVariant.Secp256k1:
                signature = secp256k1_1.Secp256k1Signature.deserialize(deserializer);
                break;
            default:
                throw new Error(`Unknown variant index for AnySignature: ${variantIndex}`);
        }
        return new AnySignature(signature);
    }
}
exports.AnySignature = AnySignature;
//# sourceMappingURL=singleKey.js.map