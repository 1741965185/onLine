"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Secp256k1Signature = exports.Secp256k1PrivateKey = exports.Secp256k1PublicKey = void 0;
const sha3_1 = require("@noble/hashes/sha3");
const secp256k1_1 = require("@noble/curves/secp256k1");
const bip32_1 = require("@scure/bip32");
const bcs_1 = require("../../bcs");
const hex_1 = require("../hex");
const hdKey_1 = require("./hdKey");
const publicKey_1 = require("./publicKey");
const signature_1 = require("./signature");
const utils_1 = require("./utils");
class Secp256k1PublicKey extends publicKey_1.PublicKey {
    constructor(hexInput) {
        super();
        const hex = hex_1.Hex.fromHexInput(hexInput);
        if (hex.toUint8Array().length !== Secp256k1PublicKey.LENGTH) {
            throw new Error(`PublicKey length should be ${Secp256k1PublicKey.LENGTH}`);
        }
        this.key = hex;
    }
    verifySignature(args) {
        const { message, signature } = args;
        if (!(signature instanceof Secp256k1Signature)) {
            return false;
        }
        const messageToVerify = (0, utils_1.convertSigningMessage)(message);
        const messageBytes = hex_1.Hex.fromHexInput(messageToVerify).toUint8Array();
        const messageSha3Bytes = (0, sha3_1.sha3_256)(messageBytes);
        const signatureBytes = signature.toUint8Array();
        return secp256k1_1.secp256k1.verify(signatureBytes, messageSha3Bytes, this.key.toUint8Array(), { lowS: true });
    }
    toUint8Array() {
        return this.key.toUint8Array();
    }
    serialize(serializer) {
        serializer.serializeBytes(this.key.toUint8Array());
    }
    static deserialize(deserializer) {
        const bytes = deserializer.deserializeBytes();
        return new Secp256k1PublicKey(bytes);
    }
    static isPublicKey(publicKey) {
        return publicKey instanceof Secp256k1PublicKey;
    }
}
exports.Secp256k1PublicKey = Secp256k1PublicKey;
Secp256k1PublicKey.LENGTH = 65;
class Secp256k1PrivateKey extends bcs_1.Serializable {
    constructor(hexInput) {
        super();
        const privateKeyHex = hex_1.Hex.fromHexInput(hexInput);
        if (privateKeyHex.toUint8Array().length !== Secp256k1PrivateKey.LENGTH) {
            throw new Error(`PrivateKey length should be ${Secp256k1PrivateKey.LENGTH}`);
        }
        this.key = privateKeyHex;
    }
    static generate() {
        const hexInput = secp256k1_1.secp256k1.utils.randomPrivateKey();
        return new Secp256k1PrivateKey(hexInput);
    }
    static fromDerivationPath(path, mnemonics) {
        if (!(0, hdKey_1.isValidBIP44Path)(path)) {
            throw new Error(`Invalid derivation path ${path}`);
        }
        return Secp256k1PrivateKey.fromDerivationPathInner(path, (0, hdKey_1.mnemonicToSeed)(mnemonics));
    }
    static fromDerivationPathInner(path, seed) {
        const { privateKey } = bip32_1.HDKey.fromMasterSeed(seed).derive(path);
        if (privateKey === null) {
            throw new Error("Invalid key");
        }
        return new Secp256k1PrivateKey(privateKey);
    }
    sign(message) {
        const messageToSign = (0, utils_1.convertSigningMessage)(message);
        const messageBytes = hex_1.Hex.fromHexInput(messageToSign);
        const messageHashBytes = (0, sha3_1.sha3_256)(messageBytes.toUint8Array());
        const signature = secp256k1_1.secp256k1.sign(messageHashBytes, this.key.toUint8Array(), { lowS: true });
        return new Secp256k1Signature(signature.toCompactRawBytes());
    }
    publicKey() {
        const bytes = secp256k1_1.secp256k1.getPublicKey(this.key.toUint8Array(), false);
        return new Secp256k1PublicKey(bytes);
    }
    toUint8Array() {
        return this.key.toUint8Array();
    }
    toString() {
        return this.key.toString();
    }
    serialize(serializer) {
        serializer.serializeBytes(this.toUint8Array());
    }
    static deserialize(deserializer) {
        const bytes = deserializer.deserializeBytes();
        return new Secp256k1PrivateKey(bytes);
    }
    static isPrivateKey(privateKey) {
        return privateKey instanceof Secp256k1PrivateKey;
    }
}
exports.Secp256k1PrivateKey = Secp256k1PrivateKey;
Secp256k1PrivateKey.LENGTH = 32;
class Secp256k1Signature extends signature_1.Signature {
    constructor(hexInput) {
        super();
        const data = hex_1.Hex.fromHexInput(hexInput);
        if (data.toUint8Array().length !== Secp256k1Signature.LENGTH) {
            throw new Error(`Signature length should be ${Secp256k1Signature.LENGTH}, received ${data.toUint8Array().length}`);
        }
        this.data = data;
    }
    toUint8Array() {
        return this.data.toUint8Array();
    }
    serialize(serializer) {
        serializer.serializeBytes(this.data.toUint8Array());
    }
    static deserialize(deserializer) {
        const hex = deserializer.deserializeBytes();
        return new Secp256k1Signature(hex);
    }
}
exports.Secp256k1Signature = Secp256k1Signature;
Secp256k1Signature.LENGTH = 64;
//# sourceMappingURL=secp256k1.js.map