"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mnemonicToSeed = exports.splitPath = exports.CKDPriv = exports.deriveKey = exports.isValidHardenedPath = exports.isValidBIP44Path = exports.HARDENED_OFFSET = exports.KeyType = exports.APTOS_BIP44_REGEX = exports.APTOS_HARDENED_REGEX = void 0;
const hmac_1 = require("@noble/hashes/hmac");
const sha512_1 = require("@noble/hashes/sha512");
const bip39 = __importStar(require("@scure/bip39"));
exports.APTOS_HARDENED_REGEX = /^m\/44'\/637'\/[0-9]+'\/[0-9]+'\/[0-9]+'?$/;
exports.APTOS_BIP44_REGEX = /^m\/44'\/637'\/[0-9]+'\/[0-9]+\/[0-9]+$/;
var KeyType;
(function (KeyType) {
    KeyType["ED25519"] = "ed25519 seed";
})(KeyType = exports.KeyType || (exports.KeyType = {}));
exports.HARDENED_OFFSET = 0x80000000;
function isValidBIP44Path(path) {
    return exports.APTOS_BIP44_REGEX.test(path);
}
exports.isValidBIP44Path = isValidBIP44Path;
function isValidHardenedPath(path) {
    return exports.APTOS_HARDENED_REGEX.test(path);
}
exports.isValidHardenedPath = isValidHardenedPath;
const deriveKey = (hashSeed, data) => {
    const digest = hmac_1.hmac.create(sha512_1.sha512, hashSeed).update(data).digest();
    return {
        key: digest.slice(0, 32),
        chainCode: digest.slice(32),
    };
};
exports.deriveKey = deriveKey;
const CKDPriv = ({ key, chainCode }, index) => {
    const buffer = new ArrayBuffer(4);
    new DataView(buffer).setUint32(0, index);
    const indexBytes = new Uint8Array(buffer);
    const zero = new Uint8Array([0]);
    const data = new Uint8Array([...zero, ...key, ...indexBytes]);
    return (0, exports.deriveKey)(chainCode, data);
};
exports.CKDPriv = CKDPriv;
const removeApostrophes = (val) => val.replace("'", "");
const splitPath = (path) => path.split("/").slice(1).map(removeApostrophes);
exports.splitPath = splitPath;
const mnemonicToSeed = (mnemonic) => {
    const normalizedMnemonic = mnemonic
        .trim()
        .split(/\s+/)
        .map((part) => part.toLowerCase())
        .join(" ");
    return bip39.mnemonicToSeedSync(normalizedMnemonic);
};
exports.mnemonicToSeed = mnemonicToSeed;
//# sourceMappingURL=hdKey.js.map