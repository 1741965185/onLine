"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiKeySignature = exports.MultiKey = void 0;
const types_1 = require("../../types");
const authenticationKey_1 = require("../authenticationKey");
const publicKey_1 = require("./publicKey");
const signature_1 = require("./signature");
const singleKey_1 = require("./singleKey");
function bitCount(byte) {
    let n = byte;
    n -= (n >> 1) & 0x55555555;
    n = (n & 0x33333333) + ((n >> 2) & 0x33333333);
    return (((n + (n >> 4)) & 0xf0f0f0f) * 0x1010101) >> 24;
}
class MultiKey extends publicKey_1.AccountPublicKey {
    constructor(args) {
        super();
        const { publicKeys, signaturesRequired } = args;
        if (signaturesRequired < 1) {
            throw new Error("The number of required signatures needs to be greater than 0");
        }
        if (publicKeys.length < signaturesRequired) {
            throw new Error(`Provided ${publicKeys.length} public keys is smaller than the ${signaturesRequired} required signatures`);
        }
        this.publicKeys = publicKeys.map((publicKey) => publicKey instanceof singleKey_1.AnyPublicKey ? publicKey : new singleKey_1.AnyPublicKey(publicKey));
        this.signaturesRequired = signaturesRequired;
    }
    verifySignature(args) {
        throw new Error("not implemented");
    }
    authKey() {
        return authenticationKey_1.AuthenticationKey.fromSchemeAndBytes({
            scheme: types_1.SigningScheme.MultiKey,
            input: this.toUint8Array(),
        });
    }
    toUint8Array() {
        return this.bcsToBytes();
    }
    serialize(serializer) {
        serializer.serializeVector(this.publicKeys);
        serializer.serializeU8(this.signaturesRequired);
    }
    static deserialize(deserializer) {
        const keys = deserializer.deserializeVector(singleKey_1.AnyPublicKey);
        const signaturesRequired = deserializer.deserializeU8();
        return new MultiKey({ publicKeys: keys, signaturesRequired });
    }
    createBitmap(args) {
        const { bits } = args;
        const firstBitInByte = 128;
        const bitmap = new Uint8Array([0, 0, 0, 0]);
        const dupCheckSet = new Set();
        bits.forEach((bit, idx) => {
            if (idx + 1 > this.publicKeys.length) {
                throw new Error(`Signature index ${idx + 1} is out of public keys range, ${this.publicKeys.length}.`);
            }
            if (dupCheckSet.has(bit)) {
                throw new Error(`Duplicate bit ${bit} detected.`);
            }
            dupCheckSet.add(bit);
            const byteOffset = Math.floor(bit / 8);
            let byte = bitmap[byteOffset];
            byte |= firstBitInByte >> bit % 8;
            bitmap[byteOffset] = byte;
        });
        return bitmap;
    }
    getIndex(publicKey) {
        const anyPublicKey = publicKey instanceof singleKey_1.AnyPublicKey ? publicKey : new singleKey_1.AnyPublicKey(publicKey);
        const index = this.publicKeys.findIndex((pk) => pk.toString() === anyPublicKey.toString());
        if (index !== -1) {
            return index;
        }
        throw new Error("Public key not found in MultiKey");
    }
}
exports.MultiKey = MultiKey;
class MultiKeySignature extends signature_1.Signature {
    constructor(args) {
        super();
        const { signatures, bitmap } = args;
        if (signatures.length > MultiKeySignature.MAX_SIGNATURES_SUPPORTED) {
            throw new Error(`The number of signatures cannot be greater than ${MultiKeySignature.MAX_SIGNATURES_SUPPORTED}`);
        }
        this.signatures = signatures.map((signature) => signature instanceof singleKey_1.AnySignature ? signature : new singleKey_1.AnySignature(signature));
        if (!(bitmap instanceof Uint8Array)) {
            this.bitmap = MultiKeySignature.createBitmap({ bits: bitmap });
        }
        else if (bitmap.length !== MultiKeySignature.BITMAP_LEN) {
            throw new Error(`"bitmap" length should be ${MultiKeySignature.BITMAP_LEN}`);
        }
        else {
            this.bitmap = bitmap;
        }
        const nSignatures = this.bitmap.reduce((acc, byte) => acc + bitCount(byte), 0);
        if (nSignatures !== this.signatures.length) {
            throw new Error(`Expecting ${nSignatures} signatures from the bitmap, but got ${this.signatures.length}`);
        }
    }
    static createBitmap(args) {
        const { bits } = args;
        const firstBitInByte = 128;
        const bitmap = new Uint8Array([0, 0, 0, 0]);
        const dupCheckSet = new Set();
        bits.forEach((bit) => {
            if (bit >= MultiKeySignature.MAX_SIGNATURES_SUPPORTED) {
                throw new Error(`Cannot have a signature larger than ${MultiKeySignature.MAX_SIGNATURES_SUPPORTED - 1}.`);
            }
            if (dupCheckSet.has(bit)) {
                throw new Error("Duplicate bits detected.");
            }
            dupCheckSet.add(bit);
            const byteOffset = Math.floor(bit / 8);
            let byte = bitmap[byteOffset];
            byte |= firstBitInByte >> bit % 8;
            bitmap[byteOffset] = byte;
        });
        return bitmap;
    }
    toUint8Array() {
        return this.bcsToBytes();
    }
    serialize(serializer) {
        serializer.serializeVector(this.signatures);
        serializer.serializeBytes(this.bitmap);
    }
    static deserialize(deserializer) {
        const signatures = deserializer.deserializeVector(singleKey_1.AnySignature);
        const bitmap = deserializer.deserializeBytes();
        return new MultiKeySignature({ signatures, bitmap });
    }
}
exports.MultiKeySignature = MultiKeySignature;
MultiKeySignature.BITMAP_LEN = 4;
MultiKeySignature.MAX_SIGNATURES_SUPPORTED = MultiKeySignature.BITMAP_LEN * 8;
//# sourceMappingURL=multiKey.js.map