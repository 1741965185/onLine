"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountAddress = exports.AddressInvalidReason = void 0;
const utils_1 = require("@noble/hashes/utils");
const serializer_1 = require("../bcs/serializer");
const common_1 = require("./common");
const types_1 = require("../types");
var AddressInvalidReason;
(function (AddressInvalidReason) {
    AddressInvalidReason["INCORRECT_NUMBER_OF_BYTES"] = "incorrect_number_of_bytes";
    AddressInvalidReason["INVALID_HEX_CHARS"] = "invalid_hex_chars";
    AddressInvalidReason["TOO_SHORT"] = "too_short";
    AddressInvalidReason["TOO_LONG"] = "too_long";
    AddressInvalidReason["LEADING_ZERO_X_REQUIRED"] = "leading_zero_x_required";
    AddressInvalidReason["LONG_FORM_REQUIRED_UNLESS_SPECIAL"] = "long_form_required_unless_special";
    AddressInvalidReason["INVALID_PADDING_ZEROES"] = "INVALID_PADDING_ZEROES";
})(AddressInvalidReason = exports.AddressInvalidReason || (exports.AddressInvalidReason = {}));
class AccountAddress extends serializer_1.Serializable {
    constructor(input) {
        super();
        if (input.length !== AccountAddress.LENGTH) {
            throw new common_1.ParsingError("AccountAddress data should be exactly 32 bytes long", AddressInvalidReason.INCORRECT_NUMBER_OF_BYTES);
        }
        this.data = input;
    }
    isSpecial() {
        return (this.data.slice(0, this.data.length - 1).every((byte) => byte === 0) && this.data[this.data.length - 1] < 0b10000);
    }
    toString() {
        return `0x${this.toStringWithoutPrefix()}`;
    }
    toStringWithoutPrefix() {
        let hex = (0, utils_1.bytesToHex)(this.data);
        if (this.isSpecial()) {
            hex = hex[hex.length - 1];
        }
        return hex;
    }
    toStringLong() {
        return `0x${this.toStringLongWithoutPrefix()}`;
    }
    toStringLongWithoutPrefix() {
        return (0, utils_1.bytesToHex)(this.data);
    }
    toUint8Array() {
        return this.data;
    }
    serialize(serializer) {
        serializer.serializeFixedBytes(this.data);
    }
    serializeForEntryFunction(serializer) {
        const bcsBytes = this.bcsToBytes();
        serializer.serializeBytes(bcsBytes);
    }
    serializeForScriptFunction(serializer) {
        serializer.serializeU32AsUleb128(types_1.ScriptTransactionArgumentVariants.Address);
        serializer.serialize(this);
    }
    static deserialize(deserializer) {
        const bytes = deserializer.deserializeFixedBytes(AccountAddress.LENGTH);
        return new AccountAddress(bytes);
    }
    static fromStringStrict(input) {
        if (!input.startsWith("0x")) {
            throw new common_1.ParsingError("Hex string must start with a leading 0x.", AddressInvalidReason.LEADING_ZERO_X_REQUIRED);
        }
        const address = AccountAddress.fromString(input);
        if (input.length !== AccountAddress.LONG_STRING_LENGTH + 2) {
            if (!address.isSpecial()) {
                throw new common_1.ParsingError(`The given hex string ${input} is not a special address, it must be represented as 0x + 64 chars.`, AddressInvalidReason.LONG_FORM_REQUIRED_UNLESS_SPECIAL);
            }
            else if (input.length !== 3) {
                throw new common_1.ParsingError(`The given hex string ${input} is a special address not in LONG form, it must be 0x0 to 0xf without padding zeroes.`, AddressInvalidReason.INVALID_PADDING_ZEROES);
            }
        }
        return address;
    }
    static fromString(input) {
        let parsedInput = input;
        if (input.startsWith("0x")) {
            parsedInput = input.slice(2);
        }
        if (parsedInput.length === 0) {
            throw new common_1.ParsingError("Hex string is too short, must be 1 to 64 chars long, excluding the leading 0x.", AddressInvalidReason.TOO_SHORT);
        }
        if (parsedInput.length > 64) {
            throw new common_1.ParsingError("Hex string is too long, must be 1 to 64 chars long, excluding the leading 0x.", AddressInvalidReason.TOO_LONG);
        }
        let addressBytes;
        try {
            addressBytes = (0, utils_1.hexToBytes)(parsedInput.padStart(64, "0"));
        }
        catch (error) {
            throw new common_1.ParsingError(`Hex characters are invalid: ${error?.message}`, AddressInvalidReason.INVALID_HEX_CHARS);
        }
        return new AccountAddress(addressBytes);
    }
    static from(input) {
        if (input instanceof AccountAddress) {
            return input;
        }
        if (input instanceof Uint8Array) {
            return new AccountAddress(input);
        }
        return AccountAddress.fromString(input);
    }
    static fromStrict(input) {
        if (input instanceof AccountAddress) {
            return input;
        }
        if (input instanceof Uint8Array) {
            return new AccountAddress(input);
        }
        return AccountAddress.fromStringStrict(input);
    }
    static isValid(args) {
        try {
            if (args.strict) {
                AccountAddress.fromStrict(args.input);
            }
            else {
                AccountAddress.from(args.input);
            }
            return { valid: true };
        }
        catch (error) {
            return {
                valid: false,
                invalidReason: error?.invalidReason,
                invalidReasonMessage: error?.message,
            };
        }
    }
    equals(other) {
        if (this.data.length !== other.data.length)
            return false;
        return this.data.every((value, index) => value === other.data[index]);
    }
}
exports.AccountAddress = AccountAddress;
AccountAddress.LENGTH = 32;
AccountAddress.LONG_STRING_LENGTH = 64;
AccountAddress.ZERO = AccountAddress.from("0x0");
AccountAddress.ONE = AccountAddress.from("0x1");
AccountAddress.TWO = AccountAddress.from("0x2");
AccountAddress.THREE = AccountAddress.from("0x3");
AccountAddress.FOUR = AccountAddress.from("0x4");
//# sourceMappingURL=accountAddress.js.map