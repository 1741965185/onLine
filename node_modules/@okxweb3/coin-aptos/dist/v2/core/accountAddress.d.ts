import { Serializable, Serializer } from "../bcs/serializer";
import { Deserializer } from "../bcs/deserializer";
import { ParsingResult } from "./common";
import { TransactionArgument } from "../transactions/instances/transactionArgument";
import { HexInput } from "../types";
export declare enum AddressInvalidReason {
    INCORRECT_NUMBER_OF_BYTES = "incorrect_number_of_bytes",
    INVALID_HEX_CHARS = "invalid_hex_chars",
    TOO_SHORT = "too_short",
    TOO_LONG = "too_long",
    LEADING_ZERO_X_REQUIRED = "leading_zero_x_required",
    LONG_FORM_REQUIRED_UNLESS_SPECIAL = "long_form_required_unless_special",
    INVALID_PADDING_ZEROES = "INVALID_PADDING_ZEROES"
}
export type AccountAddressInput = HexInput | AccountAddress;
export declare class AccountAddress extends Serializable implements TransactionArgument {
    readonly data: Uint8Array;
    static readonly LENGTH: number;
    static readonly LONG_STRING_LENGTH: number;
    static ZERO: AccountAddress;
    static ONE: AccountAddress;
    static TWO: AccountAddress;
    static THREE: AccountAddress;
    static FOUR: AccountAddress;
    constructor(input: Uint8Array);
    isSpecial(): boolean;
    toString(): `0x${string}`;
    toStringWithoutPrefix(): string;
    toStringLong(): `0x${string}`;
    toStringLongWithoutPrefix(): string;
    toUint8Array(): Uint8Array;
    serialize(serializer: Serializer): void;
    serializeForEntryFunction(serializer: Serializer): void;
    serializeForScriptFunction(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): AccountAddress;
    static fromStringStrict(input: string): AccountAddress;
    static fromString(input: string): AccountAddress;
    static from(input: AccountAddressInput): AccountAddress;
    static fromStrict(input: AccountAddressInput): AccountAddress;
    static isValid(args: {
        input: AccountAddressInput;
        strict?: boolean;
    }): ParsingResult<AddressInvalidReason>;
    equals(other: AccountAddress): boolean;
}
