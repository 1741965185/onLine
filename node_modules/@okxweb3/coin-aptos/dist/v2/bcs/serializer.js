"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateNumberInRange = exports.outOfRangeErrorMessage = exports.ensureBoolean = exports.Serializer = exports.Serializable = void 0;
const consts_1 = require("./consts");
const hex_1 = require("../core/hex");
class Serializable {
    bcsToBytes() {
        const serializer = new Serializer();
        this.serialize(serializer);
        return serializer.toUint8Array();
    }
    bcsToHex() {
        const bcsBytes = this.bcsToBytes();
        return hex_1.Hex.fromHexInput(bcsBytes);
    }
}
exports.Serializable = Serializable;
class Serializer {
    constructor(length = 64) {
        if (length <= 0) {
            throw new Error("Length needs to be greater than 0");
        }
        this.buffer = new ArrayBuffer(length);
        this.offset = 0;
    }
    ensureBufferWillHandleSize(bytes) {
        while (this.buffer.byteLength < this.offset + bytes) {
            const newBuffer = new ArrayBuffer(this.buffer.byteLength * 2);
            new Uint8Array(newBuffer).set(new Uint8Array(this.buffer));
            this.buffer = newBuffer;
        }
    }
    appendToBuffer(values) {
        this.ensureBufferWillHandleSize(values.length);
        new Uint8Array(this.buffer, this.offset).set(values);
        this.offset += values.length;
    }
    serializeWithFunction(fn, bytesLength, value) {
        this.ensureBufferWillHandleSize(bytesLength);
        const dv = new DataView(this.buffer, this.offset);
        fn.apply(dv, [0, value, true]);
        this.offset += bytesLength;
    }
    serializeStr(value) {
        const textEncoder = new TextEncoder();
        this.serializeBytes(textEncoder.encode(value));
    }
    serializeBytes(value) {
        this.serializeU32AsUleb128(value.length);
        this.appendToBuffer(value);
    }
    serializeFixedBytes(value) {
        this.appendToBuffer(value);
    }
    serializeBool(value) {
        ensureBoolean(value);
        const byteValue = value ? 1 : 0;
        this.appendToBuffer(new Uint8Array([byteValue]));
    }
    serializeU8(value) {
        this.appendToBuffer(new Uint8Array([value]));
    }
    serializeU16(value) {
        this.serializeWithFunction(DataView.prototype.setUint16, 2, value);
    }
    serializeU32(value) {
        this.serializeWithFunction(DataView.prototype.setUint32, 4, value);
    }
    serializeU64(value) {
        const low = BigInt(value) & BigInt(consts_1.MAX_U32_NUMBER);
        const high = BigInt(value) >> BigInt(32);
        this.serializeU32(Number(low));
        this.serializeU32(Number(high));
    }
    serializeU128(value) {
        const low = BigInt(value) & consts_1.MAX_U64_BIG_INT;
        const high = BigInt(value) >> BigInt(64);
        this.serializeU64(low);
        this.serializeU64(high);
    }
    serializeU256(value) {
        const low = BigInt(value) & consts_1.MAX_U128_BIG_INT;
        const high = BigInt(value) >> BigInt(128);
        this.serializeU128(low);
        this.serializeU128(high);
    }
    serializeU32AsUleb128(val) {
        let value = val;
        const valueArray = [];
        while (value >>> 7 !== 0) {
            valueArray.push((value & 0x7f) | 0x80);
            value >>>= 7;
        }
        valueArray.push(value);
        this.appendToBuffer(new Uint8Array(valueArray));
    }
    toUint8Array() {
        return new Uint8Array(this.buffer).slice(0, this.offset);
    }
    serialize(value) {
        value.serialize(this);
    }
    serializeVector(values) {
        this.serializeU32AsUleb128(values.length);
        values.forEach((item) => {
            item.serialize(this);
        });
    }
}
__decorate([
    checkNumberRange(0, consts_1.MAX_U8_NUMBER)
], Serializer.prototype, "serializeU8", null);
__decorate([
    checkNumberRange(0, consts_1.MAX_U16_NUMBER)
], Serializer.prototype, "serializeU16", null);
__decorate([
    checkNumberRange(0, consts_1.MAX_U32_NUMBER)
], Serializer.prototype, "serializeU32", null);
__decorate([
    checkNumberRange(BigInt(0), consts_1.MAX_U64_BIG_INT)
], Serializer.prototype, "serializeU64", null);
__decorate([
    checkNumberRange(BigInt(0), consts_1.MAX_U128_BIG_INT)
], Serializer.prototype, "serializeU128", null);
__decorate([
    checkNumberRange(BigInt(0), consts_1.MAX_U256_BIG_INT)
], Serializer.prototype, "serializeU256", null);
__decorate([
    checkNumberRange(0, consts_1.MAX_U32_NUMBER)
], Serializer.prototype, "serializeU32AsUleb128", null);
exports.Serializer = Serializer;
function ensureBoolean(value) {
    if (typeof value !== "boolean") {
        throw new Error(`${value} is not a boolean value`);
    }
}
exports.ensureBoolean = ensureBoolean;
const outOfRangeErrorMessage = (value, min, max) => `${value} is out of range: [${min}, ${max}]`;
exports.outOfRangeErrorMessage = outOfRangeErrorMessage;
function validateNumberInRange(value, minValue, maxValue) {
    const valueBigInt = BigInt(value);
    if (valueBigInt > BigInt(maxValue) || valueBigInt < BigInt(minValue)) {
        throw new Error((0, exports.outOfRangeErrorMessage)(value, minValue, maxValue));
    }
}
exports.validateNumberInRange = validateNumberInRange;
function checkNumberRange(minValue, maxValue) {
    return (target, propertyKey, descriptor) => {
        const childFunction = descriptor.value;
        descriptor.value = function deco(value) {
            validateNumberInRange(value, minValue, maxValue);
            return childFunction.apply(this, [value]);
        };
        return descriptor;
    };
}
//# sourceMappingURL=serializer.js.map