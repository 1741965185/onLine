"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MoveOption = exports.MoveString = exports.MoveVector = void 0;
const movePrimitives_1 = require("./movePrimitives");
const serializer_1 = require("../serializer");
const types_1 = require("../../types");
const hex_1 = require("../../core/hex");
class MoveVector extends serializer_1.Serializable {
    constructor(values) {
        super();
        this.values = values;
    }
    serializeForEntryFunction(serializer) {
        const bcsBytes = this.bcsToBytes();
        serializer.serializeBytes(bcsBytes);
    }
    serializeForScriptFunction(serializer) {
        const isU8 = this.values[0] instanceof movePrimitives_1.U8;
        if (!isU8 && this.values[0] !== undefined) {
            throw new Error("Script function arguments only accept u8 vectors");
        }
        serializer.serializeU32AsUleb128(types_1.ScriptTransactionArgumentVariants.U8Vector);
        serializer.serialize(this);
    }
    static U8(values) {
        let numbers;
        if (Array.isArray(values) && typeof values[0] === "number") {
            numbers = values;
        }
        else if (typeof values === "string") {
            const hex = hex_1.Hex.fromHexInput(values);
            numbers = Array.from(hex.toUint8Array());
        }
        else if (values instanceof Uint8Array) {
            numbers = Array.from(values);
        }
        else {
            throw new Error("Invalid input type");
        }
        return new MoveVector(numbers.map((v) => new movePrimitives_1.U8(v)));
    }
    static U16(values) {
        return new MoveVector(values.map((v) => new movePrimitives_1.U16(v)));
    }
    static U32(values) {
        return new MoveVector(values.map((v) => new movePrimitives_1.U32(v)));
    }
    static U64(values) {
        return new MoveVector(values.map((v) => new movePrimitives_1.U64(v)));
    }
    static U128(values) {
        return new MoveVector(values.map((v) => new movePrimitives_1.U128(v)));
    }
    static U256(values) {
        return new MoveVector(values.map((v) => new movePrimitives_1.U256(v)));
    }
    static Bool(values) {
        return new MoveVector(values.map((v) => new movePrimitives_1.Bool(v)));
    }
    static MoveString(values) {
        return new MoveVector(values.map((v) => new MoveString(v)));
    }
    serialize(serializer) {
        serializer.serializeVector(this.values);
    }
    static deserialize(deserializer, cls) {
        const length = deserializer.deserializeUleb128AsU32();
        const values = new Array();
        for (let i = 0; i < length; i += 1) {
            values.push(cls.deserialize(deserializer));
        }
        return new MoveVector(values);
    }
}
exports.MoveVector = MoveVector;
class MoveString extends serializer_1.Serializable {
    constructor(value) {
        super();
        this.value = value;
    }
    serialize(serializer) {
        serializer.serializeStr(this.value);
    }
    serializeForEntryFunction(serializer) {
        const bcsBytes = this.bcsToBytes();
        serializer.serializeBytes(bcsBytes);
    }
    serializeForScriptFunction(serializer) {
        const fixedStringBytes = this.bcsToBytes().slice(1);
        const vectorU8 = MoveVector.U8(fixedStringBytes);
        vectorU8.serializeForScriptFunction(serializer);
    }
    static deserialize(deserializer) {
        return new MoveString(deserializer.deserializeStr());
    }
}
exports.MoveString = MoveString;
class MoveOption extends serializer_1.Serializable {
    constructor(value) {
        super();
        if (typeof value !== "undefined" && value !== null) {
            this.vec = new MoveVector([value]);
        }
        else {
            this.vec = new MoveVector([]);
        }
        [this.value] = this.vec.values;
    }
    serializeForEntryFunction(serializer) {
        const bcsBytes = this.bcsToBytes();
        serializer.serializeBytes(bcsBytes);
    }
    unwrap() {
        if (!this.isSome()) {
            throw new Error("Called unwrap on a MoveOption with no value");
        }
        else {
            return this.vec.values[0];
        }
    }
    isSome() {
        return this.vec.values.length === 1;
    }
    serialize(serializer) {
        this.vec.serialize(serializer);
    }
    static U8(value) {
        return new MoveOption(value !== null && value !== undefined ? new movePrimitives_1.U8(value) : undefined);
    }
    static U16(value) {
        return new MoveOption(value !== null && value !== undefined ? new movePrimitives_1.U16(value) : undefined);
    }
    static U32(value) {
        return new MoveOption(value !== null && value !== undefined ? new movePrimitives_1.U32(value) : undefined);
    }
    static U64(value) {
        return new MoveOption(value !== null && value !== undefined ? new movePrimitives_1.U64(value) : undefined);
    }
    static U128(value) {
        return new MoveOption(value !== null && value !== undefined ? new movePrimitives_1.U128(value) : undefined);
    }
    static U256(value) {
        return new MoveOption(value !== null && value !== undefined ? new movePrimitives_1.U256(value) : undefined);
    }
    static Bool(value) {
        return new MoveOption(value !== null && value !== undefined ? new movePrimitives_1.Bool(value) : undefined);
    }
    static MoveString(value) {
        return new MoveOption(value !== null && value !== undefined ? new MoveString(value) : undefined);
    }
    static deserialize(deserializer, cls) {
        const vector = MoveVector.deserialize(deserializer, cls);
        return new MoveOption(vector.values[0]);
    }
}
exports.MoveOption = MoveOption;
//# sourceMappingURL=moveStructs.js.map