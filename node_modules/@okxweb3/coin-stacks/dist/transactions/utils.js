"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addHex = exports.postConditionFromString = exports.hexToBuff = exports.validateTxId = exports.validateStacksAddress = exports.parseReadOnlyResponse = exports.hexToCV = exports.cvToHex = exports.isClarityName = exports.hashP2WSH = exports.hashP2SH = exports.hashP2WPKH = exports.hashP2PKH = exports.hash160 = exports.txidFromData = exports.omit = exports.cloneDeep = exports.exceedsMaxLengthBytes = exports.rightPadHexToLength = exports.leftPadHexToLength = exports.leftPadHex = exports.randomBytes = void 0;
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const common_1 = require("../common");
const c32check_1 = require("../c32check");
const deepclone_1 = __importDefault(require("./clarity/deepclone"));
const clarity_1 = require("./clarity");
const index_1 = require("./index");
const randomBytes = (bytesLength) => crypto_lib_1.base.randomBytes(Number(bytesLength));
exports.randomBytes = randomBytes;
const leftPadHex = (hexString) => hexString.length % 2 == 0 ? hexString : `0${hexString}`;
exports.leftPadHex = leftPadHex;
const leftPadHexToLength = (hexString, length) => hexString.padStart(length, '0');
exports.leftPadHexToLength = leftPadHexToLength;
const rightPadHexToLength = (hexString, length) => hexString.padEnd(length, '0');
exports.rightPadHexToLength = rightPadHexToLength;
const exceedsMaxLengthBytes = (string, maxLengthBytes) => string ? (0, common_1.utf8ToBytes)(string).length > maxLengthBytes : false;
exports.exceedsMaxLengthBytes = exceedsMaxLengthBytes;
function cloneDeep(obj) {
    return (0, deepclone_1.default)(obj);
}
exports.cloneDeep = cloneDeep;
function omit(obj, prop) {
    const clone = cloneDeep(obj);
    delete clone[prop];
    return clone;
}
exports.omit = omit;
const txidFromData = (data) => {
    return (0, common_1.bytesToHex)(crypto_lib_1.base.sha512_256(data));
};
exports.txidFromData = txidFromData;
const hash160 = (input) => {
    return crypto_lib_1.base.ripemd160(crypto_lib_1.base.sha256(input));
};
exports.hash160 = hash160;
const hashP2PKH = (input) => {
    return (0, common_1.bytesToHex)((0, exports.hash160)(input));
};
exports.hashP2PKH = hashP2PKH;
const hashP2WPKH = (input) => {
    const keyHash = (0, exports.hash160)(input);
    const redeemScript = (0, common_1.concatBytes)(new Uint8Array([0]), new Uint8Array([keyHash.length]), keyHash);
    const redeemScriptHash = (0, exports.hash160)(redeemScript);
    return (0, common_1.bytesToHex)(redeemScriptHash);
};
exports.hashP2WPKH = hashP2WPKH;
const hashP2SH = (numSigs, pubKeys) => {
    if (numSigs > 15 || pubKeys.length > 15) {
        throw Error('P2SH multisig address can only contain up to 15 public keys');
    }
    const bytesArray = [];
    bytesArray.push(80 + numSigs);
    pubKeys.forEach(pubKey => {
        bytesArray.push(pubKey.length);
        bytesArray.push(pubKey);
    });
    bytesArray.push(80 + pubKeys.length);
    bytesArray.push(174);
    const redeemScript = (0, common_1.concatArray)(bytesArray);
    const redeemScriptHash = (0, exports.hash160)(redeemScript);
    return (0, common_1.bytesToHex)(redeemScriptHash);
};
exports.hashP2SH = hashP2SH;
const hashP2WSH = (numSigs, pubKeys) => {
    if (numSigs > 15 || pubKeys.length > 15) {
        throw Error('P2WSH multisig address can only contain up to 15 public keys');
    }
    const scriptArray = [];
    scriptArray.push(80 + numSigs);
    pubKeys.forEach(pubKey => {
        scriptArray.push(pubKey.length);
        scriptArray.push(pubKey);
    });
    scriptArray.push(80 + pubKeys.length);
    scriptArray.push(174);
    const script = (0, common_1.concatArray)(scriptArray);
    const digest = crypto_lib_1.base.sha256(script);
    const bytesArray = [];
    bytesArray.push(0);
    bytesArray.push(digest.length);
    bytesArray.push(digest);
    const redeemScript = (0, common_1.concatArray)(bytesArray);
    const redeemScriptHash = (0, exports.hash160)(redeemScript);
    return (0, common_1.bytesToHex)(redeemScriptHash);
};
exports.hashP2WSH = hashP2WSH;
function isClarityName(name) {
    const regex = /^[a-zA-Z]([a-zA-Z0-9]|[-_!?+<>=/*])*$|^[-+=/*]$|^[<>]=?$/;
    return regex.test(name) && name.length < 128;
}
exports.isClarityName = isClarityName;
function cvToHex(cv) {
    const serialized = (0, clarity_1.serializeCV)(cv);
    return `0x${(0, common_1.bytesToHex)(serialized)}`;
}
exports.cvToHex = cvToHex;
function hexToCV(hex) {
    return (0, clarity_1.deserializeCV)(hex);
}
exports.hexToCV = hexToCV;
const parseReadOnlyResponse = (response) => {
    if (response.okay)
        return hexToCV(response.result);
    throw new Error(response.cause);
};
exports.parseReadOnlyResponse = parseReadOnlyResponse;
const validateStacksAddress = (stacksAddress) => {
    try {
        (0, c32check_1.c32addressDecode)(stacksAddress);
        return true;
    }
    catch (e) {
        return false;
    }
};
exports.validateStacksAddress = validateStacksAddress;
const validateTxId = (txid) => {
    if (txid === 'success')
        return true;
    const value = (0, common_1.with0x)(txid).toLowerCase();
    if (value.length !== 66)
        return false;
    return (0, common_1.with0x)(BigInt(value).toString(16).padStart(64, '0')) === value;
};
exports.validateTxId = validateTxId;
function hexToBuff(hex) {
    return Buffer.from(cleanHex(hex), 'hex');
}
exports.hexToBuff = hexToBuff;
function cleanHex(hexWithMaybePrefix) {
    return hexWithMaybePrefix.startsWith('0x')
        ? hexWithMaybePrefix.replace('0x', '')
        : hexWithMaybePrefix;
}
function postConditionFromString(postCondition) {
    const reader = new index_1.BytesReader((0, common_1.hexToBytes)(postCondition));
    return (0, index_1.deserializePostCondition)(reader);
}
exports.postConditionFromString = postConditionFromString;
function addHex(hexWithOutPrefix) {
    return hexWithOutPrefix.startsWith('0x') ? hexWithOutPrefix : `0x${hexWithOutPrefix}`;
}
exports.addHex = addHex;
//# sourceMappingURL=utils.js.map