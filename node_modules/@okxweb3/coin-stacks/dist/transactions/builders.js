"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeContractDeploy = exports.makeUnsignedContractDeploy = exports.estimateTransactionByteLength = exports.makeContractNonFungiblePostCondition = exports.makeStandardNonFungiblePostCondition = exports.makeContractFungiblePostCondition = exports.makeStandardFungiblePostCondition = exports.makeContractSTXPostCondition = exports.makeStandardSTXPostCondition = exports.makeContractCall = exports.makeUnsignedContractCall = void 0;
const common_1 = require("../common");
const network_1 = require("../network");
const authorization_1 = require("./authorization");
const constants_1 = require("./constants");
const keys_1 = require("./keys");
const payload_1 = require("./payload");
const postcondition_1 = require("./postcondition");
const postcondition_types_1 = require("./postcondition-types");
const signer_1 = require("./signer");
const transaction_1 = require("./transaction");
const types_1 = require("./types");
const utils_1 = require("./utils");
function deriveNetwork(transaction) {
    switch (transaction.version) {
        case constants_1.TransactionVersion.Mainnet:
            return new network_1.StacksMainnet();
        case constants_1.TransactionVersion.Testnet:
            return new network_1.StacksTestnet();
    }
}
async function makeUnsignedContractCall(txOptions) {
    const defaultOptions = {
        fee: BigInt(0),
        nonce: BigInt(0),
        network: new network_1.StacksMainnet(),
        postConditionMode: constants_1.PostConditionMode.Deny,
        sponsored: false,
    };
    const options = Object.assign(defaultOptions, txOptions);
    const payload = (0, payload_1.createContractCallPayload)(options.contractAddress, options.contractName, options.functionName, options.functionArgs);
    let spendingCondition = null;
    let authorization = null;
    if ('publicKey' in options) {
        spendingCondition = (0, authorization_1.createSingleSigSpendingCondition)(constants_1.AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);
    }
    else {
        spendingCondition = (0, authorization_1.createMultiSigSpendingCondition)(constants_1.AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);
    }
    if (options.sponsored) {
        authorization = (0, authorization_1.createSponsoredAuth)(spendingCondition);
    }
    else {
        authorization = (0, authorization_1.createStandardAuth)(spendingCondition);
    }
    const network = network_1.StacksNetwork.fromNameOrNetwork(options.network);
    const postConditions = [];
    if (options.postConditions && options.postConditions.length > 0) {
        options.postConditions.forEach(postCondition => {
            postConditions.push(postCondition);
        });
    }
    const lpPostConditions = (0, types_1.createLPList)(postConditions);
    const transaction = new transaction_1.StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);
    return transaction;
}
exports.makeUnsignedContractCall = makeUnsignedContractCall;
async function makeContractCall(txOptions) {
    if ('senderKey' in txOptions) {
        const publicKey = (0, keys_1.publicKeyToString)((0, keys_1.getPublicKey)((0, keys_1.createStacksPrivateKey)(txOptions.senderKey)));
        const options = (0, utils_1.omit)(txOptions, 'senderKey');
        const transaction = await makeUnsignedContractCall({ publicKey, ...options });
        const privKey = (0, keys_1.createStacksPrivateKey)(txOptions.senderKey);
        const signer = new signer_1.TransactionSigner(transaction);
        signer.signOrigin(privKey);
        return transaction;
    }
    else {
        const options = (0, utils_1.omit)(txOptions, 'signerKeys');
        const transaction = await makeUnsignedContractCall(options);
        const signer = new signer_1.TransactionSigner(transaction);
        let pubKeys = txOptions.publicKeys;
        for (const key of txOptions.signerKeys) {
            const pubKey = (0, keys_1.pubKeyfromPrivKey)(key);
            pubKeys = pubKeys.filter(pk => pk !== (0, common_1.bytesToHex)(pubKey.data));
            signer.signOrigin((0, keys_1.createStacksPrivateKey)(key));
        }
        for (const key of pubKeys) {
            signer.appendOrigin((0, keys_1.publicKeyFromBytes)((0, common_1.hexToBytes)(key)));
        }
        return transaction;
    }
}
exports.makeContractCall = makeContractCall;
function makeStandardSTXPostCondition(address, conditionCode, amount) {
    return (0, postcondition_1.createSTXPostCondition)((0, postcondition_types_1.createStandardPrincipal)(address), conditionCode, amount);
}
exports.makeStandardSTXPostCondition = makeStandardSTXPostCondition;
function makeContractSTXPostCondition(address, contractName, conditionCode, amount) {
    return (0, postcondition_1.createSTXPostCondition)((0, postcondition_types_1.createContractPrincipal)(address, contractName), conditionCode, amount);
}
exports.makeContractSTXPostCondition = makeContractSTXPostCondition;
function makeStandardFungiblePostCondition(address, conditionCode, amount, assetInfo) {
    return (0, postcondition_1.createFungiblePostCondition)((0, postcondition_types_1.createStandardPrincipal)(address), conditionCode, amount, assetInfo);
}
exports.makeStandardFungiblePostCondition = makeStandardFungiblePostCondition;
function makeContractFungiblePostCondition(address, contractName, conditionCode, amount, assetInfo) {
    return (0, postcondition_1.createFungiblePostCondition)((0, postcondition_types_1.createContractPrincipal)(address, contractName), conditionCode, amount, assetInfo);
}
exports.makeContractFungiblePostCondition = makeContractFungiblePostCondition;
function makeStandardNonFungiblePostCondition(address, conditionCode, assetInfo, assetId) {
    return (0, postcondition_1.createNonFungiblePostCondition)((0, postcondition_types_1.createStandardPrincipal)(address), conditionCode, assetInfo, assetId);
}
exports.makeStandardNonFungiblePostCondition = makeStandardNonFungiblePostCondition;
function makeContractNonFungiblePostCondition(address, contractName, conditionCode, assetInfo, assetId) {
    return (0, postcondition_1.createNonFungiblePostCondition)((0, postcondition_types_1.createContractPrincipal)(address, contractName), conditionCode, assetInfo, assetId);
}
exports.makeContractNonFungiblePostCondition = makeContractNonFungiblePostCondition;
function estimateTransactionByteLength(transaction) {
    const hashMode = transaction.auth.spendingCondition.hashMode;
    const multiSigHashModes = [constants_1.AddressHashMode.SerializeP2SH, constants_1.AddressHashMode.SerializeP2WSH];
    if (multiSigHashModes.includes(hashMode)) {
        const multiSigSpendingCondition = transaction.auth
            .spendingCondition;
        const existingSignatures = multiSigSpendingCondition.fields.filter(field => field.contents.type === constants_1.StacksMessageType.MessageSignature).length;
        const totalSignatureLength = (multiSigSpendingCondition.signaturesRequired - existingSignatures) *
            (constants_1.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES + 1);
        return transaction.serialize().byteLength + totalSignatureLength;
    }
    else {
        return transaction.serialize().byteLength;
    }
}
exports.estimateTransactionByteLength = estimateTransactionByteLength;
async function makeUnsignedContractDeploy(txOptions) {
    const defaultOptions = {
        fee: BigInt(0),
        nonce: BigInt(0),
        network: new network_1.StacksMainnet(),
        postConditionMode: constants_1.PostConditionMode.Deny,
        sponsored: false,
        clarityVersion: constants_1.ClarityVersion.Clarity2,
    };
    const options = Object.assign(defaultOptions, txOptions);
    const payload = (0, payload_1.createSmartContractPayload)(options.contractName, options.codeBody, options.clarityVersion);
    const addressHashMode = constants_1.AddressHashMode.SerializeP2PKH;
    const pubKey = (0, keys_1.createStacksPublicKey)(options.publicKey);
    let authorization = null;
    const spendingCondition = (0, authorization_1.createSingleSigSpendingCondition)(addressHashMode, (0, keys_1.publicKeyToString)(pubKey), options.nonce, options.fee);
    if (options.sponsored) {
        authorization = (0, authorization_1.createSponsoredAuth)(spendingCondition);
    }
    else {
        authorization = (0, authorization_1.createStandardAuth)(spendingCondition);
    }
    const network = network_1.StacksNetwork.fromNameOrNetwork(options.network);
    const postConditions = [];
    if (options.postConditions && options.postConditions.length > 0) {
        options.postConditions.forEach(postCondition => {
            postConditions.push(postCondition);
        });
    }
    const lpPostConditions = (0, types_1.createLPList)(postConditions);
    const transaction = new transaction_1.StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);
    return transaction;
}
exports.makeUnsignedContractDeploy = makeUnsignedContractDeploy;
async function makeContractDeploy(txOptions) {
    const privKey = (0, keys_1.createStacksPrivateKey)(txOptions.senderKey);
    const stacksPublicKey = (0, keys_1.getPublicKey)(privKey);
    const publicKey = (0, keys_1.publicKeyToString)(stacksPublicKey);
    const unsignedTxOptions = { ...txOptions, publicKey };
    const transaction = await makeUnsignedContractDeploy(unsignedTxOptions);
    if (txOptions.senderKey) {
        const signer = new signer_1.TransactionSigner(transaction);
        signer.signOrigin(privKey);
    }
    return transaction;
}
exports.makeContractDeploy = makeContractDeploy;
//# sourceMappingURL=builders.js.map