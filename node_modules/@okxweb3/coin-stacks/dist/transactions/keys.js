"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.publicKeyToAddress = exports.privateKeyToString = exports.getPublicKey = exports.signMessageHashRsv = exports.signWithKey = exports.makeRandomPrivKey = exports.createStacksPrivateKey = exports.deserializePublicKey = exports.compressPublicKey = exports.pubKeyfromPrivKey = exports.serializePublicKey = exports.publicKeyToString = exports.isCompressed = exports.publicKeyFromBytes = exports.publicKeyFromSignatureRsv = exports.publicKeyFromSignatureVrs = exports.createStacksPublicKey = exports.getAddressFromPublicKey = exports.getAddressFromPrivateKey = void 0;
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const nobleGetPublicKey = crypto_lib_1.secp256k1.getPublicKey;
const Point = crypto_lib_1.secp256k1.Point;
const Signature = crypto_lib_1.secp256k1.Signature;
const signSync = crypto_lib_1.secp256k1.signSync;
const utils = crypto_lib_1.secp256k1.utils;
const common_1 = require("../common");
const c32check_1 = require("../c32check");
const common_2 = require("./common");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
utils.hmacSha256Sync = (key, ...msgs) => {
    const h = crypto_lib_1.base.hmac.create(crypto_lib_1.base.sha256, key);
    msgs.forEach(msg => h.update(msg));
    return h.digest();
};
function getAddressFromPrivateKey(privateKey, transactionVersion = constants_1.TransactionVersion.Mainnet) {
    const pubKey = pubKeyfromPrivKey(privateKey);
    return getAddressFromPublicKey(pubKey.data, transactionVersion);
}
exports.getAddressFromPrivateKey = getAddressFromPrivateKey;
function getAddressFromPublicKey(publicKey, transactionVersion = constants_1.TransactionVersion.Mainnet) {
    publicKey = typeof publicKey === 'string' ? publicKey : (0, common_1.bytesToHex)(publicKey);
    const addrVer = (0, common_2.addressHashModeToVersion)(constants_1.AddressHashMode.SerializeP2PKH, transactionVersion);
    const addr = (0, common_2.addressFromVersionHash)(addrVer, (0, utils_1.hashP2PKH)((0, common_1.hexToBytes)(publicKey)));
    const addrString = (0, common_2.addressToString)(addr);
    return addrString;
}
exports.getAddressFromPublicKey = getAddressFromPublicKey;
function createStacksPublicKey(key) {
    return {
        type: constants_1.StacksMessageType.PublicKey,
        data: (0, common_1.hexToBytes)(key),
    };
}
exports.createStacksPublicKey = createStacksPublicKey;
function publicKeyFromSignatureVrs(messageHash, messageSignature, pubKeyEncoding = constants_1.PubKeyEncoding.Compressed) {
    const parsedSignature = (0, common_1.parseRecoverableSignatureVrs)(messageSignature.data);
    const signature = new Signature((0, common_1.hexToBigInt)(parsedSignature.r), (0, common_1.hexToBigInt)(parsedSignature.s));
    const point = Point.fromSignature(messageHash, signature, parsedSignature.recoveryId);
    const compressed = pubKeyEncoding === constants_1.PubKeyEncoding.Compressed;
    return point.toHex(compressed);
}
exports.publicKeyFromSignatureVrs = publicKeyFromSignatureVrs;
function publicKeyFromSignatureRsv(messageHash, messageSignature, pubKeyEncoding = constants_1.PubKeyEncoding.Compressed) {
    return publicKeyFromSignatureVrs(messageHash, { ...messageSignature, data: (0, common_1.signatureRsvToVrs)(messageSignature.data) }, pubKeyEncoding);
}
exports.publicKeyFromSignatureRsv = publicKeyFromSignatureRsv;
function publicKeyFromBytes(data) {
    return { type: constants_1.StacksMessageType.PublicKey, data };
}
exports.publicKeyFromBytes = publicKeyFromBytes;
function isCompressed(key) {
    return !(0, common_1.bytesToHex)(key.data).startsWith('04');
}
exports.isCompressed = isCompressed;
function publicKeyToString(key) {
    return (0, common_1.bytesToHex)(key.data);
}
exports.publicKeyToString = publicKeyToString;
function serializePublicKey(key) {
    return key.data.slice();
}
exports.serializePublicKey = serializePublicKey;
function pubKeyfromPrivKey(privateKey) {
    const privKey = createStacksPrivateKey(privateKey);
    const publicKey = nobleGetPublicKey(privKey.data.slice(0, 32), privKey.compressed);
    return createStacksPublicKey((0, common_1.bytesToHex)(publicKey));
}
exports.pubKeyfromPrivKey = pubKeyfromPrivKey;
function compressPublicKey(publicKey) {
    const hex = typeof publicKey === 'string' ? publicKey : (0, common_1.bytesToHex)(publicKey);
    const compressed = Point.fromHex(hex).toHex(true);
    return createStacksPublicKey(compressed);
}
exports.compressPublicKey = compressPublicKey;
function deserializePublicKey(bytesReader) {
    const fieldId = bytesReader.readUInt8();
    const keyLength = fieldId !== 4 ? constants_1.COMPRESSED_PUBKEY_LENGTH_BYTES : constants_1.UNCOMPRESSED_PUBKEY_LENGTH_BYTES;
    return publicKeyFromBytes((0, common_1.concatArray)([fieldId, bytesReader.readBytes(keyLength)]));
}
exports.deserializePublicKey = deserializePublicKey;
function createStacksPrivateKey(key) {
    if (key == undefined || null || key.length == 0) {
        throw new Error('invalid key');
    }
    const data = (0, common_1.privateKeyToBytes)(key);
    const compressed = data.length == common_1.PRIVATE_KEY_COMPRESSED_LENGTH;
    return { data, compressed };
}
exports.createStacksPrivateKey = createStacksPrivateKey;
function makeRandomPrivKey() {
    return createStacksPrivateKey(utils.randomPrivateKey());
}
exports.makeRandomPrivKey = makeRandomPrivKey;
function signWithKey(privateKey, messageHash) {
    const [rawSignature, recoveryId] = signSync(messageHash, privateKey.data.slice(0, 32), {
        canonical: true,
        recovered: true,
    });
    if (recoveryId == null) {
        throw new Error('No signature recoveryId received');
    }
    const recoveryIdHex = (0, common_1.intToHex)(recoveryId, 1);
    const recoverableSignatureString = recoveryIdHex + Signature.fromHex(rawSignature).toCompactHex();
    return (0, common_2.createMessageSignature)(recoverableSignatureString);
}
exports.signWithKey = signWithKey;
function signMessageHashRsv({ messageHash, privateKey, }) {
    const messageSignature = signWithKey(privateKey, messageHash);
    return { ...messageSignature, data: (0, common_1.signatureVrsToRsv)(messageSignature.data) };
}
exports.signMessageHashRsv = signMessageHashRsv;
function getPublicKey(privateKey) {
    return pubKeyfromPrivKey(privateKey.data);
}
exports.getPublicKey = getPublicKey;
function privateKeyToString(privateKey) {
    return (0, common_1.bytesToHex)(privateKey.data);
}
exports.privateKeyToString = privateKeyToString;
function publicKeyToAddress(version, publicKey) {
    return (0, c32check_1.c32address)(version, (0, common_1.bytesToHex)((0, utils_1.hash160)(publicKey.data)));
}
exports.publicKeyToAddress = publicKeyToAddress;
//# sourceMappingURL=keys.js.map