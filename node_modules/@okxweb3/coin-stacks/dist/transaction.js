"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDeployPayload = exports.getContractCallPayload = exports.getRevokeDelegateStxPayload = exports.getDelegateStxPayload = exports.getAllowContractCallerPayload = exports.getTokenTransferPayload = exports.getTransferPayload = exports.revokeDelegateStx = exports.delegateStx = exports.ContractDeployTx = exports.makeContractCallTx = exports.TransactionTypes = exports.allowContractCaller = exports.tokenTransfer = exports.stacks = exports.transfer = void 0;
const transactions_1 = require("./transactions");
const payload_1 = require("./transactions/payload");
const common_1 = require("./common");
const network_1 = require("./network");
const stacking_1 = require("./stacking");
function transfer(secretKey, to, amount, memo, nonce, fee, anchorMode) {
    const transactionVersion = transactions_1.TransactionVersion.Mainnet;
    const address = to;
    const recipient = (0, transactions_1.createStandardPrincipal)(address);
    const recipientCV = (0, transactions_1.standardPrincipalCV)(address);
    const payload = (0, payload_1.createTokenTransferPayload)(recipientCV, amount, memo);
    const addressHashMode = transactions_1.AddressHashMode.SerializeP2PKH;
    const privateKey = (0, transactions_1.createStacksPrivateKey)(secretKey);
    const pubKey = (0, common_1.bytesToHex)((0, transactions_1.getPublicKey)(privateKey).data);
    const spendingCondition = (0, transactions_1.createSingleSigSpendingCondition)(addressHashMode, pubKey, nonce, fee);
    const authorization = (0, transactions_1.createStandardAuth)(spendingCondition);
    const postConditions = (0, transactions_1.createLPList)([]);
    const transaction = new transactions_1.StacksTransaction(transactionVersion, authorization, payload, postConditions, undefined, anchorMode);
    const signer = new transactions_1.TransactionSigner(transaction);
    signer.signOrigin((0, transactions_1.createStacksPrivateKey)(secretKey));
    transaction.verifyOrigin();
    const txId = (0, transactions_1.addHex)(transaction.txid());
    const serialized = transaction.serialize();
    const txSerializedHexString = (0, common_1.bytesToHex)(serialized);
    return { txId, txSerializedHexString };
}
exports.transfer = transfer;
async function stacks(privateKey, address, poxAddress, amountMicroStx, cycles, burnBlockHeight, contract, fee, nonce) {
    const network = new network_1.StacksMainnet();
    const stackingResults = await (0, stacking_1.stack)({
        contract,
        amountMicroStx,
        poxAddress,
        cycles,
        privateKey,
        burnBlockHeight,
        fee,
        nonce
    });
    return stackingResults;
}
exports.stacks = stacks;
async function tokenTransfer(secretKey, from, to, memo, amount, contract, contractName, tokenName, functionName, nonce, fee) {
    const stacksTransaction = await (0, transactions_1.makeContractCall)({
        anchorMode: transactions_1.AnchorMode.Any,
        contractAddress: contract,
        contractName: contractName,
        fee: fee,
        functionArgs: [(0, transactions_1.uintCV)(amount), (0, transactions_1.standardPrincipalCV)(from), (0, transactions_1.standardPrincipalCV)(to), (0, transactions_1.someCV)((0, transactions_1.bufferCVFromString)(memo))],
        functionName: functionName,
        nonce: nonce,
        postConditionMode: transactions_1.PostConditionMode.Deny,
        postConditions: [(0, transactions_1.makeStandardFungiblePostCondition)(from, transactions_1.FungibleConditionCode.Equal, amount, (0, transactions_1.createAssetInfo)(contract, contractName, tokenName))],
        senderKey: secretKey,
        network: new network_1.StacksMainnet(),
    });
    const txId = (0, transactions_1.addHex)(stacksTransaction.txid());
    const txSerializedHexString = (0, common_1.bytesToHex)(stacksTransaction.serialize());
    return { txId, txSerializedHexString };
}
exports.tokenTransfer = tokenTransfer;
async function allowContractCaller(secretKey, caller, contract, contractName, functionName, untilBurnBlockHeight, nonce, fee) {
    const stacksTransaction = await (0, transactions_1.makeContractCall)({
        anchorMode: transactions_1.AnchorMode.Any,
        contractAddress: contract,
        contractName: contractName,
        fee: fee,
        functionArgs: [(0, transactions_1.principalCV)(caller), untilBurnBlockHeight ? (0, transactions_1.someCV)((0, transactions_1.uintCV)(untilBurnBlockHeight)) : (0, transactions_1.noneCV)()],
        functionName: functionName,
        nonce: nonce,
        senderKey: secretKey,
        network: new network_1.StacksMainnet(),
    });
    const txId = (0, transactions_1.addHex)(stacksTransaction.txid());
    const txSerializedHexString = (0, common_1.bytesToHex)(stacksTransaction.serialize());
    return { txId, txSerializedHexString };
}
exports.allowContractCaller = allowContractCaller;
var TransactionTypes;
(function (TransactionTypes) {
    TransactionTypes["ContractCall"] = "contract_call";
    TransactionTypes["ContractDeploy"] = "smart_contract";
    TransactionTypes["STXTransfer"] = "token_transfer";
})(TransactionTypes = exports.TransactionTypes || (exports.TransactionTypes = {}));
async function makeContractCallTx(args, senderKey) {
    const { txData, nonce, fee } = args;
    const { contractName, contractAddress, functionName, functionArgs, sponsored, postConditionMode, postConditions, anchorMode, } = txData;
    const fnArgs = functionArgs.map(arg => (0, transactions_1.deserializeCV)((0, transactions_1.hexToBuff)(arg)));
    const options = {
        senderKey: senderKey,
        contractName,
        contractAddress,
        functionName,
        anchorMode: anchorMode ?? transactions_1.AnchorMode.Any,
        functionArgs: fnArgs,
        nonce: nonce,
        fee: fee,
        postConditionMode: postConditionMode,
        postConditions: postConditions?.map(transactions_1.postConditionFromString),
        sponsored
    };
    const tx = await (0, transactions_1.makeContractCall)(options);
    const txId = (0, transactions_1.addHex)(tx.txid());
    const txSerializedHexString = (0, common_1.bytesToHex)(tx.serialize());
    return { txId, txSerializedHexString };
}
exports.makeContractCallTx = makeContractCallTx;
async function ContractDeployTx(args, senderKey) {
    const { txData, nonce, fee } = args;
    const { contractName, codeBody, postConditions, postConditionMode, anchorMode } = txData;
    const options = {
        senderKey: senderKey,
        contractName,
        codeBody,
        nonce: nonce,
        fee: fee,
        anchorMode: anchorMode ?? transactions_1.AnchorMode.Any,
        postConditionMode: postConditionMode,
        postConditions: postConditions?.map(transactions_1.postConditionFromString),
    };
    const tx = await (0, transactions_1.makeContractDeploy)(options);
    const txId = (0, transactions_1.addHex)(tx.txid());
    const txSerializedHexString = (0, common_1.bytesToHex)(tx.serialize());
    return { txId, txSerializedHexString };
}
exports.ContractDeployTx = ContractDeployTx;
async function delegateStx(secretKey, contract, contractName, functionName, delegateTo, poxAddress, amountMicroStx, untilBurnBlockHeight, nonce, fee) {
    const txOptions = (0, stacking_1.getDelegateOptions)(contract, contractName, functionName, amountMicroStx, delegateTo, untilBurnBlockHeight, poxAddress);
    const stacksTransaction = await (0, transactions_1.makeContractCall)({ ...txOptions, senderKey: secretKey, nonce, fee });
    const txId = (0, transactions_1.addHex)(stacksTransaction.txid());
    const txSerializedHexString = (0, common_1.bytesToHex)(stacksTransaction.serialize());
    return { txId, txSerializedHexString };
}
exports.delegateStx = delegateStx;
async function revokeDelegateStx(secretKey, contract, contractName, functionName, nonce, fee) {
    const stacksTransaction = await (0, transactions_1.makeContractCall)({
        anchorMode: transactions_1.AnchorMode.Any,
        contractAddress: contract,
        contractName: contractName,
        fee: fee,
        functionArgs: [],
        functionName: functionName,
        nonce: nonce,
        senderKey: secretKey,
        network: new network_1.StacksMainnet(),
    });
    const txId = (0, transactions_1.addHex)(stacksTransaction.txid());
    const txSerializedHexString = (0, common_1.bytesToHex)(stacksTransaction.serialize());
    return { txId, txSerializedHexString };
}
exports.revokeDelegateStx = revokeDelegateStx;
function getTransferPayload(to, amount, memo) {
    const address = to;
    const recipientCV = (0, transactions_1.standardPrincipalCV)(address);
    const payload = (0, payload_1.createTokenTransferPayload)(recipientCV, amount, memo);
    const s = (0, transactions_1.serializePayload)(payload);
    return (0, common_1.bytesToHex)(s);
}
exports.getTransferPayload = getTransferPayload;
function getTokenTransferPayload(from, to, memo, amount, contract, contractName, functionName) {
    const payload = (0, payload_1.createContractCallPayload)(contract, contractName, functionName, [(0, transactions_1.uintCV)(amount), (0, transactions_1.standardPrincipalCV)(from), (0, transactions_1.standardPrincipalCV)(to), (0, transactions_1.someCV)((0, transactions_1.bufferCVFromString)(memo))]);
    const s = (0, transactions_1.serializePayload)(payload);
    return (0, common_1.bytesToHex)(s);
}
exports.getTokenTransferPayload = getTokenTransferPayload;
function getAllowContractCallerPayload(caller, contract, contractName, functionName, untilBurnBlockHeight) {
    const payload = (0, payload_1.createContractCallPayload)(contract, contractName, functionName, [(0, transactions_1.principalCV)(caller), untilBurnBlockHeight ? (0, transactions_1.someCV)((0, transactions_1.uintCV)(untilBurnBlockHeight)) : (0, transactions_1.noneCV)()]);
    const s = (0, transactions_1.serializePayload)(payload);
    return (0, common_1.bytesToHex)(s);
}
exports.getAllowContractCallerPayload = getAllowContractCallerPayload;
function getDelegateStxPayload(contract, contractName, functionName, delegateTo, poxAddress, amountMicroStx, untilBurnBlockHeight) {
    const address = poxAddress ? (0, transactions_1.someCV)((0, stacking_1.poxAddressToTuple)(poxAddress)) : (0, transactions_1.noneCV)();
    const functionArgs = [
        (0, transactions_1.uintCV)(amountMicroStx),
        (0, transactions_1.principalCV)(delegateTo),
        untilBurnBlockHeight ? (0, transactions_1.someCV)((0, transactions_1.uintCV)(untilBurnBlockHeight)) : (0, transactions_1.noneCV)(),
        address
    ];
    const payload = (0, payload_1.createContractCallPayload)(contract, contractName, functionName, functionArgs);
    const s = (0, transactions_1.serializePayload)(payload);
    return (0, common_1.bytesToHex)(s);
}
exports.getDelegateStxPayload = getDelegateStxPayload;
function getRevokeDelegateStxPayload(contract, contractName, functionName) {
    const payload = (0, payload_1.createContractCallPayload)(contract, contractName, functionName, []);
    const s = (0, transactions_1.serializePayload)(payload);
    return (0, common_1.bytesToHex)(s);
}
exports.getRevokeDelegateStxPayload = getRevokeDelegateStxPayload;
function getContractCallPayload(contract, contractName, functionName, functionArgs) {
    const fnArgs = functionArgs.map(arg => (0, transactions_1.deserializeCV)((0, transactions_1.hexToBuff)(arg)));
    const payload = (0, payload_1.createContractCallPayload)(contract, contractName, functionName, fnArgs);
    const s = (0, transactions_1.serializePayload)(payload);
    return (0, common_1.bytesToHex)(s);
}
exports.getContractCallPayload = getContractCallPayload;
function getDeployPayload(contractName, codeBody) {
    const payload = (0, payload_1.createSmartContractPayload)(contractName, codeBody, transactions_1.ClarityVersion.Clarity2);
    const s = (0, transactions_1.serializePayload)(payload);
    return (0, common_1.bytesToHex)(s);
}
exports.getDeployPayload = getDeployPayload;
//# sourceMappingURL=transaction.js.map