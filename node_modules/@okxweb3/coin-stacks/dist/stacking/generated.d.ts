export interface AddressAssetsListResponse {
    limit: number;
    offset: number;
    total: number;
    results: TransactionEvent[];
}
export interface AddressBalanceResponse {
    stx: {
        balance: string;
        total_sent: string;
        total_received: string;
        total_fees_sent: string;
        total_miner_rewards_received: string;
        lock_tx_id: string;
        locked: string;
        lock_height: number;
        burnchain_lock_height: number;
        burnchain_unlock_height: number;
    };
    fungible_tokens: {
        [k: string]: {
            balance: string;
            total_sent: string;
            total_received: string;
        };
    };
    non_fungible_tokens: {
        [k: string]: {
            count: string;
            total_sent: string;
            total_received: string;
        };
    };
    token_offering_locked?: AddressTokenOfferingLocked;
}
export interface AddressNftListResponse {
    limit: number;
    offset: number;
    total: number;
    nft_events: NftEvent[];
}
export interface AddressStxBalanceResponse {
    balance: string;
    total_sent: string;
    total_received: string;
    total_fees_sent: string;
    total_miner_rewards_received: string;
    lock_tx_id: string;
    locked: string;
    lock_height: number;
    burnchain_lock_height: number;
    burnchain_unlock_height: number;
    token_offering_locked?: AddressTokenOfferingLocked;
}
export interface AddressStxInboundListResponse {
    limit: number;
    offset: number;
    total: number;
    results: InboundStxTransfer[];
}
export interface AddressTransactionsWithTransfersListResponse {
    limit: number;
    offset: number;
    total: number;
    results: AddressTransactionWithTransfers[];
}
export interface AddressTransactionsListResponse {
    limit: number;
    offset: number;
    total: number;
    results: (MempoolTransaction | Transaction)[];
}
export interface BlockListResponse {
    limit: number;
    offset: number;
    total: number;
    results: Block[];
}
export interface BnsError {
    error?: string;
}
export type BnsFetchFileZoneResponse = {
    zonefile?: string;
    [k: string]: unknown | undefined;
} | {
    error?: string;
    [k: string]: unknown | undefined;
};
export type BnsGetAllNamesResponse = string[];
export type BnsGetAllSubdomainsResponse = string[];
export type BnsFetchHistoricalZoneFileResponse = {
    zonefile?: string;
    [k: string]: unknown | undefined;
} | {
    error?: string;
    [k: string]: unknown | undefined;
};
export interface BnsGetNameHistoryResponse {
    [k: string]: {
        address?: string;
        base?: number;
        buckets?: number[] | null;
        block_number?: number;
        coeff?: number | null;
        consensus_hash?: string | null;
        domain?: string;
        fee?: number;
        first_registered?: number;
        history_snapshot?: boolean;
        importer?: string | null;
        importer_address?: string | null;
        last_renewed?: number;
        name?: string;
        op?: string;
        op_fee?: number;
        opcode?: string;
        revoked?: boolean;
        sender?: string;
        sender_pubkey?: string | null;
        sequence?: number;
        recipient?: string | null;
        recipient_address?: string | null;
        recipient_pubkey?: string | null;
        txid: string;
        value_hash?: string | null;
        vtxindex: number;
        [k: string]: unknown | undefined;
    }[];
}
export interface BnsGetNameInfoResponse {
    address: string;
    blockchain: string;
    expire_block?: number;
    grace_period?: number;
    last_txid: string;
    resolver?: string;
    status: string;
    zonefile: string;
    zonefile_hash: string;
}
export interface BnsGetNamePriceResponse {
    units: string;
    amount: string;
}
export interface BnsNamesOwnByAddressResponse {
    names?: string[];
}
export type BnsGetSubdomainAtTx = {
    accepted?: number;
    block_height?: number;
    domain?: string;
    fully_qualified_subdomain?: string;
    missing?: string;
    owner?: string;
    parent_zonefile_hash?: string;
    parent_zonefile_index?: number;
    resolver?: string;
    sequence?: number;
    signature?: string;
    txid?: string;
    zonefile_hash?: string;
    zonefile_offset?: number;
    [k: string]: unknown | undefined;
}[];
export type BnsGetAllNamespacesNamesResponse = string[];
export interface BnsGetAllNamespacesResponse {
    namespaces: string[];
}
export interface BnsGetNamespacePriceResponse {
    units: string;
    amount: string;
}
export interface BurnchainRewardSlotHolderListResponse {
    limit: number;
    offset: number;
    total: number;
    results: BurnchainRewardSlotHolder[];
}
export interface BurnchainRewardListResponse {
    limit: number;
    offset: number;
    results: BurnchainReward[];
}
export interface ReadOnlyFunctionSuccessResponse {
    okay: boolean;
    result?: string;
    cause?: string;
}
export interface AccountDataResponse {
    balance: string;
    locked: string;
    unlock_height: number;
    nonce: number;
    balance_proof: string;
    nonce_proof: string;
}
export interface MapEntryResponse {
    data: string;
    proof?: string;
}
export interface ContractInterfaceResponse {
    functions: {
        [k: string]: unknown | undefined;
    }[];
    variables: {
        [k: string]: unknown | undefined;
    }[];
    maps: {
        [k: string]: unknown | undefined;
    }[];
    fungible_tokens: {
        [k: string]: unknown | undefined;
    }[];
    non_fungible_tokens: {
        [k: string]: unknown | undefined;
    }[];
}
export interface ContractSourceResponse {
    source: string;
    publish_height: number;
    proof: string;
}
export type CoreNodeFeeResponse = string;
export interface CoreNodeInfoResponse {
    peer_version: number;
    pox_consensus: string;
    burn_block_height: number;
    stable_pox_consensus: string;
    stable_burn_block_height: number;
    server_version: string;
    network_id: number;
    parent_network_id: number;
    stacks_tip_height: number;
    stacks_tip: string;
    stacks_tip_consensus_hash: string;
    unanchored_tip: string;
    exit_at_block_height: number;
}
export interface CoreNodePoxResponse {
    contract_id: string;
    first_burnchain_block_height: number;
    min_amount_ustx: number;
    registration_window_length: number;
    rejection_fraction: number;
    reward_cycle_id: number;
    reward_cycle_length: number;
    rejection_votes_left_required: number;
    total_liquid_supply_ustx: number;
}
export interface RunFaucetResponse {
    success: boolean;
    txId?: string;
    txRaw?: string;
}
export interface NetworkBlockTimeResponse {
    target_block_time: number;
}
export interface NetworkBlockTimesResponse {
    mainnet: {
        target_block_time: number;
    };
    testnet: {
        target_block_time: number;
    };
}
export type GetStxCirculatingSupplyPlainResponse = string;
export interface GetStxSupplyLegacyFormatResponse {
    unlockedPercent: string;
    totalStacks: string;
    totalStacksFormatted: string;
    unlockedSupply: string;
    unlockedSupplyFormatted: string;
    blockHeight: string;
}
export type GetStxTotalSupplyPlainResponse = string;
export interface GetStxSupplyResponse {
    unlocked_percent: string;
    total_stx: string;
    unlocked_stx: string;
    block_height: number;
}
export interface RosettaAccountBalanceRequest {
    network_identifier: NetworkIdentifier;
    account_identifier: RosettaAccount;
    block_identifier?: RosettaPartialBlockIdentifier;
}
export interface RosettaAccountBalanceResponse {
    block_identifier: RosettaBlockIdentifier;
    balances: RosettaAmount[];
    coins?: RosettaCoin[];
    metadata?: {
        sequence_number: number;
        [k: string]: unknown | undefined;
    };
}
export interface RosettaBlockRequest {
    network_identifier: NetworkIdentifier;
    block_identifier: RosettaPartialBlockIdentifier;
}
export interface RosettaBlockResponse {
    block?: RosettaBlock;
    other_transactions?: OtherTransactionIdentifier[];
}
export interface RosettaBlockTransactionRequest {
    network_identifier: NetworkIdentifier;
    block_identifier: RosettaBlockIdentifier;
    transaction_identifier: TransactionIdentifier;
}
export interface RosettaBlockTransactionResponse {
    transaction: RosettaTransaction;
}
export interface RosettaConstructionCombineRequest {
    network_identifier: NetworkIdentifier;
    unsigned_transaction: string;
    signatures: RosettaSignature[];
}
export interface RosettaConstructionCombineResponse {
    signed_transaction: string;
}
export interface RosettaConstructionDeriveRequest {
    network_identifier: NetworkIdentifier;
    public_key: RosettaPublicKey;
    metadata?: {
        [k: string]: unknown | undefined;
    };
}
export interface RosettaConstructionDeriveResponse {
    address?: string;
    account_identifier?: RosettaAccountIdentifier;
    metadata?: {
        [k: string]: unknown | undefined;
    };
}
export interface RosettaConstructionHashRequest {
    network_identifier: NetworkIdentifier;
    signed_transaction: string;
}
export interface RosettaConstructionHashResponse {
    transaction_identifier: TransactionIdentifier;
    metadata?: {
        [k: string]: unknown | undefined;
    };
}
export interface RosettaConstructionMetadataRequest {
    network_identifier: NetworkIdentifier;
    options: RosettaOptions;
    public_keys?: RosettaPublicKey[];
}
export interface RosettaConstructionMetadataResponse {
    metadata: {
        account_sequence?: number;
        recent_block_hash?: string;
        [k: string]: unknown | undefined;
    };
    suggested_fee?: RosettaAmount[];
}
export interface RosettaConstructionParseRequest {
    network_identifier: NetworkIdentifier;
    signed: boolean;
    transaction: string;
}
export interface RosettaConstructionParseResponse {
    operations: RosettaOperation[];
    signers?: string[];
    account_identifier_signers?: RosettaAccountIdentifier[];
    metadata?: {
        [k: string]: unknown | undefined;
    };
}
export interface RosettaConstructionPayloadsRequest {
    network_identifier: NetworkIdentifier;
    operations: RosettaOperation[];
    public_keys?: RosettaPublicKey[];
    metadata?: {
        account_sequence?: number;
        recent_block_hash?: string;
        [k: string]: unknown | undefined;
    };
}
export interface RosettaConstructionPayloadResponse {
    unsigned_transaction: string;
    payloads: SigningPayload[];
}
export interface RosettaConstructionPreprocessRequest {
    network_identifier: NetworkIdentifier;
    operations: RosettaOperation[];
    metadata?: {
        [k: string]: unknown | undefined;
    };
    max_fee?: RosettaMaxFeeAmount[];
    suggested_fee_multiplier?: number;
}
export interface RosettaConstructionPreprocessResponse {
    options?: RosettaOptions;
    required_public_keys?: RosettaAccount[];
}
export interface RosettaConstructionSubmitRequest {
    network_identifier: NetworkIdentifier;
    signed_transaction: string;
}
export interface RosettaConstructionSubmitResponse {
    transaction_identifier: TransactionIdentifier;
    metadata?: {
        [k: string]: unknown | undefined;
    };
}
export interface RosettaMempoolRequest {
    network_identifier: NetworkIdentifier;
    metadata?: {
        [k: string]: unknown | undefined;
    };
}
export interface RosettaMempoolResponse {
    transaction_identifiers: TransactionIdentifier[];
    metadata?: {
        [k: string]: unknown | undefined;
    };
}
export interface RosettaMempoolTransactionRequest {
    network_identifier: NetworkIdentifier;
    transaction_identifier: TransactionIdentifier;
}
export interface RosettaMempoolTransactionResponse {
    transaction: RosettaTransaction;
    metadata?: {
        [k: string]: unknown | undefined;
    };
}
export interface RosettaNetworkListRequest {
    metadata?: {
        [k: string]: unknown | undefined;
    };
}
export interface RosettaNetworkListResponse {
    network_identifiers: NetworkIdentifier[];
}
export interface RosettaOptionsRequest {
    network_identifier: NetworkIdentifier;
    metadata?: {
        [k: string]: unknown | undefined;
    };
}
export interface RosettaNetworkOptionsResponse {
    version: {
        rosetta_version: string;
        node_version: string;
        middleware_version?: string;
        metadata?: {
            [k: string]: unknown | undefined;
        };
        [k: string]: unknown | undefined;
    };
    allow: {
        operation_statuses: RosettaOperationStatus[];
        operation_types: string[];
        errors: RosettaErrorNoDetails[];
        historical_balance_lookup: boolean;
        [k: string]: unknown | undefined;
    };
}
export interface RosettaStatusRequest {
    network_identifier: NetworkIdentifier;
    metadata?: {
        [k: string]: unknown | undefined;
    };
}
export interface RosettaNetworkStatusResponse {
    current_block_identifier: RosettaBlockIdentifier;
    current_block_timestamp: number;
    genesis_block_identifier: RosettaGenesisBlockIdentifier;
    oldest_block_identifier?: RosettaOldestBlockIdentifier;
    sync_status?: RosettaSyncStatus;
    peers: RosettaPeers[];
}
export interface MempoolTransactionListResponse {
    limit: number;
    offset: number;
    total: number;
    results: MempoolTransaction[];
}
export interface GetRawTransactionResult {
    raw_tx: string;
}
export interface TransactionResults {
    limit: number;
    offset: number;
    total: number;
    results: Transaction[];
}
export interface PostCoreNodeTransactionsError {
    error: string;
    reason: string;
    reason_data: {
        [k: string]: unknown | undefined;
    };
    txid: string;
}
export interface AddressTokenOfferingLocked {
    total_locked: string;
    total_unlocked: string;
    unlock_schedule: AddressUnlockSchedule[];
}
export interface AddressTransactionWithTransfers {
    tx: Transaction;
    stx_sent: string;
    stx_received: string;
    stx_transfers: {
        amount: string;
        sender?: string;
        recipient?: string;
    }[];
}
export interface AddressUnlockSchedule {
    amount: string;
    block_height: number;
}
export interface Block {
    canonical: boolean;
    height: number;
    hash: string;
    parent_block_hash: string;
    burn_block_time: number;
    burn_block_time_iso: string;
    burn_block_hash: string;
    burn_block_height: number;
    miner_txid: string;
    txs: string[];
}
export interface BurnchainRewardSlotHolder {
    canonical: boolean;
    burn_block_hash: string;
    burn_block_height: number;
    address: string;
    slot_index: number;
}
export interface BurnchainReward {
    canonical: boolean;
    burn_block_hash: string;
    burn_block_height: number;
    burn_amount: string;
    reward_recipient: string;
    reward_amount: string;
    reward_index: number;
}
export interface BurnchainRewardsTotal {
    reward_recipient: string;
    reward_amount: string;
}
export interface ReadOnlyFunctionArgs {
    sender: string;
    arguments: string[];
}
export interface MempoolTokenTransferTransaction {
    tx_id: string;
    tx_status: MempoolTransactionStatus;
    tx_result?: {
        hex: string;
        repr: string;
    };
    nonce: number;
    fee_rate: string;
    sender_address: string;
    sponsored: boolean;
    sponsor_address?: string;
    post_condition_mode: PostConditionMode;
    receipt_time: number;
    receipt_time_iso: string;
    tx_type: "token_transfer";
    token_transfer: {
        recipient_address: string;
        amount: string;
        memo: string;
    };
}
export interface MempoolSmartContractTransaction {
    tx_id: string;
    tx_status: MempoolTransactionStatus;
    tx_result?: {
        hex: string;
        repr: string;
    };
    nonce: number;
    fee_rate: string;
    sender_address: string;
    sponsored: boolean;
    sponsor_address?: string;
    post_condition_mode: PostConditionMode;
    receipt_time: number;
    receipt_time_iso: string;
    tx_type: "smart_contract";
    smart_contract: {
        contract_id: string;
        source_code: string;
    };
    post_conditions?: PostCondition[];
}
export interface MempoolContractCallTransaction {
    tx_id: string;
    tx_status: MempoolTransactionStatus;
    tx_result?: {
        hex: string;
        repr: string;
    };
    nonce: number;
    fee_rate: string;
    sender_address: string;
    sponsored: boolean;
    sponsor_address?: string;
    post_condition_mode: PostConditionMode;
    receipt_time: number;
    receipt_time_iso: string;
    tx_type: "contract_call";
    contract_call: {
        contract_id: string;
        function_name: string;
    };
    post_conditions: PostCondition[];
}
export interface MempoolPoisonMicroblockTransaction {
    tx_id: string;
    tx_status: MempoolTransactionStatus;
    tx_result?: {
        hex: string;
        repr: string;
    };
    nonce: number;
    fee_rate: string;
    sender_address: string;
    sponsored: boolean;
    sponsor_address?: string;
    post_condition_mode: PostConditionMode;
    receipt_time: number;
    receipt_time_iso: string;
    tx_type: "poison_microblock";
    poison_microblock: {
        microblock_header_1: string;
        microblock_header_2: string;
    };
}
export interface MempoolCoinbaseTransaction {
    tx_id: string;
    tx_status: MempoolTransactionStatus;
    tx_result?: {
        hex: string;
        repr: string;
    };
    nonce: number;
    fee_rate: string;
    sender_address: string;
    sponsored: boolean;
    sponsor_address?: string;
    post_condition_mode: PostConditionMode;
    receipt_time: number;
    receipt_time_iso: string;
    tx_type: "coinbase";
    coinbase_payload: {
        data: string;
    };
}
export type MempoolTransactionStatus = "pending" | "dropped_replace_by_fee" | "dropped_replace_across_fork" | "dropped_too_expensive" | "dropped_stale_garbage_collect";
export type MempoolTransaction = MempoolTokenTransferTransaction | MempoolSmartContractTransaction | MempoolContractCallTransaction | MempoolPoisonMicroblockTransaction | MempoolCoinbaseTransaction;
export interface NftEvent {
    sender: string;
    recipient: string;
    asset_identifier: string;
    value: {
        hex: string;
        repr: string;
    };
    tx_id: string;
    block_height: number;
}
export interface PostConditionStx {
    principal: PostConditionPrincipal;
    condition_code: PostConditionFungibleConditionCode;
    amount: string;
    type: "stx";
}
export interface PostConditionFungible {
    principal: PostConditionPrincipal;
    condition_code: PostConditionFungibleConditionCode;
    type: "fungible";
    amount: string;
    asset: {
        asset_name: string;
        contract_address: string;
        contract_name: string;
    };
}
export interface PostConditionNonFungible {
    principal: PostConditionPrincipal;
    condition_code: PostConditionNonFungibleConditionCode;
    type: "non_fungible";
    asset_value: {
        hex: string;
        repr: string;
    };
    asset: {
        asset_name: string;
        contract_address: string;
        contract_name: string;
    };
}
export type PostConditionFungibleConditionCode = "sent_equal_to" | "sent_greater_than" | "sent_greater_than_or_equal_to" | "sent_less_than" | "sent_less_than_or_equal_to";
export type PostConditionMode = "allow" | "deny";
export type PostConditionNonFungibleConditionCode = "sent" | "not_sent";
export type PostConditionPrincipalType = "principal_origin" | "principal_standard" | "principal_contract";
export type PostConditionPrincipal = {
    type_id: "principal_origin";
} | {
    type_id: "principal_standard";
    address: string;
} | {
    type_id: "principal_contract";
    address: string;
    contract_name: string;
};
export type PostConditionType = "stx" | "non_fungible" | "fungible";
export type PostCondition = PostConditionStx | PostConditionFungible | PostConditionNonFungible;
export interface RosettaAccountIdentifier {
    address: string;
    sub_account?: RosettaSubAccount;
    metadata?: {
        [k: string]: unknown | undefined;
    };
}
export interface RosettaAccount {
    address: string;
    sub_account?: RosettaSubAccount;
    metadata?: {
        [k: string]: unknown | undefined;
    };
}
export interface RosettaMaxFeeAmount {
    value: string;
    currency: RosettaCurrency;
    metadata?: {
        [k: string]: unknown | undefined;
    };
}
export interface RosettaAmount {
    value: string;
    currency: RosettaCurrency;
    metadata?: {
        [k: string]: unknown | undefined;
    };
}
export interface RosettaBlockIdentifierHash {
    hash?: string;
}
export interface RosettaBlockIdentifierHeight {
    index?: number;
}
export interface RosettaBlockIdentifier {
    hash: string;
    index: number;
}
export interface RosettaBlock {
    block_identifier: RosettaBlockIdentifier;
    parent_block_identifier: RosettaParentBlockIdentifier;
    timestamp: number;
    transactions: RosettaTransaction[];
    metadata?: {
        transactions_root: string;
        difficulty: string;
        [k: string]: unknown | undefined;
    };
}
export interface RosettaCoinChange {
    coin_identifier: {
        identifier: string;
        [k: string]: unknown | undefined;
    };
    coin_action: "coin_created" | "coin_spent";
}
export interface RosettaCoin {
    coin_identifier: {
        identifier: string;
        [k: string]: unknown | undefined;
    };
    amount: RosettaAmount;
}
export interface RosettaOptions {
    sender_address?: string;
    type?: string;
    status?: string | null;
    token_transfer_recipient_address?: string;
    amount?: string;
    symbol?: string;
    decimals?: number;
    gas_limit?: number;
    gas_price?: number;
    suggested_fee_multiplier?: number;
    max_fee?: string;
    fee?: string;
    size?: number;
    number_of_cycles?: number;
    contract_address?: string;
    contract_name?: string;
    burn_block_height?: number;
    delegate_to?: string;
}
export interface RosettaCurrency {
    symbol: string;
    decimals: number;
    metadata?: {
        [k: string]: unknown | undefined;
    };
}
export interface RosettaErrorNoDetails {
    code: number;
    message: string;
    retriable: boolean;
}
export interface RosettaError {
    details?: {
        address?: string;
        error?: string;
        [k: string]: unknown | undefined;
    };
    code: number;
    message: string;
    retriable: boolean;
}
export interface RosettaGenesisBlockIdentifier {
    index: number;
    hash: string;
}
export interface NetworkIdentifier {
    blockchain: string;
    network: string;
    sub_network_identifier?: {
        network: string;
        metadata?: {
            producer: string;
            [k: string]: unknown | undefined;
        };
        [k: string]: unknown | undefined;
    };
}
export interface RosettaPeers {
    peer_id: string;
    metadata?: {
        [k: string]: unknown | undefined;
    };
}
export interface RosettaOldestBlockIdentifier {
    index: number;
    hash: string;
}
export interface RosettaOperationIdentifier {
    index: number;
    network_index?: number;
}
export interface RosettaOperationStatus {
    status: string;
    successful: boolean;
}
export interface RosettaOperation {
    operation_identifier: RosettaOperationIdentifier;
    related_operations?: RosettaRelatedOperation[];
    type: string;
    status?: string;
    account?: RosettaAccount;
    amount?: RosettaAmount;
    coin_change?: RosettaCoinChange;
    metadata?: {
        [k: string]: unknown | undefined;
    };
}
export interface OtherTransactionIdentifier {
    hash: string;
}
export interface RosettaParentBlockIdentifier {
    index: number;
    hash: string;
}
export type RosettaPartialBlockIdentifier = RosettaBlockIdentifierHash | RosettaBlockIdentifierHeight;
export interface RosettaPublicKey {
    hex_bytes: string;
    curve_type: "secp256k1" | "edwards25519";
}
export interface RosettaRelatedOperation {
    index: number;
    network_index?: number;
}
export interface RosettaSignature {
    signing_payload: SigningPayload;
    public_key: RosettaPublicKey;
    signature_type: "ecdsa" | "ecdsa_recovery" | "ed25519" | "schnorr_1" | "schnorr_poseidon";
    hex_bytes: string;
}
export interface SigningPayload {
    address?: string;
    account_identifier?: RosettaAccount;
    hex_bytes: string;
    signature_type?: "ecdsa" | "ecdsa_recovery" | "ed25519" | "schnorr_1" | "schnorr_poseidon";
}
export interface RosettaSubAccount {
    address: string;
    metadata?: {
        [k: string]: unknown | undefined;
    };
}
export interface RosettaSyncStatus {
    current_index: number;
    target_index?: number;
    stage?: string;
    synced?: boolean;
}
export interface TransactionIdentifier {
    hash: string;
}
export interface RosettaTransaction {
    transaction_identifier: TransactionIdentifier;
    operations: RosettaOperation[];
    metadata?: {
        size: number;
        lockTime: number;
        [k: string]: unknown | undefined;
    };
}
export type TransactionEventAssetType = "transfer" | "mint" | "burn";
export interface TransactionEventAsset {
    asset_event_type?: TransactionEventAssetType;
    asset_id?: string;
    sender?: string;
    recipient?: string;
    amount?: string;
    value?: string;
}
export interface TransactionEventFungibleAsset {
    event_index: number;
    event_type: "fungible_token_asset";
    asset: {
        asset_event_type: string;
        asset_id: string;
        sender: string;
        recipient: string;
        amount: string;
    };
}
export interface TransactionEventNonFungibleAsset {
    event_index: number;
    event_type: "non_fungible_token_asset";
    asset: {
        asset_event_type: string;
        asset_id: string;
        sender: string;
        recipient: string;
        value: {
            hex: string;
            repr: string;
        };
    };
}
export interface TransactionEventSmartContractLog {
    event_index: number;
    event_type: "smart_contract_log";
    contract_log: {
        contract_id: string;
        topic: string;
        value: {
            hex: string;
            repr: string;
        };
    };
}
export interface TransactionEventStxAsset {
    event_index: number;
    event_type: "stx_asset";
    asset: TransactionEventAsset;
}
export interface TransactionEventStxLock {
    event_index: number;
    event_type: "stx_lock";
    stx_lock_event: {
        locked_amount: string;
        unlock_height: number;
        locked_address: string;
    };
}
export type TransactionEventType = "smart_contract_log" | "stx_lock" | "stx_asset" | "fungible_token_asset" | "non_fungible_token_asset";
export type TransactionEvent = TransactionEventSmartContractLog | TransactionEventStxLock | TransactionEventStxAsset | TransactionEventFungibleAsset | TransactionEventNonFungibleAsset;
export interface TokenTransferTransaction {
    block_hash: string;
    block_height: number;
    burn_block_time: number;
    burn_block_time_iso: string;
    canonical: boolean;
    tx_id: string;
    tx_index: number;
    tx_status: TransactionStatus;
    tx_result?: {
        hex: string;
        repr: string;
    };
    nonce: number;
    fee_rate: string;
    sender_address: string;
    sponsored: boolean;
    sponsor_address?: string;
    post_condition_mode: PostConditionMode;
    event_count: number;
    events: TransactionEvent[];
    tx_type: "token_transfer";
    token_transfer: {
        recipient_address: string;
        amount: string;
        memo: string;
    };
}
export interface SmartContractTransaction {
    block_hash: string;
    block_height: number;
    burn_block_time: number;
    burn_block_time_iso: string;
    canonical: boolean;
    tx_id: string;
    tx_index: number;
    tx_status: TransactionStatus;
    tx_result?: {
        hex: string;
        repr: string;
    };
    nonce: number;
    fee_rate: string;
    sender_address: string;
    sponsored: boolean;
    sponsor_address?: string;
    post_condition_mode: PostConditionMode;
    event_count: number;
    events: TransactionEvent[];
    tx_type: "smart_contract";
    smart_contract: {
        contract_id: string;
        source_code: string;
    };
    post_conditions?: PostCondition[];
}
export interface ContractCallTransaction {
    block_hash: string;
    block_height: number;
    burn_block_time: number;
    burn_block_time_iso: string;
    canonical: boolean;
    tx_id: string;
    tx_index: number;
    tx_status: TransactionStatus;
    tx_result?: {
        hex: string;
        repr: string;
    };
    nonce: number;
    fee_rate: string;
    sender_address: string;
    sponsored: boolean;
    sponsor_address?: string;
    post_condition_mode: PostConditionMode;
    event_count: number;
    events: TransactionEvent[];
    tx_type: "contract_call";
    contract_call: {
        contract_id: string;
        function_name: string;
        function_signature: string;
        function_args?: {
            hex: string;
            repr: string;
            name: string;
            type: string;
        }[];
    };
    post_conditions: PostCondition[];
}
export interface PoisonMicroblockTransaction {
    block_hash: string;
    block_height: number;
    burn_block_time: number;
    burn_block_time_iso: string;
    canonical: boolean;
    tx_id: string;
    tx_index: number;
    tx_status: TransactionStatus;
    tx_result?: {
        hex: string;
        repr: string;
    };
    nonce: number;
    fee_rate: string;
    sender_address: string;
    sponsored: boolean;
    sponsor_address?: string;
    post_condition_mode: PostConditionMode;
    event_count: number;
    events: TransactionEvent[];
    tx_type: "poison_microblock";
    poison_microblock: {
        microblock_header_1: string;
        microblock_header_2: string;
    };
}
export interface CoinbaseTransaction {
    block_hash: string;
    block_height: number;
    burn_block_time: number;
    burn_block_time_iso: string;
    canonical: boolean;
    tx_id: string;
    tx_index: number;
    tx_status: TransactionStatus;
    tx_result?: {
        hex: string;
        repr: string;
    };
    nonce: number;
    fee_rate: string;
    sender_address: string;
    sponsored: boolean;
    sponsor_address?: string;
    post_condition_mode: PostConditionMode;
    event_count: number;
    events: TransactionEvent[];
    tx_type: "coinbase";
    coinbase_payload: {
        data: string;
    };
}
export type TransactionStatus = "success" | "abort_by_response" | "abort_by_post_condition";
export type TransactionType = "token_transfer" | "smart_contract" | "contract_call" | "poison_microblock" | "coinbase";
export type Transaction = TokenTransferTransaction | SmartContractTransaction | ContractCallTransaction | PoisonMicroblockTransaction | CoinbaseTransaction;
export interface InboundStxTransfer {
    sender: string;
    amount: string;
    memo: string;
    block_height: number;
    tx_id: string;
    transfer_type: "bulk-send" | "stx-transfer";
    tx_index: number;
}
export interface RpcAddressBalanceNotificationParams {
    address: string;
    balance: string;
}
export interface RpcAddressBalanceNotificationResponse {
    jsonrpc: "2.0";
    method: "address_balance_update";
    params: RpcAddressBalanceNotificationParams;
}
export interface RpcAddressBalanceSubscriptionParams {
    event: "address_balance_update";
    address: string;
}
export interface RpcAddressBalanceSubscriptionRequest {
    jsonrpc: "2.0";
    id: number | string;
    method: "address_balance_update";
    params: RpcAddressBalanceSubscriptionParams;
}
export interface RpcAddressTxNotificationParams {
    address: string;
    tx_id: string;
    tx_type: TransactionType;
    tx_status: TransactionStatus | MempoolTransactionStatus;
}
export interface RpcAddressTxNotificationResponse {
    jsonrpc: "2.0";
    method: "address_tx_update";
    params: RpcAddressTxNotificationParams;
}
export interface RpcAddressTxSubscriptionParams {
    event: "address_tx_update";
    address: string;
}
export interface RpcAddressTxSubscriptionRequest {
    jsonrpc: "2.0";
    id: number | string;
    method: "address_tx_update";
    params: RpcAddressTxSubscriptionParams;
}
export type RpcSubscriptionType = "tx_update" | "address_tx_update" | "address_balance_update";
export interface RpcTxUpdateNotificationParams {
    tx_id: string;
    tx_type: TransactionType;
    tx_status: TransactionStatus | MempoolTransactionStatus;
}
export interface RpcTxUpdateNotificationResponse {
    jsonrpc: "2.0";
    method: "tx_update";
    params: RpcTxUpdateNotificationParams;
}
export interface RpcTxUpdateSubscriptionParams {
    event: "tx_update";
    tx_id: string;
}
export interface RpcTxUpdateSubscriptionRequest {
    jsonrpc: "2.0";
    id: number | string;
    method: "tx_update";
    params: RpcTxUpdateSubscriptionParams;
}
