'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decode = exports.encode = void 0;
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const common_1 = require("../common");
const base_x_1 = __importDefault(require("../base-x"));
const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
function encode(data, prefix = '00') {
    const dataBytes = typeof data === 'string' ? (0, common_1.hexToBytes)(data) : data;
    const prefixBytes = typeof prefix === 'string' ? (0, common_1.hexToBytes)(prefix) : data;
    if (!(dataBytes instanceof Uint8Array) || !(prefixBytes instanceof Uint8Array)) {
        throw new TypeError('Argument must be of type Uint8Array or string');
    }
    const checksum = crypto_lib_1.base.sha256(crypto_lib_1.base.sha256(new Uint8Array([...prefixBytes, ...dataBytes])));
    return (0, base_x_1.default)(ALPHABET).encode([...prefixBytes, ...dataBytes, ...checksum.slice(0, 4)]);
}
exports.encode = encode;
function decode(string) {
    const bytes = (0, base_x_1.default)(ALPHABET).decode(string);
    const prefixBytes = bytes.slice(0, 1);
    const dataBytes = bytes.slice(1, -4);
    const checksum = crypto_lib_1.base.sha256(crypto_lib_1.base.sha256(new Uint8Array([...prefixBytes, ...dataBytes])));
    bytes.slice(-4).forEach((check, index) => {
        if (check !== checksum[index]) {
            throw new Error('Invalid checksum');
        }
    });
    return { prefix: prefixBytes, data: dataBytes };
}
exports.decode = decode;
//# sourceMappingURL=base58check.js.map