"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StxWallet = void 0;
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const coin_base_1 = require("@okxweb3/coin-base");
const index_1 = require("./index");
class StxWallet extends coin_base_1.BaseWallet {
    async getDerivedPath(param) {
        return `m/44'/5757'/0'/0/${param.index}`;
    }
    getDerivedPrivateKey(param) {
        return crypto_lib_1.bip39.mnemonicToSeed(param.mnemonic)
            .then(masterSeed => {
            let childKey = crypto_lib_1.bip32.fromSeed(masterSeed).derivePath(param.hdPath);
            if (!childKey.privateKey) {
                return Promise.reject(coin_base_1.GenPrivateKeyError);
            }
            return Promise.resolve(crypto_lib_1.base.toHex(childKey.privateKey) + "01");
        }).catch((e) => {
            return Promise.reject(coin_base_1.GenPrivateKeyError);
        });
    }
    getRandomPrivateKey() {
        try {
            while (true) {
                const privateKey = crypto_lib_1.base.randomBytes(32);
                if ((0, coin_base_1.secp256k1SignTest)(privateKey)) {
                    return Promise.resolve(crypto_lib_1.base.toHex(privateKey, true) + "01");
                }
            }
        }
        catch (e) {
        }
        return Promise.reject(coin_base_1.GenPrivateKeyError);
    }
    getNewAddress(param) {
        try {
            let key = param.privateKey.toLowerCase().startsWith("0x") ? param.privateKey.substring(2) : param.privateKey;
            const privateKey = (0, index_1.createStacksPrivateKey)(key.toLowerCase());
            const publicKey = crypto_lib_1.base.toHex((0, index_1.getPublicKey)(privateKey).data);
            let address;
            if (param.version && param.version === 'Testnet') {
                address = (0, index_1.getAddressFromPublicKey)(publicKey, index_1.TransactionVersion.Testnet);
            }
            else {
                address = (0, index_1.getAddressFromPublicKey)(publicKey);
            }
            const data = {
                address: address,
                publicKey: publicKey
            };
            return Promise.resolve(data);
        }
        catch (e) {
            return Promise.reject(coin_base_1.NewAddressError);
        }
    }
    checkPrivateKey(privateKeyHex) {
        if (privateKeyHex.toLowerCase().startsWith("0x")) {
            privateKeyHex = privateKeyHex.substring(2);
        }
        (0, index_1.createStacksPrivateKey)(privateKeyHex);
        return true;
    }
    async validPrivateKey(param) {
        let isValid;
        try {
            isValid = this.checkPrivateKey(param.privateKey);
        }
        catch (e) {
            isValid = false;
        }
        const data = {
            isValid: isValid,
            privateKey: param.privateKey
        };
        return Promise.resolve(data);
    }
    async signTransaction(param) {
        try {
            if (param.privateKey.startsWith("0x")) {
                param.privateKey = param.privateKey.substring(2);
            }
            const data = param.data;
            if (data.type == 'transfer') {
                const transferParam = data.data;
                if (transferParam.to == null || transferParam.amount == null || transferParam.nonce == null || transferParam.fee == null) {
                    return Promise.reject(coin_base_1.SignTxError);
                }
                const tx = (0, index_1.transfer)(param.privateKey, transferParam.to, transferParam.amount, transferParam.memo, transferParam.nonce, transferParam.fee, transferParam.anchorMode);
                return Promise.resolve(tx);
            }
            else if (data.type == 'tokenTransfer') {
                const contractCallParam = data.data;
                if (contractCallParam.from == null || contractCallParam.to == null || contractCallParam.amount == null || contractCallParam.contract == null
                    || contractCallParam.contractName == null || contractCallParam.functionName == null) {
                    return Promise.reject(coin_base_1.SignTxError);
                }
                const tx = await (0, index_1.tokenTransfer)(param.privateKey, contractCallParam.from, contractCallParam.to, contractCallParam.memo, contractCallParam.amount, contractCallParam.contract, contractCallParam.contractName, contractCallParam.tokenName, contractCallParam.functionName, contractCallParam.nonce, contractCallParam.fee);
                return Promise.resolve(tx);
            }
            else if (data.type == 'allowContractCaller') {
                const contractCallParam = data.data;
                if (contractCallParam.caller == null || contractCallParam.contract == null || contractCallParam.contractName == null
                    || contractCallParam.functionName == null) {
                    return Promise.reject(coin_base_1.SignTxError);
                }
                const tx = await (0, index_1.allowContractCaller)(param.privateKey, contractCallParam.caller, contractCallParam.contract, contractCallParam.contractName, contractCallParam.functionName, contractCallParam.untilBurnBlockHeight, contractCallParam.nonce, contractCallParam.fee);
                return Promise.resolve(tx);
            }
            else if (data.type == 'delegateStx') {
                const delegateStxParam = data.data;
                if (delegateStxParam.contract == null || delegateStxParam.contractName == null || delegateStxParam.functionName == null
                    || delegateStxParam.amountMicroStx == null || delegateStxParam.delegateTo == null) {
                    return Promise.reject(coin_base_1.SignTxError);
                }
                const tx = await (0, index_1.delegateStx)(param.privateKey, delegateStxParam.contract, delegateStxParam.contractName, delegateStxParam.functionName, delegateStxParam.delegateTo, delegateStxParam.poxAddress, delegateStxParam.amountMicroStx, delegateStxParam.untilBurnBlockHeight, delegateStxParam.nonce, delegateStxParam.fee);
                return Promise.resolve(tx);
            }
            else if (data.type == 'revokeDelegateStx') {
                const revokeDelegateStxParam = data.data;
                if (revokeDelegateStxParam.contract == null || revokeDelegateStxParam.contractName == null || revokeDelegateStxParam.functionName == null) {
                    return Promise.reject(coin_base_1.SignTxError);
                }
                const tx = await (0, index_1.revokeDelegateStx)(param.privateKey, revokeDelegateStxParam.contract, revokeDelegateStxParam.contractName, revokeDelegateStxParam.functionName, revokeDelegateStxParam.nonce, revokeDelegateStxParam.fee);
                return Promise.resolve(tx);
            }
            else if (data.type == 'contractCall') {
                const contractCallParam = data.data;
                const tx = await (0, index_1.makeContractCallTx)(contractCallParam, param.privateKey);
                return Promise.resolve(tx);
            }
            else if (data.type == 'deployContract') {
                const contractCallParam = data.data;
                const tx = await (0, index_1.ContractDeployTx)(contractCallParam, param.privateKey);
                return Promise.resolve(tx);
            }
            return Promise.reject(coin_base_1.SignTxError);
        }
        catch (e) {
            return Promise.reject(e);
        }
    }
    async signMessage(param) {
        try {
            if (param.privateKey.startsWith("0x")) {
                param.privateKey = param.privateKey.substring(2);
            }
            const privateKey = (0, index_1.createStacksPrivateKey)(param.privateKey);
            if (param.data.type == "signMessage") {
                const messageHash = (0, index_1.hashMessage)(param.data.message);
                const signature = (0, index_1.signMessageHashRsv)({
                    messageHash: (0, index_1.bytesToHex)(messageHash),
                    privateKey: privateKey
                });
                return Promise.resolve({ signature: signature.data, publicKey: (0, index_1.publicKeyToString)((0, index_1.getPublicKey)(privateKey)) });
            }
            else if (param.data.type == "signStructuredData") {
                const message = param.data.message;
                const domain = param.data.domain;
                const signature = (0, index_1.signStructuredData)({ message, domain, privateKey }).data;
                return Promise.resolve({
                    signature: signature,
                    publicKey: (0, index_1.publicKeyToString)((0, index_1.getPublicKey)(privateKey))
                });
            }
        }
        catch (e) {
            return Promise.reject(coin_base_1.SignMsgError);
        }
    }
    async verifyMessage(param) {
        try {
            const d = param.data;
            if (d.publicKey === undefined) {
                return Promise.reject(coin_base_1.SignMsgError);
            }
            const signature = param.signature;
            const message = (0, index_1.hashMessage)(param.data.message);
            const publicKey = d.publicKey;
            return Promise.resolve((0, index_1.verifyMessageSignatureRsv)({ signature, message, publicKey }));
        }
        catch (e) {
            return Promise.reject(e);
        }
    }
    validAddress(param) {
        let isValid;
        try {
            isValid = (0, index_1.validateStacksAddress)(param.address);
        }
        catch (e) {
            isValid = false;
        }
        let data = {
            isValid: isValid,
            address: param.address,
        };
        return Promise.resolve(data);
    }
    getRawTransaction(param) {
        try {
            const data = param.data;
            if (data.type == 'transfer') {
                const transferParam = data.data;
                if (transferParam.to == null || transferParam.amount == null) {
                    return Promise.reject(coin_base_1.GetPayLoadError);
                }
                const serializePayload = (0, index_1.getTransferPayload)(transferParam.to, transferParam.amount, transferParam.memo);
                return Promise.resolve(serializePayload);
            }
            else if (data.type == 'tokenTransfer') {
                const contractCallParam = data.data;
                if (contractCallParam.from == null || contractCallParam.to == null || contractCallParam.amount == null || contractCallParam.contract == null
                    || contractCallParam.contractName == null || contractCallParam.functionName == null) {
                    return Promise.reject(coin_base_1.GetPayLoadError);
                }
                const serializePayload = (0, index_1.getTokenTransferPayload)(contractCallParam.from, contractCallParam.to, contractCallParam.memo, contractCallParam.amount, contractCallParam.contract, contractCallParam.contractName, contractCallParam.functionName);
                return Promise.resolve(serializePayload);
            }
            else if (data.type == 'allowContractCaller') {
                const contractCallParam = data.data;
                if (contractCallParam.caller == null || contractCallParam.contract == null || contractCallParam.contractName == null
                    || contractCallParam.functionName == null) {
                    return Promise.reject(coin_base_1.GetPayLoadError);
                }
                const serializePayload = (0, index_1.getAllowContractCallerPayload)(contractCallParam.caller, contractCallParam.contract, contractCallParam.contractName, contractCallParam.functionName, contractCallParam.untilBurnBlockHeight);
                return Promise.resolve(serializePayload);
            }
            else if (data.type == 'delegateStx') {
                const delegateStxParam = data.data;
                if (delegateStxParam.contract == null || delegateStxParam.contractName == null || delegateStxParam.functionName == null
                    || delegateStxParam.amountMicroStx == null || delegateStxParam.delegateTo == null) {
                    return Promise.reject(coin_base_1.GetPayLoadError);
                }
                const serializePayload = (0, index_1.getDelegateStxPayload)(delegateStxParam.contract, delegateStxParam.contractName, delegateStxParam.functionName, delegateStxParam.delegateTo, delegateStxParam.poxAddress, delegateStxParam.amountMicroStx, delegateStxParam.untilBurnBlockHeight);
                return Promise.resolve(serializePayload);
            }
            else if (data.type == 'revokeDelegateStx') {
                const delegateStxParam = data.data;
                if (delegateStxParam.contract == null || delegateStxParam.contractName == null || delegateStxParam.functionName == null) {
                    return Promise.reject(coin_base_1.GetPayLoadError);
                }
                const serializePayload = (0, index_1.getRevokeDelegateStxPayload)(delegateStxParam.contract, delegateStxParam.contractName, delegateStxParam.functionName);
                return Promise.resolve(serializePayload);
            }
            else if (data.type == 'contractCall') {
                const contractCallParam = data.data;
                const serializePayload = (0, index_1.getContractCallPayload)(contractCallParam.contract, contractCallParam.contractName, contractCallParam.functionName, contractCallParam.functionArgs);
                return Promise.resolve(serializePayload);
            }
            else if (data.type == 'deployContract') {
                const deployPayload = data.data;
                const serializePayload = (0, index_1.getDeployPayload)(deployPayload.contractName, deployPayload.codeBody);
                return Promise.resolve(serializePayload);
            }
            return Promise.reject(coin_base_1.GetPayLoadError);
        }
        catch (e) {
            return Promise.reject(coin_base_1.GetPayLoadError);
        }
    }
}
exports.StxWallet = StxWallet;
//# sourceMappingURL=Stxwallet.js.map