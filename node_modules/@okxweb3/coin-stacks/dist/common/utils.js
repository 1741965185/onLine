"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isInstance = exports.concatArray = exports.concatBytes = exports.toBytes = exports.octetsToBytes = exports.bytesToAscii = exports.asciiToBytes = exports.bytesToUtf8 = exports.utf8ToBytes = exports.hexToBytes = exports.bytesToHex = exports.fromTwos = exports.toTwos = exports.bigIntToBytes = exports.hexToInt = exports.intToHex = exports.hexToBigInt = exports.with0x = exports.intToBigInt = exports.intToBytes = void 0;
function intToBytes(value, signed, byteLength) {
    return bigIntToBytes(intToBigInt(value, signed), byteLength);
}
exports.intToBytes = intToBytes;
function intToBigInt(value, signed) {
    let parsedValue = value;
    if (typeof parsedValue === 'number') {
        if (!Number.isInteger(parsedValue)) {
            throw new RangeError(`Invalid value. Values of type 'number' must be an integer.`);
        }
        return BigInt(parsedValue);
    }
    if (typeof parsedValue === 'string') {
        if (parsedValue.toLowerCase().startsWith('0x')) {
            let hex = parsedValue.slice(2);
            hex = hex.padStart(hex.length + (hex.length % 2), '0');
            parsedValue = hexToBytes(hex);
        }
        else {
            try {
                return BigInt(parsedValue);
            }
            catch (error) {
                if (error instanceof SyntaxError) {
                    throw new RangeError(`Invalid value. String integer '${parsedValue}' is not finite.`);
                }
            }
        }
    }
    if (typeof parsedValue === 'bigint') {
        return parsedValue;
    }
    if (parsedValue instanceof Uint8Array) {
        if (signed) {
            const bn = fromTwos(BigInt(`0x${bytesToHex(parsedValue)}`), BigInt(parsedValue.byteLength * 8));
            return BigInt(bn.toString());
        }
        else {
            return BigInt(`0x${bytesToHex(parsedValue)}`);
        }
    }
    if (parsedValue != null &&
        typeof parsedValue === 'object' &&
        parsedValue.constructor.name === 'BN') {
        return BigInt(parsedValue.toString());
    }
    throw new TypeError(`Invalid value type. Must be a number, bigint, integer-string, hex-string, or Uint8Array.`);
}
exports.intToBigInt = intToBigInt;
function with0x(value) {
    return value.startsWith('0x') ? value : `0x${value}`;
}
exports.with0x = with0x;
function hexToBigInt(hex) {
    if (typeof hex !== 'string')
        throw new TypeError(`hexToBigInt: expected string, got ${typeof hex}`);
    return BigInt(`0x${hex}`);
}
exports.hexToBigInt = hexToBigInt;
function intToHex(integer, lengthBytes = 8) {
    const value = typeof integer === 'bigint' ? integer : intToBigInt(integer, false);
    return value.toString(16).padStart(lengthBytes * 2, '0');
}
exports.intToHex = intToHex;
function hexToInt(hex) {
    return parseInt(hex, 16);
}
exports.hexToInt = hexToInt;
function bigIntToBytes(value, length = 16) {
    const hex = intToHex(value, length);
    return hexToBytes(hex);
}
exports.bigIntToBytes = bigIntToBytes;
function toTwos(value, width) {
    if (value < -(BigInt(1) << (width - BigInt(1))) ||
        (BigInt(1) << (width - BigInt(1))) - BigInt(1) < value) {
        throw `Unable to represent integer in width: ${width}`;
    }
    if (value >= BigInt(0)) {
        return BigInt(value);
    }
    return value + (BigInt(1) << width);
}
exports.toTwos = toTwos;
function nthBit(value, n) {
    return value & (BigInt(1) << n);
}
function fromTwos(value, width) {
    if (nthBit(value, width - BigInt(1))) {
        return value - (BigInt(1) << width);
    }
    return value;
}
exports.fromTwos = fromTwos;
const hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
function bytesToHex(uint8a) {
    if (!(uint8a instanceof Uint8Array))
        throw new Error('Uint8Array expected');
    let hex = '';
    for (const u of uint8a) {
        hex += hexes[u];
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
function hexToBytes(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError(`hexToBytes: expected string, got ${typeof hex}`);
    }
    const paddedHex = hex.length % 2 ? `0${hex}` : hex;
    const array = new Uint8Array(paddedHex.length / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = paddedHex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
            throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
function utf8ToBytes(str) {
    return new TextEncoder().encode(str);
}
exports.utf8ToBytes = utf8ToBytes;
function bytesToUtf8(arr) {
    return new TextDecoder().decode(arr);
}
exports.bytesToUtf8 = bytesToUtf8;
function asciiToBytes(str) {
    const byteArray = [];
    for (let i = 0; i < str.length; i++) {
        byteArray.push(str.charCodeAt(i) & 0xff);
    }
    return new Uint8Array(byteArray);
}
exports.asciiToBytes = asciiToBytes;
function bytesToAscii(arr) {
    return String.fromCharCode.apply(null, arr);
}
exports.bytesToAscii = bytesToAscii;
function isNotOctet(octet) {
    return !Number.isInteger(octet) || octet < 0 || octet > 255;
}
function octetsToBytes(numbers) {
    if (numbers.some(isNotOctet))
        throw new Error('Some values are invalid bytes.');
    return new Uint8Array(numbers);
}
exports.octetsToBytes = octetsToBytes;
function toBytes(data) {
    if (typeof data === 'string')
        return utf8ToBytes(data);
    if (data instanceof Uint8Array)
        return data;
    throw new TypeError(`Expected input type is (Uint8Array | string) but got (${typeof data})`);
}
exports.toBytes = toBytes;
function concatBytes(...arrays) {
    if (!arrays.every(a => a instanceof Uint8Array))
        throw new Error('Uint8Array list expected');
    if (arrays.length === 1)
        return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
exports.concatBytes = concatBytes;
function concatArray(elements) {
    return concatBytes(...elements.map(e => {
        if (typeof e === 'number')
            return octetsToBytes([e]);
        if (e instanceof Array)
            return octetsToBytes(e);
        return e;
    }));
}
exports.concatArray = concatArray;
function isInstance(object, type) {
    return object instanceof type || object?.constructor?.name?.toLowerCase() === type.name;
}
exports.isInstance = isInstance;
//# sourceMappingURL=utils.js.map