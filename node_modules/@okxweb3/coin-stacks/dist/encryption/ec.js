"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyMessageSignatureRsv = exports.verifyMessageSignature = exports.verifyECDSA = exports.signECDSA = exports.eciesGetJsonStringLength = exports.getSignedCipherObjectWrapper = exports.getCipherObjectWrapper = exports.getBytesFromBN = exports.getHexFromBN = exports.hmacSha256 = exports.InvalidPublicKeyReason = void 0;
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const signSync = crypto_lib_1.secp256k1.signSync;
const utils = crypto_lib_1.secp256k1.utils;
const common_1 = require("../common");
const keys_1 = require("./keys");
const messageSignature_1 = require("./messageSignature");
const sha2Hash_1 = require("./sha2Hash");
const utils_1 = require("./utils");
utils.hmacSha256Sync = (key, ...msgs) => {
    const h = crypto_lib_1.base.hmac.create(crypto_lib_1.base.sha256, key);
    msgs.forEach(msg => h.update(msg));
    return h.digest();
};
var InvalidPublicKeyReason;
(function (InvalidPublicKeyReason) {
    InvalidPublicKeyReason["InvalidFormat"] = "InvalidFormat";
    InvalidPublicKeyReason["IsNotPoint"] = "IsNotPoint";
})(InvalidPublicKeyReason = exports.InvalidPublicKeyReason || (exports.InvalidPublicKeyReason = {}));
function hmacSha256(key, content) {
    return crypto_lib_1.base.hmac(crypto_lib_1.base.sha256, key, content);
}
exports.hmacSha256 = hmacSha256;
function equalsConstTime(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    let res = 0;
    for (let i = 0; i < a.length; i++) {
        res |= a[i] ^ b[i];
    }
    return res === 0;
}
function sharedSecretToKeys(sharedSecret) {
    const hashedSecret = (0, sha2Hash_1.hashSha512Sync)(sharedSecret);
    return {
        encryptionKey: hashedSecret.slice(0, 32),
        hmacKey: hashedSecret.slice(32),
    };
}
function allHexChars(maybe) {
    return maybe.match(/^[0-9a-f]+$/i) !== null;
}
function isValidPublicKey(pub) {
    const invalidFormat = {
        result: false,
        reason_data: 'Invalid public key format',
        reason: InvalidPublicKeyReason.InvalidFormat,
    };
    const invalidPoint = {
        result: false,
        reason_data: 'Public key is not a point',
        reason: InvalidPublicKeyReason.IsNotPoint,
    };
    if (pub.length !== 66 && pub.length !== 130)
        return invalidFormat;
    const firstByte = pub.slice(0, 2);
    if (pub.length === 130 && firstByte !== '04')
        return invalidFormat;
    if (pub.length === 66 && firstByte !== '02' && firstByte !== '03')
        return invalidFormat;
    if (!allHexChars(pub))
        return invalidFormat;
    try {
        const point = crypto_lib_1.secp256k1.Point.fromHex(pub);
        point.assertValidity();
        return {
            result: true,
            reason_data: null,
            reason: null,
        };
    }
    catch (e) {
        return invalidPoint;
    }
}
function getHexFromBN(bnInput) {
    const hexOut = bnInput.toString(16);
    if (hexOut.length === 64) {
        return hexOut;
    }
    else if (hexOut.length < 64) {
        const padding = '0'.repeat(64 - hexOut.length);
        return `${padding}${hexOut}`;
    }
    else {
        throw new Error('Generated a > 32-byte BN for encryption. Failing.');
    }
}
exports.getHexFromBN = getHexFromBN;
function getBytesFromBN(bnInput) {
    const result = (0, common_1.bigIntToBytes)(bnInput, 32);
    if (result.byteLength !== 32) {
        throw new Error('Failed to generate a 32-byte Uint8Array');
    }
    return result;
}
exports.getBytesFromBN = getBytesFromBN;
function getCipherObjectWrapper(opts) {
    const shell = {
        iv: '',
        ephemeralPK: '',
        mac: '',
        cipherText: '',
        wasString: !!opts.wasString,
    };
    if (opts.cipherTextEncoding === 'base64') {
        shell.cipherTextEncoding = 'base64';
    }
    const ivLength = 32;
    const ephemeralPKLength = 66;
    const macLength = 64;
    return {
        payloadValuesLength: ivLength + ephemeralPKLength + macLength,
        payloadShell: JSON.stringify(shell),
    };
}
exports.getCipherObjectWrapper = getCipherObjectWrapper;
function getSignedCipherObjectWrapper(payloadShell) {
    const shell = {
        signature: '',
        publicKey: '',
        cipherText: payloadShell,
    };
    const signatureLength = 144;
    const publicKeyLength = 66;
    return {
        signedPayloadValuesLength: signatureLength + publicKeyLength,
        signedPayloadShell: JSON.stringify(shell),
    };
}
exports.getSignedCipherObjectWrapper = getSignedCipherObjectWrapper;
function eciesGetJsonStringLength(opts) {
    const { payloadShell, payloadValuesLength } = getCipherObjectWrapper(opts);
    const cipherTextLength = (0, utils_1.getAesCbcOutputLength)(opts.contentLength);
    let encodedCipherTextLength;
    if (!opts.cipherTextEncoding || opts.cipherTextEncoding === 'hex') {
        encodedCipherTextLength = cipherTextLength * 2;
    }
    else if (opts.cipherTextEncoding === 'base64') {
        encodedCipherTextLength = (0, utils_1.getBase64OutputLength)(cipherTextLength);
    }
    else {
        throw new Error(`Unexpected cipherTextEncoding "${opts.cipherTextEncoding}"`);
    }
    if (!opts.sign) {
        return payloadShell.length + payloadValuesLength + encodedCipherTextLength;
    }
    else {
        const { signedPayloadShell, signedPayloadValuesLength } = getSignedCipherObjectWrapper(payloadShell);
        return (signedPayloadShell.length +
            signedPayloadValuesLength +
            payloadValuesLength +
            encodedCipherTextLength);
    }
}
exports.eciesGetJsonStringLength = eciesGetJsonStringLength;
function signECDSA(privateKey, content) {
    const contentBytes = typeof content === 'string' ? (0, common_1.utf8ToBytes)(content) : content;
    const publicKey = (0, keys_1.getPublicKeyFromPrivate)(privateKey);
    const contentHash = (0, sha2Hash_1.hashSha256Sync)(contentBytes);
    const signature = signSync(contentHash, privateKey);
    return {
        signature: (0, common_1.bytesToHex)(signature),
        publicKey,
    };
}
exports.signECDSA = signECDSA;
function verifyECDSA(content, publicKey, signature) {
    const contentBytes = typeof content === 'string' ? (0, common_1.utf8ToBytes)(content) : content;
    const contentHash = (0, sha2Hash_1.hashSha256Sync)(contentBytes);
    return crypto_lib_1.secp256k1.verify(signature, contentHash, publicKey, { strict: false });
}
exports.verifyECDSA = verifyECDSA;
function verifyMessageSignature({ signature, message, publicKey, }) {
    const { r, s } = (0, common_1.parseRecoverableSignatureVrs)(signature);
    const sig = new crypto_lib_1.secp256k1.Signature((0, common_1.hexToBigInt)(r), (0, common_1.hexToBigInt)(s));
    const hashedMsg = typeof message === 'string' ? (0, messageSignature_1.hashMessage)(message) : message;
    const verificationResult = crypto_lib_1.secp256k1.verify(sig, hashedMsg, publicKey, { strict: false });
    if (verificationResult || typeof message !== 'string')
        return verificationResult;
    const LEGACY_PREFIX = '\x18Stacks Message Signing:\n';
    const legacyHash = crypto_lib_1.base.sha256((0, messageSignature_1.encodeMessage)(message, LEGACY_PREFIX));
    return crypto_lib_1.secp256k1.verify(sig, legacyHash, publicKey, { strict: false });
}
exports.verifyMessageSignature = verifyMessageSignature;
function verifyMessageSignatureRsv({ signature, message, publicKey, }) {
    return verifyMessageSignature({
        signature: (0, common_1.signatureRsvToVrs)(signature),
        message,
        publicKey,
    });
}
exports.verifyMessageSignatureRsv = verifyMessageSignatureRsv;
//# sourceMappingURL=ec.js.map