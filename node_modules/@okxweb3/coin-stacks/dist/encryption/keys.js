"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compressPrivateKey = exports.isValidPrivateKey = exports.ecSign = exports.getPublicKeyFromPrivate = exports.publicKeyToBtcAddress = exports.base58CheckEncode = exports.base58Encode = exports.base58CheckDecode = exports.makeECPrivateKey = void 0;
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const nobleGetPublicKey = crypto_lib_1.secp256k1.getPublicKey;
const signSync = crypto_lib_1.secp256k1.signSync;
const utils = crypto_lib_1.secp256k1.utils;
const common_1 = require("../common");
const hashRipemd160_1 = require("./hashRipemd160");
const sha2Hash_1 = require("./sha2Hash");
const BITCOIN_PUBKEYHASH = 0x00;
utils.hmacSha256Sync = (key, ...msgs) => {
    const h = crypto_lib_1.base.hmac.create(crypto_lib_1.base.sha256, key);
    msgs.forEach(msg => h.update(msg));
    return h.digest();
};
function makeECPrivateKey() {
    return (0, common_1.bytesToHex)(utils.randomPrivateKey());
}
exports.makeECPrivateKey = makeECPrivateKey;
function base58CheckDecode(btcAddress) {
    const bytes = crypto_lib_1.base.base58.decode(btcAddress);
    const payload = bytes.slice(0, -4);
    const checksum = bytes.slice(-4);
    const newChecksum = crypto_lib_1.base.sha256(crypto_lib_1.base.sha256(payload));
    if ((checksum[0] ^ newChecksum[0]) |
        (checksum[1] ^ newChecksum[1]) |
        (checksum[2] ^ newChecksum[2]) |
        (checksum[3] ^ newChecksum[3])) {
        throw new Error('Invalid checksum');
    }
    if (payload.length !== 21)
        throw new TypeError('Invalid address length');
    const version = (0, common_1.readUInt8)(payload, 0);
    const hash = payload.slice(1);
    return { version, hash };
}
exports.base58CheckDecode = base58CheckDecode;
function base58Encode(hash) {
    const checksum = crypto_lib_1.base.sha256(crypto_lib_1.base.sha256(hash));
    return crypto_lib_1.base.base58.encode((0, common_1.concatBytes)(hash, checksum).slice(0, hash.length + 4));
}
exports.base58Encode = base58Encode;
function base58CheckEncode(version, hash) {
    return base58Encode((0, common_1.concatBytes)(new Uint8Array([version]), hash.slice(0, 20)));
}
exports.base58CheckEncode = base58CheckEncode;
function publicKeyToBtcAddress(publicKey, version = BITCOIN_PUBKEYHASH) {
    const publicKeyBytes = typeof publicKey === 'string' ? (0, common_1.hexToBytes)(publicKey) : publicKey;
    const publicKeyHash160 = (0, hashRipemd160_1.hashRipemd160)((0, sha2Hash_1.hashSha256Sync)(publicKeyBytes));
    return base58CheckEncode(version, publicKeyHash160);
}
exports.publicKeyToBtcAddress = publicKeyToBtcAddress;
function getPublicKeyFromPrivate(privateKey) {
    const privateKeyBytes = (0, common_1.privateKeyToBytes)(privateKey);
    return (0, common_1.bytesToHex)(nobleGetPublicKey(privateKeyBytes.slice(0, 32), true));
}
exports.getPublicKeyFromPrivate = getPublicKeyFromPrivate;
function ecSign(messageHash, hexPrivateKey) {
    return signSync(messageHash, (0, common_1.privateKeyToBytes)(hexPrivateKey).slice(0, 32), {
        der: false,
    });
}
exports.ecSign = ecSign;
function isValidPrivateKey(privateKey) {
    return utils.isValidPrivateKey((0, common_1.privateKeyToBytes)(privateKey));
}
exports.isValidPrivateKey = isValidPrivateKey;
function compressPrivateKey(privateKey) {
    const privateKeyBytes = (0, common_1.privateKeyToBytes)(privateKey);
    return privateKeyBytes.length == common_1.PRIVATE_KEY_COMPRESSED_LENGTH
        ? privateKeyBytes
        : (0, common_1.concatBytes)(privateKeyBytes, new Uint8Array([1]));
}
exports.compressPrivateKey = compressPrivateKey;
//# sourceMappingURL=keys.js.map