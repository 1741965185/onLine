import { AnchorMode, PostConditionMode } from './transactions';
export declare function transfer(secretKey: string, to: string, amount: number, memo: string, nonce: number, fee: number, anchorMode?: number): {
    txId: string;
    txSerializedHexString: string;
};
export declare function stacks(privateKey: string, address: string, poxAddress: string, amountMicroStx: bigint, cycles: number, burnBlockHeight: number, contract: string, fee: number, nonce: number): Promise<any>;
export declare function tokenTransfer(secretKey: string, from: string, to: string, memo: string, amount: number, contract: string, contractName: string, tokenName: string, functionName: string, nonce: number, fee: number): Promise<{
    txId: string;
    txSerializedHexString: string;
}>;
export declare function allowContractCaller(secretKey: string, caller: string, contract: string, contractName: string, functionName: string, untilBurnBlockHeight: number, nonce: number, fee: number): Promise<{
    txId: string;
    txSerializedHexString: string;
}>;
interface GenerateUnsignedTxArgs<TxPayload> {
    txData: TxPayload;
    fee: number;
    nonce: number;
}
export interface TxBase {
    postConditionMode?: PostConditionMode;
    postConditions?: string[];
    anchorMode?: AnchorMode;
}
export interface ContractCallBase extends TxBase {
    contractAddress: string;
    contractName: string;
    functionName: string;
    functionArgs: string[];
}
interface ContractCallPayload extends ContractCallBase {
    functionArgs: string[];
    sponsored?: boolean;
}
export interface ContractDeployPayload extends TxBase {
    contractName: string;
    codeBody: string;
    sponsored?: boolean;
}
export type GenerateUnsignedContractCallTxArgs = GenerateUnsignedTxArgs<ContractCallPayload>;
export type GenerateUnsignedContractDeployTxArgs = GenerateUnsignedTxArgs<ContractDeployPayload>;
export declare enum TransactionTypes {
    ContractCall = "contract_call",
    ContractDeploy = "smart_contract",
    STXTransfer = "token_transfer"
}
export declare function makeContractCallTx(args: GenerateUnsignedContractCallTxArgs, senderKey: string): Promise<{
    txId: string;
    txSerializedHexString: string;
}>;
export declare function ContractDeployTx(args: GenerateUnsignedContractDeployTxArgs, senderKey: string): Promise<{
    txId: string;
    txSerializedHexString: string;
}>;
export declare function delegateStx(secretKey: string, contract: string, contractName: string, functionName: string, delegateTo: string, poxAddress: string, amountMicroStx: number, untilBurnBlockHeight: number, nonce: number, fee: number): Promise<{
    txId: string;
    txSerializedHexString: string;
}>;
export declare function revokeDelegateStx(secretKey: string, contract: string, contractName: string, functionName: string, nonce: number, fee: number): Promise<{
    txId: string;
    txSerializedHexString: string;
}>;
export declare function getTransferPayload(to: string, amount: number, memo: string): string;
export declare function getTokenTransferPayload(from: string, to: string, memo: string, amount: number, contract: string, contractName: string, functionName: string): string;
export declare function getAllowContractCallerPayload(caller: string, contract: string, contractName: string, functionName: string, untilBurnBlockHeight: number): string;
export declare function getDelegateStxPayload(contract: string, contractName: string, functionName: string, delegateTo: string, poxAddress: string, amountMicroStx: number, untilBurnBlockHeight: number): string;
export declare function getRevokeDelegateStxPayload(contract: string, contractName: string, functionName: string): string;
export declare function getContractCallPayload(contract: string, contractName: string, functionName: string, functionArgs: string[]): string;
export declare function getDeployPayload(contractName: string, codeBody: string): string;
export {};
